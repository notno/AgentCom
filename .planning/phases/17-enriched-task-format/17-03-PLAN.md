---
phase: 17-enriched-task-format
plan: 03
type: execute
wave: 2
depends_on: ["17-01", "17-02"]
files_modified:
  - lib/agent_com/task_queue.ex
  - lib/agent_com/scheduler.ex
  - lib/agent_com/socket.ex
  - lib/agent_com/endpoint.ex
  - sidecar/index.js
  - test/agent_com/task_queue_test.exs
autonomous: true

must_haves:
  truths:
    - "A task submitted with context fields arrives at the sidecar with those fields intact in the task_assign WebSocket push"
    - "A task submitted with success criteria and verification steps is retrievable through the full pipeline (submit, assign, complete) with fields intact"
    - "A task submitted with an explicit complexity tier carries that classification through assignment to the sidecar"
    - "A task submitted without a complexity tier receives an inferred classification from the heuristic engine"
    - "Existing v1.0/v1.1 tasks (without enrichment fields) continue working unchanged through the full pipeline"
    - "When explicit tier disagrees with inferred tier, a telemetry event is emitted and both are preserved"
  artifacts:
    - path: "lib/agent_com/task_queue.ex"
      provides: "Complexity.build wired into submit handler"
      contains: "AgentCom.Complexity.build"
    - path: "lib/agent_com/scheduler.ex"
      provides: "Enrichment fields passed in task_data push to Socket"
      contains: "file_hints"
    - path: "lib/agent_com/socket.ex"
      provides: "Enrichment fields included in task_assign WebSocket message"
      contains: "file_hints"
    - path: "sidecar/index.js"
      provides: "Sidecar stores enrichment fields from task_assign"
      contains: "file_hints"
  key_links:
    - from: "lib/agent_com/task_queue.ex"
      to: "lib/agent_com/complexity.ex"
      via: "TaskQueue.submit calls Complexity.build to compute complexity"
      pattern: "AgentCom\\.Complexity\\.build"
    - from: "lib/agent_com/scheduler.ex"
      to: "lib/agent_com/socket.ex"
      via: "Scheduler sends enrichment fields in task_data, Socket pushes to sidecar"
      pattern: "file_hints.*task_data|push_task.*file_hints"
    - from: "lib/agent_com/socket.ex"
      to: "sidecar/index.js"
      via: "Socket pushes task_assign with enrichment fields, sidecar receives and stores"
      pattern: "task_assign.*file_hints"
    - from: "lib/agent_com/endpoint.ex"
      to: "lib/agent_com/task_queue.ex"
      via: "Endpoint passes complexity_tier to TaskQueue, which feeds it to Complexity.build"
      pattern: "complexity_tier"
---

<objective>
Wire the complexity engine into task submission and propagate all enrichment fields through the full pipeline: TaskQueue -> Scheduler -> Socket -> Sidecar.

Purpose: This completes Phase 17 by connecting Plan 01 (Complexity module) and Plan 02 (enrichment fields in task map) into the full task lifecycle. After this plan, enrichment fields flow end-to-end from HTTP submission to sidecar receipt, and complexity classification happens automatically at submission time.

Output: Complete enriched task pipeline. All 5 success criteria from the roadmap are satisfied.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-enriched-task-format/17-RESEARCH.md
@.planning/phases/17-enriched-task-format/17-01-SUMMARY.md
@.planning/phases/17-enriched-task-format/17-02-SUMMARY.md
@lib/agent_com/task_queue.ex
@lib/agent_com/scheduler.ex
@lib/agent_com/socket.ex
@lib/agent_com/endpoint.ex
@lib/agent_com/complexity.ex
@sidecar/index.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire Complexity.build into TaskQueue.submit and pass complexity_tier from Endpoint</name>
  <files>lib/agent_com/task_queue.ex, lib/agent_com/endpoint.ex, test/agent_com/task_queue_test.exs</files>
  <action>
    **In `lib/agent_com/task_queue.ex`:**

    1. In `handle_call({:submit, params}, _from, state)`, replace the `complexity: nil` placeholder (added in Plan 02) with a call to `AgentCom.Complexity.build(params)`:
       ```elixir
       complexity: AgentCom.Complexity.build(params)
       ```
       This passes the full params map to the heuristic engine. The Complexity module handles:
       - Extracting explicit tier from `complexity_tier` key
       - Running heuristic inference on description, file_hints, verification_steps
       - Returning the combined classification map

    2. After building the task map, check for disagreement between explicit and inferred tiers. If `complexity.explicit_tier` is not nil and `complexity.explicit_tier != complexity.inferred.tier`, emit a telemetry event:
       ```elixir
       if complexity.explicit_tier && complexity.explicit_tier != complexity.inferred.tier do
         :telemetry.execute(
           [:agent_com, :complexity, :disagreement],
           %{},
           %{
             task_id: task_id,
             explicit_tier: complexity.explicit_tier,
             inferred_tier: complexity.inferred.tier,
             inferred_confidence: complexity.inferred.confidence
           }
         )
       end
       ```
       Place this AFTER persist_task but BEFORE the reply, so the telemetry is non-blocking.

    **In `lib/agent_com/endpoint.ex`:**

    3. In the `POST /api/tasks` route, add `complexity_tier` to `task_params`:
       ```elixir
       task_params = %{
         # ... existing fields including enrichment from Plan 02 ...
         complexity_tier: params["complexity_tier"]
       }
       ```
       The Complexity module reads this from params to determine explicit tier.

    **In `test/agent_com/task_queue_test.exs`:**

    4. Add tests in the existing "enriched task submission" describe block (from Plan 02):
       - Submit task with `complexity_tier: "standard"` -- verify `task.complexity.effective_tier == :standard` and `task.complexity.source == :explicit`
       - Submit task without complexity_tier but with a long description -- verify `task.complexity.effective_tier` is inferred (not nil) and `task.complexity.source == :inferred`
       - Submit task with complexity_tier that disagrees with content (e.g., `complexity_tier: "trivial"` but complex description) -- verify effective_tier is :trivial (explicit wins) and inferred tier differs
       - Submit task with no enrichment at all (backward compat) -- verify `task.complexity` is a map with `effective_tier: :unknown` and `source: :inferred`
  </action>
  <verify>
    `mix test test/agent_com/task_queue_test.exs` -- all tests pass.
    `mix test test/agent_com/complexity_test.exs` -- still passing.
    `mix compile --warnings-as-errors` -- no warnings.
  </verify>
  <done>
    TaskQueue.submit calls Complexity.build for every task submission. Explicit tiers are honored, inferred tiers fill the gap, disagreements emit telemetry. Backward-compatible tasks get :unknown inference.
  </done>
</task>

<task type="auto">
  <name>Task 2: Propagate enrichment fields through Scheduler, Socket, and Sidecar</name>
  <files>lib/agent_com/scheduler.ex, lib/agent_com/socket.ex, sidecar/index.js</files>
  <action>
    **In `lib/agent_com/scheduler.ex`:**

    1. In `do_assign/2` (line ~229), expand the `task_data` map to include all enrichment fields. Use `Map.get/3` with defaults for backward compatibility with any tasks already in DETS that lack these fields:
       ```elixir
       task_data = %{
         task_id: assigned_task.id,
         description: assigned_task.description,
         metadata: assigned_task.metadata,
         generation: assigned_task.generation,
         # Enrichment fields (Phase 17)
         repo: Map.get(assigned_task, :repo),
         branch: Map.get(assigned_task, :branch),
         file_hints: Map.get(assigned_task, :file_hints, []),
         success_criteria: Map.get(assigned_task, :success_criteria, []),
         verification_steps: Map.get(assigned_task, :verification_steps, []),
         complexity: Map.get(assigned_task, :complexity)
       }
       ```

    **In `lib/agent_com/socket.ex`:**

    2. In `handle_info({:push_task, task}, state)` (line ~170), expand the push map to include enrichment fields. Use the same `task["key"] || task[:key]` pattern already used for existing fields, with safe defaults:
       ```elixir
       push = %{
         "type" => "task_assign",
         "task_id" => task["task_id"] || task[:task_id],
         "description" => task["description"] || task[:description] || "",
         "metadata" => task["metadata"] || task[:metadata] || %{},
         "generation" => task["generation"] || task[:generation] || 0,
         "assigned_at" => System.system_time(:millisecond),
         # Enrichment fields (Phase 17)
         "repo" => task["repo"] || task[:repo],
         "branch" => task["branch"] || task[:branch],
         "file_hints" => task["file_hints"] || task[:file_hints] || [],
         "success_criteria" => task["success_criteria"] || task[:success_criteria] || [],
         "verification_steps" => task["verification_steps"] || task[:verification_steps] || [],
         "complexity" => format_complexity_for_ws(task["complexity"] || task[:complexity])
       }
       ```

    3. Add a private helper `format_complexity_for_ws/1` that converts the complexity map to JSON-safe format (atom keys to strings, atom values to strings):
       ```elixir
       defp format_complexity_for_ws(nil), do: nil
       defp format_complexity_for_ws(c) when is_map(c) do
         %{
           "effective_tier" => to_string(Map.get(c, :effective_tier, Map.get(c, "effective_tier"))),
           "source" => to_string(Map.get(c, :source, Map.get(c, "source"))),
           "explicit_tier" => case Map.get(c, :explicit_tier, Map.get(c, "explicit_tier")) do
             nil -> nil
             t -> to_string(t)
           end,
           "inferred" => case Map.get(c, :inferred, Map.get(c, "inferred")) do
             nil -> nil
             inf -> %{
               "tier" => to_string(Map.get(inf, :tier, Map.get(inf, "tier"))),
               "confidence" => Map.get(inf, :confidence, Map.get(inf, "confidence"))
             }
           end
         }
       end
       ```

    **In `sidecar/index.js`:**

    4. In the `handleTaskAssign(msg)` method (line ~506), expand the task object to store enrichment fields from the task_assign message:
       ```javascript
       const task = {
         task_id: msg.task_id,
         description: msg.description,
         metadata: msg.metadata || {},
         status: 'accepted',
         assigned_at: msg.assigned_at || Date.now(),
         generation: msg.generation || 0,
         wake_attempts: 0,
         // Enrichment fields (Phase 17)
         repo: msg.repo || null,
         branch: msg.branch || null,
         file_hints: msg.file_hints || [],
         success_criteria: msg.success_criteria || [],
         verification_steps: msg.verification_steps || [],
         complexity: msg.complexity || null
       };
       ```

    5. In the `sendTaskComplete(taskId, result)` method, include the task's enrichment fields in the result so they are available for verification infrastructure (Phase 21):
       No change needed here -- the result already carries whatever the agent writes to the result JSON file. The enrichment fields are stored in the queue for the sidecar to read when it needs them.

    6. Verify that the task object in queue.json will correctly serialize/deserialize the enrichment fields. The existing `saveQueue`/`loadQueue` in `lib/queue.js` use `JSON.stringify`/`JSON.parse` which handles objects and arrays natively -- no changes needed.

    IMPORTANT: All new fields in the WebSocket `task_assign` message are ADDITIVE. Never remove or rename existing fields (research pitfall #4). The sidecar must gracefully handle missing fields (via `|| null` / `|| []` defaults) for backward compatibility during rolling upgrades.
  </action>
  <verify>
    `mix compile --warnings-as-errors` -- no warnings.
    `mix test` -- full test suite passes (no regressions in existing tests).
    Manual verification: Review that Scheduler, Socket, and Sidecar all include the same set of enrichment fields in the correct format.
  </verify>
  <done>
    Enrichment fields flow through the complete pipeline: TaskQueue.submit (store) -> Scheduler.do_assign (pass to Socket) -> Socket.push_task (push to sidecar as JSON) -> Sidecar.handleTaskAssign (store in queue). Old tasks without enrichment fields get safe defaults at every stage. All 5 roadmap success criteria for Phase 17 are satisfied.
  </done>
</task>

</tasks>

<verification>
Full phase verification against roadmap success criteria:

1. **"A task submitted with context fields arrives at the sidecar with those fields intact"**
   - Verify: Submit task via `POST /api/tasks` with repo, branch, file_hints. Task flows through TaskQueue -> Scheduler -> Socket -> Sidecar with fields preserved.

2. **"A task submitted with success criteria and verification steps stores and retrieves them through the full pipeline"**
   - Verify: Submit task with success_criteria and verification_steps. GET /api/tasks/:id returns them. When assigned, they appear in task_assign WebSocket message.

3. **"A task submitted with an explicit complexity tier carries that classification through assignment"**
   - Verify: Submit task with complexity_tier: "complex". GET /api/tasks/:id shows complexity.effective_tier = "complex", complexity.source = "explicit". Sidecar receives the same.

4. **"A task submitted without a complexity tier receives an inferred classification"**
   - Verify: Submit task without complexity_tier. GET /api/tasks/:id shows complexity.source = "inferred", complexity.inferred.confidence > 0.

5. **"Existing v1.0/v1.1 tasks continue working unchanged"**
   - Verify: `mix test` passes with no regressions. Old tasks in DETS (without enrichment keys) can be listed, retrieved, and format_task handles them via Map.get defaults.
</verification>

<success_criteria>
- All 5 roadmap success criteria pass
- Full test suite passes with no regressions
- No compilation warnings
- Enrichment fields survive submit -> assign -> complete lifecycle
- Old tasks without enrichment fields work identically to v1.0/v1.1
- Complexity disagreement telemetry fires when explicit != inferred
</success_criteria>

<output>
After completion, create `.planning/phases/17-enriched-task-format/17-03-SUMMARY.md`
</output>
