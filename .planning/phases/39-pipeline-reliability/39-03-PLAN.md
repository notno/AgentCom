---
phase: 39-pipeline-reliability
plan: 03
type: execute
wave: 2
depends_on: ["39-01", "39-02"]
files_modified:
  - sidecar/index.js
  - lib/agent_com/socket.ex
  - lib/agent_com/validation.ex
autonomous: true
must_haves:
  truths:
    - "Sidecar reconnecting after disconnect reports its current task state to the hub"
    - "Hub reconciles sidecar state report: continues waiting, accepts late result, or requeues"
    - "Validation schema accepts state_report and wake_result message types"
  artifacts:
    - path: "sidecar/index.js"
      provides: "state_report on reconnect after identify"
    - path: "lib/agent_com/socket.ex"
      provides: "state_report handler with reconciliation logic"
    - path: "lib/agent_com/validation.ex"
      provides: "state_report and wake_result WS schemas"
  key_links:
    - from: "sidecar/index.js identify -> state_report"
      to: "lib/agent_com/socket.ex state_report handler"
      via: "WebSocket message after identified response"
      pattern: "type.*state_report"
---

<objective>
Add sidecar reconnect state recovery and validation for new message types.

Purpose: PIPE-05 ensures that when a sidecar reconnects after a network disruption, the hub knows what the sidecar is currently doing and can reconcile state (continue waiting, or requeue the task). This complements the existing crash recovery flow (task_recovering) by handling the reconnect-while-working case.

Output: Sidecar sends state_report on reconnect, hub reconciles, validation schemas updated.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/39-pipeline-reliability/39-RESEARCH.md
@.planning/phases/39-pipeline-reliability/39-01-SUMMARY.md
@.planning/phases/39-pipeline-reliability/39-02-SUMMARY.md
@sidecar/index.js
@lib/agent_com/socket.ex
@lib/agent_com/validation.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: PIPE-05 -- Sidecar state_report on reconnect</name>
  <files>sidecar/index.js</files>
  <action>
Modify the `handleMessage` method in `HubConnection` to send a `state_report` after receiving the `identified` response. Currently, `reportRecovery()` is called on identify (line 558), which only handles the crash recovery case (recovering slot). Add a state_report for the active task case.

In the `case 'identified':` handler (lines 553-559), after the existing `this.reportRecovery()` call, add:

```javascript
case 'identified':
    this.identified = true;
    this.reconnectDelay = 1000;
    log('info', 'identified', { agent_id: msg.agent_id });
    // Report any recovering task to hub after identification
    this.reportRecovery();
    // PIPE-05: Report current active task state on reconnect
    this.reportActiveState();
    break;
```

Add the `reportActiveState()` method to `HubConnection`:

```javascript
/**
 * PIPE-05: Report current active task state on reconnect.
 * Unlike reportRecovery() which handles crash recovery (recovering slot),
 * this handles the case where sidecar was actively working on a task when
 * the WebSocket disconnected and reconnected.
 */
reportActiveState() {
    if (!_queue.active) return;

    const task = _queue.active;
    const generation = this.taskGenerations.get(task.task_id) || task.generation || 0;

    log('info', 'state_report_sending', {
        task_id: task.task_id,
        status: task.status,
        generation: generation
    });

    this.send({
        type: 'state_report',
        task_id: task.task_id,
        status: task.status,
        generation: generation,
        assigned_at: task.assigned_at
    });
}
```

Note: This is distinct from `reportRecovery()` which handles the `_queue.recovering` slot (tasks that were in-progress when the sidecar process crashed). `reportActiveState()` handles the `_queue.active` slot (tasks that are actively being worked on when just the WebSocket connection drops).

Also add handling for the hub's response to state_report. The hub may respond with:
- `state_report_ack` with action: "continue" -- sidecar keeps working
- `state_report_ack` with action: "abort" -- sidecar should abandon the task

Add to the `handleMessage` switch:

```javascript
case 'state_report_ack':
    log('info', 'state_report_ack', {
        task_id: msg.task_id,
        action: msg.action
    });
    if (msg.action === 'abort' && _queue.active && _queue.active.task_id === msg.task_id) {
        log('warning', 'state_report_abort', { task_id: msg.task_id });
        _queue.active = null;
        saveQueue(QUEUE_PATH, _queue);
        this.taskGenerations.delete(msg.task_id);
    }
    break;
```
  </action>
  <verify>
1. Search for `reportActiveState` in index.js -- should find the method definition and the call in the 'identified' handler.
2. Search for `state_report` in index.js -- should find it in the send() call with type, task_id, status, generation.
3. Search for `state_report_ack` in index.js -- should find the handler in the switch statement.
4. Verify the abort case clears _queue.active and saves.
  </verify>
  <done>Sidecar sends state_report with current task status and generation on every reconnect. Handles state_report_ack response: continues working on "continue", aborts task on "abort".</done>
</task>

<task type="auto">
  <name>Task 2: Hub state_report handler and validation schemas</name>
  <files>lib/agent_com/socket.ex, lib/agent_com/validation.ex</files>
  <action>
**Hub state_report handler in socket.ex.**

Add a handler for `state_report` messages. The hub should reconcile the sidecar's reported state with its own task state:

Add after the `wake_result` handler (added in Plan 39-02):

```elixir
defp handle_msg(%{"type" => "state_report", "task_id" => task_id} = msg, state) do
    log_task_event(state.agent_id, "state_report", task_id, msg)
    reported_generation = msg["generation"] || 0
    reported_status = msg["status"] || "unknown"

    # Reconcile with hub's view of the task
    action = case AgentCom.TaskQueue.get(task_id) do
      {:ok, %{status: :assigned, assigned_to: agent_id, generation: gen}} when agent_id == state.agent_id ->
        if gen == reported_generation do
          # Task still assigned to this agent with matching generation -- continue
          AgentCom.TaskQueue.update_progress(task_id)
          "continue"
        else
          # Generation mismatch -- task was requeued and possibly reassigned
          "abort"
        end

      {:ok, %{status: :assigned, assigned_to: _other_agent}} ->
        # Task reassigned to a different agent
        "abort"

      {:ok, %{status: :completed}} ->
        # Already completed (maybe by retry)
        "abort"

      {:ok, %{status: :queued}} ->
        # Task was reclaimed back to queue
        "abort"

      _ ->
        # Not found or dead-lettered
        "abort"
    end

    Logger.info("state_report_reconciled",
      task_id: task_id,
      agent_id: state.agent_id,
      reported_status: reported_status,
      reported_generation: reported_generation,
      action: action
    )

    reply = Jason.encode!(%{
      "type" => "state_report_ack",
      "task_id" => task_id,
      "action" => action
    })
    {:push, {:text, reply}, state}
end
```

**Validation schemas in validation.ex.**

Find the WebSocket message type validation and add "state_report" and "wake_result" as valid types. Look for the list of valid message types (likely a pattern match or list of strings) and add both new types.

Search for where message types are validated. Add:
- "state_report" with required fields: task_id (string)
- "wake_result" with required fields: task_id (string), status (string)

The exact location depends on how validation.ex is structured. Look for patterns like:
- A map of message types to schemas
- A case/cond checking the "type" field
- A list of valid type strings

Add the new types to whichever pattern is used.
  </action>
  <verify>
1. In socket.ex, search for `state_report` handler -- should find the handle_msg clause.
2. In socket.ex, verify the handler returns `state_report_ack` with action field.
3. In socket.ex, verify generation comparison logic: matching gen = continue, mismatch = abort.
4. In validation.ex, search for "state_report" and "wake_result" -- should find both registered.
5. Run `mix compile --warnings-as-errors` to confirm no compilation errors.
  </verify>
  <done>Hub handles state_report by reconciling sidecar state with task queue state, responding with continue/abort. Validation schemas accept state_report and wake_result message types without validation errors.</done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` passes with all new handlers and validation
2. Sidecar sends state_report on reconnect when active task exists
3. Hub responds with state_report_ack(continue) when task is still assigned with matching generation
4. Hub responds with state_report_ack(abort) when task was requeued, reassigned, or completed
5. Sidecar clears active task on abort response
6. Validation schemas accept both new message types
</verification>

<success_criteria>
- PIPE-05: Sidecar reconnecting after disconnect reports state, hub reconciles appropriately
- state_report_ack with "continue" keeps sidecar working on the task
- state_report_ack with "abort" causes sidecar to clear the stale task
- No validation errors for new message types
- Generation-based reconciliation prevents conflicting work
</success_criteria>

<output>
After completion, create `.planning/phases/39-pipeline-reliability/39-03-SUMMARY.md`
</output>
