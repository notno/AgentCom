---
phase: 39-pipeline-reliability
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - sidecar/index.js
autonomous: true
gap_closure: true
must_haves:
  truths:
    - "Tasks with missing or empty wake_command immediately fail regardless of routing_decision target_type"
    - "Tasks routed to sidecar/ollama (non-wake) with no wake_command never reach the LLM"
    - "Tasks routed to wake path with no wake_command still fail fast (existing behavior preserved)"
  artifacts:
    - path: "sidecar/index.js"
      provides: "Pre-routing wake_command gate in task_assigned handler"
      contains: "no_wake_command"
  key_links:
    - from: "sidecar/index.js task_assigned handler"
      to: "wakeAgent fail-fast"
      via: "shared wake_command check before routing branch"
      pattern: "wake_command.*task_assigned"
---

<objective>
Close UAT gap: tasks with missing/empty wake_command bypass the fail-fast check when routing_decision.target_type is not 'wake' (trivial/standard tasks go to executeTask() directly).

Purpose: The existing fail-fast check in wakeAgent() only guards the legacy wake path. The scheduler routes trivial tasks to sidecar and standard tasks to ollama, both of which bypass wakeAgent() entirely. This means agents with no wake_command configured still attempt LLM execution instead of failing immediately.

Output: Updated sidecar/index.js with a wake_command gate BEFORE the routing decision branch in the task_assigned handler.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@sidecar/index.js
@.planning/phases/39-pipeline-reliability/39-01-SUMMARY.md
@.planning/phases/v14-UAT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add wake_command gate before routing decision branch</name>
  <files>sidecar/index.js</files>
  <action>
In the task_assigned handler (around line 793), BEFORE the routing_decision check, add a wake_command validation gate:

1. After the git start-task block (after line 791 `saveQueue(QUEUE_PATH, _queue);`) and BEFORE line 793 (`const routing = task.routing_decision;`), insert a wake_command check:

```javascript
// Gap closure: wake_command gates ALL task execution, not just wake path
const wakeCmd = _config.wake_command;
if (!wakeCmd || (typeof wakeCmd === 'string' && wakeCmd.trim() === '')) {
  log('error', 'no_wake_command', {
    task_id: msg.task_id,
    reason: 'wake_command not configured - rejecting task before execution',
    routing_target: task.routing_decision?.target_type || 'none'
  });
  task.status = 'failed';
  _queue.active = null;
  saveQueue(QUEUE_PATH, _queue);
  this.sendTaskFailed(task.task_id, 'no_wake_command_configured');
  this.send({
    type: 'wake_result',
    task_id: msg.task_id,
    status: 'failed',
    attempt: 0,
    error: 'no_wake_command_configured'
  });
  return;
}
```

2. This check runs BEFORE the routing decision branch, so it catches ALL task types: trivial (sidecar), standard (ollama), and complex (wake).

3. The existing fail-fast check inside wakeAgent() (lines 99-115) can remain as defense-in-depth -- it will never fire since the new gate catches it first, but leaving it preserves backward compatibility if wakeAgent is ever called directly.

4. Important: Use `return` after the fail-fast to prevent falling through to either executeTask() or wakeAgent().

5. Important: The check must handle both `undefined`/`null` wake_command AND empty string wake_command (both reported by user as problematic).
  </action>
  <verify>
    1. Read sidecar/index.js and confirm the wake_command check appears BEFORE `const routing = task.routing_decision;`
    2. Confirm the check handles both missing (undefined/null) and empty string cases
    3. Confirm the check calls sendTaskFailed and sends wake_result before returning
    4. Confirm no code path can reach executeTask() or wakeAgent() without passing the wake_command gate
    5. Run: `cd sidecar && node -e "require('./index.js')" 2>&1 | head -5` to verify no syntax errors (module will fail to connect but should parse cleanly)
  </verify>
  <done>
    - wake_command check exists before the routing_decision branch in task_assigned handler
    - Both undefined/null AND empty string wake_command are caught
    - Failed tasks send wake_result with error 'no_wake_command_configured'
    - No execution path (sidecar, ollama, or wake) can proceed without a valid wake_command
  </done>
</task>

</tasks>

<verification>
1. Code inspection: The wake_command gate appears in task_assigned handler BEFORE the routing decision branch (line ~793)
2. Both missing and empty-string wake_command are rejected
3. The existing wakeAgent() fail-fast check is preserved as defense-in-depth
4. No syntax errors in sidecar/index.js (node -e "require('./index.js')" parses without SyntaxError)
</verification>

<success_criteria>
UAT Test 3 will pass: Tasks with missing/empty wake_command immediately fail instead of reaching the LLM, regardless of routing_decision.target_type.
</success_criteria>

<output>
After completion, create `.planning/phases/39-pipeline-reliability/39-04-SUMMARY.md`
</output>
