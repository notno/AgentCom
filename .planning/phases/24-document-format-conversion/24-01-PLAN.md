---
phase: 24-document-format-conversion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - mix.exs
  - lib/agent_com/xml/xml.ex
  - lib/agent_com/xml/parser.ex
  - lib/agent_com/xml/schemas/goal.ex
  - lib/agent_com/xml/schemas/scan_result.ex
  - lib/agent_com/xml/schemas/fsm_snapshot.ex
  - lib/agent_com/xml/schemas/improvement.ex
  - lib/agent_com/xml/schemas/proposal.ex
autonomous: true

must_haves:
  truths:
    - "Saxy library is available as a project dependency"
    - "Each XML document type (goal, scan_result, fsm_snapshot, improvement, proposal) has a corresponding Elixir struct"
    - "Structs can be encoded to XML strings via Saxy.encode!/2"
    - "XML strings can be parsed back into Elixir structs via the SAX parser"
    - "AgentCom.XML.encode/1 and AgentCom.XML.decode/2 provide a single public API"
  artifacts:
    - path: "mix.exs"
      provides: "Saxy dependency declaration"
      contains: "saxy"
    - path: "lib/agent_com/xml/xml.ex"
      provides: "Public encode/decode API module"
      exports: ["encode", "decode"]
    - path: "lib/agent_com/xml/parser.ex"
      provides: "SAX event handler for parsing XML to structs"
      contains: "Saxy.Handler"
    - path: "lib/agent_com/xml/schemas/goal.ex"
      provides: "Goal XML schema struct"
      contains: "defstruct"
    - path: "lib/agent_com/xml/schemas/scan_result.ex"
      provides: "ScanResult XML schema struct"
      contains: "defstruct"
    - path: "lib/agent_com/xml/schemas/fsm_snapshot.ex"
      provides: "FsmSnapshot XML schema struct"
      contains: "defstruct"
    - path: "lib/agent_com/xml/schemas/improvement.ex"
      provides: "Improvement XML schema struct"
      contains: "defstruct"
    - path: "lib/agent_com/xml/schemas/proposal.ex"
      provides: "Proposal XML schema struct"
      contains: "defstruct"
  key_links:
    - from: "lib/agent_com/xml/xml.ex"
      to: "lib/agent_com/xml/schemas/*.ex"
      via: "pattern match on struct type in encode/1"
      pattern: "%AgentCom\\.XML\\.Schemas\\."
    - from: "lib/agent_com/xml/xml.ex"
      to: "lib/agent_com/xml/parser.ex"
      via: "delegates parsing to Saxy.parse_string with Parser handler"
      pattern: "Saxy\\.parse_string"
    - from: "lib/agent_com/xml/schemas/*.ex"
      to: "Saxy.Builder protocol"
      via: "@derive Saxy.Builder on each struct"
      pattern: "@derive.*Saxy\\.Builder"
---

<objective>
Create the XML document infrastructure for AgentCom's v1.3 autonomous loop. Add the Saxy library dependency, build a centralized encode/decode API module, implement a SAX event handler for parsing, and define all five XML schema structs (Goal, ScanResult, FsmSnapshot, Improvement, Proposal) that downstream phases will consume.

Purpose: Phase 24 establishes XML as the format for all new machine-consumed documents. This is foundational -- Phase 27 (GoalBacklog), Phase 29 (HubFSM), Phase 32 (Improvement Scanning), and Phase 33 (Contemplation) all depend on these schemas to produce and consume structured documents.

Output: 8 new/modified files providing a complete XML encode/decode subsystem.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-document-format-conversion/24-CONTEXT.md
@.planning/phases/24-document-format-conversion/24-RESEARCH.md
@mix.exs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Saxy dependency and create XML module foundation</name>
  <files>
    mix.exs
    lib/agent_com/xml/xml.ex
    lib/agent_com/xml/parser.ex
  </files>
  <action>
1. Add `{:saxy, "~> 1.6"}` to the deps list in mix.exs (after jason, before web_push_elixir). Run `mix deps.get` to fetch.

2. Create `lib/agent_com/xml/xml.ex` as `AgentCom.XML` module with:
   - `@moduledoc` explaining this is the public API for XML document encoding/decoding
   - `encode/1` function that accepts any schema struct and returns `{:ok, xml_string}` or `{:error, reason}`. Implementation: pattern match on struct type, call `Saxy.encode!(root_element_name, struct)` wrapped in try/rescue, prepend XML declaration `<?xml version="1.0" encoding="UTF-8"?>`. The root element name is derived from the struct module (e.g., `AgentCom.XML.Schemas.Goal` -> `"goal"`, `AgentCom.XML.Schemas.ScanResult` -> `"scan-result"`). Use a private `root_name/1` function with a map from struct module to kebab-case element name.
   - `encode!/1` that raises on error (delegates to encode/1, unwraps or raises).
   - `decode/2` that accepts an XML string and a schema atom (`:goal`, `:scan_result`, `:fsm_snapshot`, `:improvement`, `:proposal`) and returns `{:ok, struct}` or `{:error, reason}`. Implementation: call `Saxy.parse_string(xml, AgentCom.XML.Parser, {schema_type, %{}})` then construct the struct from the accumulated map.
   - `decode!/2` that raises on error.
   - Private `schema_module/1` mapping atoms to modules (`:goal` -> `AgentCom.XML.Schemas.Goal`).

3. Create `lib/agent_com/xml/parser.ex` as `AgentCom.XML.Parser` module with:
   - `@moduledoc` explaining this is the SAX event handler for parsing XML back into schema structs
   - `@behaviour Saxy.Handler`
   - Implement the 5 callbacks: `handle_event(:start_document, ...)`, `handle_event(:end_document, ...)`, `handle_event(:start_element, ...)`, `handle_event(:end_element, ...)`, `handle_event(:characters, ...)`.
   - State is a tuple `{schema_type, accumulator_map, current_element, current_chars}` where current_element tracks which XML element we're inside, and current_chars accumulates text content.
   - On `:start_element`, push the element name. On `:characters`, append to current_chars. On `:end_element`, store `current_element => current_chars` in the accumulator map (convert element kebab-case to atom snake_case, e.g., "scan-type" -> :scan_type). Reset current_chars.
   - On `:end_document`, return `{:ok, accumulated_map}`.
   - Handle XML attributes on the root element by merging them into the accumulator map.
   - For list-type child elements (e.g., `<items>` containing multiple `<item>` children), track a stack and accumulate lists. Use a simple approach: when encountering a child element with the same name multiple times, convert the value to a list.

Do NOT use :xmerl -- Saxy is the chosen library per research. Keep the parser generic enough to handle all 5 schema types without special-casing per type.
  </action>
  <verify>
    Run `mix deps.get` succeeds with saxy fetched.
    Run `mix compile` succeeds with zero warnings on the new modules.
    Verify files exist: `lib/agent_com/xml/xml.ex`, `lib/agent_com/xml/parser.ex`.
  </verify>
  <done>
    Saxy is a project dependency. AgentCom.XML module compiles with encode/1, encode!/1, decode/2, decode!/2 functions. AgentCom.XML.Parser compiles with Saxy.Handler behaviour implemented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Define all five XML schema structs with Saxy.Builder</name>
  <files>
    lib/agent_com/xml/schemas/goal.ex
    lib/agent_com/xml/schemas/scan_result.ex
    lib/agent_com/xml/schemas/fsm_snapshot.ex
    lib/agent_com/xml/schemas/improvement.ex
    lib/agent_com/xml/schemas/proposal.ex
  </files>
  <action>
Create 5 schema struct modules under `lib/agent_com/xml/schemas/`. Each follows the same pattern:
- `@moduledoc` describing what this document represents and which phase consumes it
- `@derive {Saxy.Builder, ...}` with element name and field mapping
- `defstruct` with all fields defaulting to nil (or [] for list fields)
- A `new/1` constructor that accepts a keyword list or map and builds the struct with validation (required fields return `{:error, reason}` if missing)

**AgentCom.XML.Schemas.Goal** (`goal.ex`):
- Root element: `"goal"`
- Fields: `id` (string, required), `title` (string, required), `description` (string), `priority` (string, one of "urgent"/"high"/"normal"/"low", default "normal"), `success_criteria` (list of strings), `source` (string -- "api", "cli", "file", "scan"), `repo` (string), `created_at` (string, ISO 8601), `metadata` (string, freeform)
- `@derive {Saxy.Builder, element: "goal", attributes: [:id, :priority, :source, :repo, :created_at], children: [:title, :description, :metadata]}` -- success_criteria needs special handling as a list of `<criterion>` elements
- Consumer: Phase 27 (GoalBacklog), Phase 30 (Decomposition)

**AgentCom.XML.Schemas.ScanResult** (`scan_result.ex`):
- Root element: `"scan-result"`
- Fields: `id` (string, required), `repo` (string, required), `scan_type` (string -- "test_gap", "doc_gap", "dead_dep", "refactor", "simplification"), `file_path` (string), `description` (string, required), `severity` (string -- "low", "medium", "high"), `suggested_action` (string), `scanned_at` (string, ISO 8601), `metadata` (string)
- Consumer: Phase 32 (Improvement Scanning)

**AgentCom.XML.Schemas.FsmSnapshot** (`fsm_snapshot.ex`):
- Root element: `"fsm-snapshot"`
- Fields: `state` (string, required -- "executing", "improving", "contemplating", "resting"), `since` (string, ISO 8601, required), `cycle_count` (string/integer), `current_goal_id` (string), `queue_depth` (string/integer), `budget_remaining` (string), `transition_history` (list of maps with `from`, `to`, `at` keys), `snapshot_at` (string, ISO 8601, required)
- Consumer: Phase 29 (Hub FSM Core)

**AgentCom.XML.Schemas.Improvement** (`improvement.ex`):
- Root element: `"improvement"`
- Fields: `id` (string, required), `repo` (string, required), `file_path` (string), `improvement_type` (string -- "test", "doc", "refactor", "dependency", "cleanup"), `description` (string, required), `status` (string -- "identified", "in_progress", "completed", "skipped"), `scan_result_id` (string -- links to originating scan), `attempted_at` (string, ISO 8601), `completed_at` (string, ISO 8601), `metadata` (string)
- Consumer: Phase 32 (Improvement Scanning)

**AgentCom.XML.Schemas.Proposal** (`proposal.ex`):
- Root element: `"proposal"`
- Fields: `id` (string, required), `title` (string, required), `description` (string, required), `rationale` (string), `impact` (string -- "low", "medium", "high"), `effort` (string -- "small", "medium", "large"), `repo` (string), `related_files` (list of strings), `proposed_at` (string, ISO 8601), `metadata` (string)
- Consumer: Phase 33 (Contemplation)

For the `@derive Saxy.Builder` directive, use the format from Saxy docs: `@derive {Saxy.Builder, element: "goal", attributes: [...], children: [...]}`. Scalar fields that should appear as child elements go in `children`. Fields that are compact identifiers go in `attributes`. List fields need custom encoding -- implement `Saxy.Builder` protocol manually for list fields if `@derive` doesn't support lists natively, OR handle list serialization in the `AgentCom.XML.encode/1` function by pre-processing the struct.

Keep XML flat: use attributes for IDs, types, timestamps, dates. Use child elements for text content (title, description, rationale, suggested_action). Keep it consistent across all 5 schemas.
  </action>
  <verify>
    Run `mix compile` succeeds with zero warnings.
    All 5 schema files exist under `lib/agent_com/xml/schemas/`.
    Each module defines a struct and has @derive Saxy.Builder or implements the protocol.
    Quick IEx check: `AgentCom.XML.Schemas.Goal.__struct__()` returns the default struct.
  </verify>
  <done>
    All 5 schema structs compile, have documented fields, @derive Saxy.Builder or protocol implementation, and new/1 constructors with required-field validation. XML element naming follows kebab-case convention. Attribute vs child element split is consistent across schemas.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire encode/decode round-trip and verify with IEx smoke test</name>
  <files>
    lib/agent_com/xml/xml.ex
  </files>
  <action>
After Tasks 1 and 2, wire the full encode/decode round-trip:

1. Update `AgentCom.XML.encode/1` to handle list fields in schemas. For each schema struct, before passing to Saxy.encode!, pre-process list fields into nested XML-compatible structures. For example, Goal's `success_criteria` list `["criterion 1", "criterion 2"]` should produce `<success-criteria><criterion>criterion 1</criterion><criterion>criterion 2</criterion></success-criteria>`. Similarly for Proposal's `related_files` and FsmSnapshot's `transition_history`.

2. Update `AgentCom.XML.Parser` to handle list elements during parsing. When a parent element (e.g., `success-criteria`) contains repeated child elements (e.g., `criterion`), accumulate them into a list on the parent's key.

3. Add a `schema_types/0` function to `AgentCom.XML` that returns `[:goal, :scan_result, :fsm_snapshot, :improvement, :proposal]` -- useful for downstream iteration.

4. Add `to_map/1` to each schema struct module (or as a shared function in AgentCom.XML) that converts a struct to a plain map with string keys -- useful for JSON serialization or DETS storage of parsed XML.

5. Smoke test via IEx (document the commands in moduledoc):
   ```elixir
   goal = %AgentCom.XML.Schemas.Goal{id: "g-001", title: "Test", priority: "normal", success_criteria: ["passes tests"]}
   {:ok, xml} = AgentCom.XML.encode(goal)
   {:ok, decoded} = AgentCom.XML.decode(xml, :goal)
   decoded.id == "g-001" # true
   decoded.title == "Test" # true
   ```

Run `mix compile --warnings-as-errors` to ensure clean compilation of all XML modules.
  </action>
  <verify>
    Run `mix compile --warnings-as-errors` passes with zero errors.
    In IEx (`iex -S mix`), execute the encode/decode round-trip for a Goal struct -- verify the decoded struct matches the original.
  </verify>
  <done>
    AgentCom.XML.encode/1 produces valid XML strings for all 5 schema types. AgentCom.XML.decode/2 parses XML strings back into correct Elixir structs. List fields (success_criteria, related_files, transition_history) survive the round-trip. The full XML subsystem compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `mix deps.get` succeeds -- saxy is fetched
2. `mix compile --warnings-as-errors` passes -- all 8 new/modified files compile cleanly
3. In IEx, `AgentCom.XML.encode(%AgentCom.XML.Schemas.Goal{id: "test", title: "Test Goal", priority: "normal"})` returns `{:ok, xml_string}` containing `<goal` root element
4. In IEx, `AgentCom.XML.decode(xml_string, :goal)` returns `{:ok, %AgentCom.XML.Schemas.Goal{id: "test", title: "Test Goal", ...}}`
5. All 5 schema modules exist and define structs: Goal, ScanResult, FsmSnapshot, Improvement, Proposal
6. GSD .planning/ files remain untouched in markdown format
</verification>

<success_criteria>
- Saxy ~> 1.6 is a project dependency in mix.exs
- AgentCom.XML provides encode/1, encode!/1, decode/2, decode!/2 public API
- AgentCom.XML.Parser implements Saxy.Handler for generic XML-to-struct parsing
- 5 schema structs exist with @derive Saxy.Builder and new/1 constructors
- Encode/decode round-trip works for all 5 schema types
- XML uses kebab-case elements, snake_case attributes per convention
- No existing code is broken (mix compile clean)
</success_criteria>

<output>
After completion, create `.planning/phases/24-document-format-conversion/24-01-SUMMARY.md`
</output>
