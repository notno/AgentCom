---
phase: 03-agent-state
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/agent_com/agent_supervisor.ex
  - lib/agent_com/agent_fsm.ex
  - lib/agent_com/application.ex
autonomous: true

must_haves:
  truths:
    - "AgentFSM GenServer can be started dynamically under AgentSupervisor with an agent_id, ws_pid, name, and capabilities"
    - "AgentFSM validates state transitions: idle -> assigned -> working -> idle, with blocked and offline paths"
    - "AgentFSM monitors a WebSocket pid and transitions to offline on :DOWN, reclaiming any assigned task"
    - "60-second acceptance timeout fires if agent does not transition from assigned to working, reclaiming the task and flagging the agent"
    - "Capabilities are normalized: string lists become %{name: cap} maps, structured maps pass through"
  artifacts:
    - path: "lib/agent_com/agent_fsm.ex"
      provides: "Per-agent FSM GenServer with state machine, disconnect detection, acceptance timeout"
      exports: ["start_link", "get_state", "get_capabilities", "list_all", "assign_task", "task_accepted", "task_completed", "task_failed", "task_blocked", "task_unblocked"]
    - path: "lib/agent_com/agent_supervisor.ex"
      provides: "DynamicSupervisor for per-agent AgentFSM processes"
      exports: ["start_link", "start_agent", "stop_agent"]
    - path: "lib/agent_com/application.ex"
      provides: "AgentFSMRegistry and AgentSupervisor in supervision tree"
      contains: "AgentCom.AgentFSMRegistry"
  key_links:
    - from: "lib/agent_com/agent_fsm.ex"
      to: "AgentCom.AgentFSMRegistry"
      via: "Registry :via tuple for process name"
      pattern: "via.*Registry.*AgentFSMRegistry"
    - from: "lib/agent_com/agent_fsm.ex"
      to: "AgentCom.TaskQueue"
      via: "reclaim_task call on disconnect/timeout"
      pattern: "TaskQueue\\.reclaim_task"
    - from: "lib/agent_com/agent_supervisor.ex"
      to: "AgentCom.AgentFSM"
      via: "DynamicSupervisor.start_child"
      pattern: "start_child.*AgentFSM"
---

<objective>
Create the per-agent FSM GenServer and its DynamicSupervisor infrastructure. Each connected agent gets a dedicated GenServer process that tracks its work lifecycle through validated state transitions (idle -> assigned -> working -> idle/blocked), monitors the WebSocket process for immediate disconnect detection, enforces a 60-second acceptance timeout on assigned tasks, and normalizes structured capabilities for future scheduler routing.

Purpose: Establish the per-agent process infrastructure that Phase 3's wiring plan (03-02) and Phase 4's scheduler will build upon. This is the first DynamicSupervisor usage in the codebase.
Output: agent_fsm.ex, agent_supervisor.ex, updated application.ex
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-agent-state/03-RESEARCH.md
@.planning/phases/02-task-queue/02-01-SUMMARY.md
@lib/agent_com/application.ex
@lib/agent_com/task_queue.ex
@lib/agent_com/presence.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AgentSupervisor DynamicSupervisor and register in supervision tree</name>
  <files>lib/agent_com/agent_supervisor.ex, lib/agent_com/application.ex</files>
  <action>
Create `lib/agent_com/agent_supervisor.ex` as a DynamicSupervisor module:
- `use DynamicSupervisor`
- `start_link/1` with `name: __MODULE__`
- `init/1` returning `DynamicSupervisor.init(strategy: :one_for_one)`
- `start_agent(args)` -- calls `DynamicSupervisor.start_child(__MODULE__, {AgentCom.AgentFSM, args})`
- `stop_agent(pid)` -- calls `DynamicSupervisor.terminate_child(__MODULE__, pid)`

In `lib/agent_com/application.ex`, add two new children AFTER `AgentCom.Reaper` and BEFORE `AgentCom.TaskQueue`:
```elixir
{Registry, keys: :unique, name: AgentCom.AgentFSMRegistry},
{AgentCom.AgentSupervisor, []},
```

The Registry is placed before AgentSupervisor because FSM processes register in it on start. Both must be before TaskQueue and Bandit so they are available when WebSocket connections arrive.
  </action>
  <verify>
Run `mix compile` -- zero errors, zero warnings. Verify supervision tree order: PubSub > AgentRegistry > ... > Reaper > AgentFSMRegistry > AgentSupervisor > TaskQueue > Bandit.
  </verify>
  <done>AgentSupervisor module exists with start_agent/stop_agent. AgentFSMRegistry registered. Both in supervision tree before TaskQueue/Bandit.</done>
</task>

<task type="auto">
  <name>Task 2: Create AgentFSM GenServer with state machine, monitoring, timeout, and capabilities</name>
  <files>lib/agent_com/agent_fsm.ex</files>
  <action>
Create `lib/agent_com/agent_fsm.ex` as a GenServer implementing the per-agent FSM. This is the largest module in Phase 3.

**Child spec:** Override `child_spec/1` to use `restart: :temporary` (agent processes are transient -- do not restart on crash; agent must reconnect).

**State struct fields:**
- `agent_id` (string) -- unique agent identifier
- `ws_pid` (pid) -- WebSocket process being monitored
- `ws_monitor_ref` (reference) -- from Process.monitor
- `name` (string) -- display name
- `capabilities` (list of maps) -- normalized capabilities
- `connected_at` (integer ms) -- when FSM was started
- `last_state_change` (integer ms) -- timestamp of last transition
- `current_task_id` (string | nil) -- task currently assigned/being worked
- `acceptance_timer_ref` (reference | nil) -- timer for 60s acceptance
- `fsm_state` (atom) -- one of :idle, :assigned, :working, :blocked, :offline
- `flags` (list of atoms) -- e.g., [:unresponsive]

**start_link/1:** Takes keyword list args. Registers via `{:via, Registry, {AgentCom.AgentFSMRegistry, agent_id}}`.

**init/1:** Synchronous and fast (per research Pitfall 1):
1. Extract agent_id, ws_pid, name, capabilities from args
2. Monitor WebSocket pid: `ref = Process.monitor(ws_pid)`
3. Normalize capabilities (see below)
4. Check TaskQueue for existing assignments: `AgentCom.TaskQueue.tasks_assigned_to(agent_id)`. If a task is assigned, start in `:assigned` state with that task_id and start the acceptance timer.
5. Otherwise start in `:idle` state
6. Return `{:ok, state}`

**Valid transitions map:**
```elixir
@valid_transitions %{
  idle:     [:assigned, :offline],
  assigned: [:working, :idle, :offline],
  working:  [:idle, :blocked, :offline],
  blocked:  [:working, :idle, :offline]
}
```

Note: "done" and "failed" are NOT FSM states (per research Q2). Task outcomes live in TaskQueue. The agent transitions working -> idle on task completion/failure.

**Private transition/2 function:** Pattern-matches current state against @valid_transitions. On valid transition, updates fsm_state and last_state_change. Returns `{:ok, new_state}` or `{:error, {:invalid_transition, from, to}}`.

**Public API functions (all look up FSM via Registry):**
- `get_state(agent_id)` -- GenServer.call :get_state. Returns `{:ok, map}` with agent_id, fsm_state, current_task_id, capabilities, flags, connected_at, last_state_change. Returns `{:error, :not_found}` if no FSM exists.
- `get_capabilities(agent_id)` -- GenServer.call :get_capabilities. Returns `{:ok, caps}` or `{:error, :not_found}`.
- `list_all()` -- Uses `Registry.select/2` on AgentFSMRegistry to get all agent_ids, then calls get_state for each. Returns list of maps.
- `assign_task(agent_id, task_id)` -- GenServer.cast {:task_assigned, task_id}. Called by scheduler (Phase 4) or Socket when pushing a task.
- `task_accepted(agent_id, task_id)` -- GenServer.cast {:task_accepted, task_id}. Transitions assigned -> working, cancels acceptance timer.
- `task_completed(agent_id)` -- GenServer.cast :task_completed. Transitions working -> idle, clears current_task_id.
- `task_failed(agent_id)` -- GenServer.cast :task_failed. Transitions working -> idle, clears current_task_id.
- `task_blocked(agent_id)` -- GenServer.cast :task_blocked. Transitions working -> blocked.
- `task_unblocked(agent_id)` -- GenServer.cast :task_unblocked. Transitions blocked -> working.

**handle_cast implementations:**

`{:task_assigned, task_id}`:
1. Transition to :assigned
2. Set current_task_id = task_id
3. Start acceptance timer: `Process.send_after(self(), {:acceptance_timeout, task_id}, @acceptance_timeout_ms)` where `@acceptance_timeout_ms` is 60_000
4. Store timer ref in state

`{:task_accepted, task_id}`:
1. Guard: only if `state.current_task_id == task_id` and `state.fsm_state == :assigned`
2. Cancel acceptance timer via `Process.cancel_timer/1`
3. Transition to :working
4. Clear acceptance_timer_ref

`:task_completed` and `:task_failed`:
1. Guard: only if fsm_state is :working
2. Cancel acceptance timer if somehow still active (safety)
3. Transition to :idle
4. Clear current_task_id and acceptance_timer_ref

`:task_blocked`:
1. Guard: fsm_state == :working
2. Transition to :blocked

`:task_unblocked`:
1. Guard: fsm_state == :blocked
2. Transition to :working

**handle_info implementations:**

`{:DOWN, ref, :process, _pid, _reason}` where ref matches ws_monitor_ref:
1. Log warning with agent_id
2. Cancel acceptance timer if active
3. If current_task_id is not nil, call `AgentCom.TaskQueue.reclaim_task(state.current_task_id)` -- note: this function needs to exist or be added. For now, use `AgentCom.TaskQueue.get(task_id)` to check status, and if :assigned, requeue it. **Important:** The reclaim_task function will be added to TaskQueue in Plan 02. For this plan, implement a private `reclaim_task_from_agent/2` function in AgentFSM that calls a GenServer.call to TaskQueue. If TaskQueue does not yet have a `reclaim_task/1` function, define a minimal stub approach: call `TaskQueue.get(task_id)` and log the reclamation intent. The actual wiring through Socket/TaskQueue happens in Plan 02.
4. Broadcast offline state change
5. Return `{:stop, :normal, %{state | fsm_state: :offline}}`

`{:acceptance_timeout, task_id}` where task_id matches current_task_id:
1. Log warning about unresponsive agent
2. Reclaim the task (same as disconnect logic)
3. Transition to :idle
4. Add :unresponsive to flags (Enum.uniq to prevent duplicates)
5. Clear current_task_id and acceptance_timer_ref

`{:acceptance_timeout, _stale_task_id}` (stale timer):
1. Ignore -- `{:noreply, state}`

**Capability normalization (private function):**
```elixir
defp normalize_capabilities(caps) when is_list(caps) do
  Enum.map(caps, fn
    cap when is_binary(cap) -> %{name: cap}
    cap when is_map(cap) -> cap
    _ -> nil
  end)
  |> Enum.reject(&is_nil/1)
end
defp normalize_capabilities(_), do: []
```

**Helper: lookup_fsm/1** -- Private function for API calls:
```elixir
defp lookup_fsm(agent_id) do
  case Registry.lookup(AgentCom.AgentFSMRegistry, agent_id) do
    [{pid, _}] -> {:ok, pid}
    [] -> {:error, :not_found}
  end
end
```

**Key implementation notes:**
- Do NOT use handle_continue for init -- keep init synchronous (Pitfall 1 from research)
- Do NOT call Presence from AgentFSM in this plan -- that wiring happens in Plan 02
- TaskQueue.reclaim_task/1 may not exist yet. Implement reclaim logic defensively: wrap in try/rescue or check function availability. Plan 02 adds the proper reclaim_task/1 to TaskQueue.
- All Logger calls use `require Logger` at module top
  </action>
  <verify>
Run `mix compile` -- zero errors, zero warnings. Verify module attributes: @valid_transitions has all 4 states mapped, @acceptance_timeout_ms is 60_000. Verify child_spec has restart: :temporary. Verify that the module defines all listed public API functions.
  </verify>
  <done>AgentFSM GenServer exists with validated state transitions, Process.monitor disconnect detection, 60-second acceptance timeout with reclamation, capability normalization, and lookup via Registry. Compiles cleanly with the AgentSupervisor and application.ex changes from Task 1.</done>
</task>

</tasks>

<verification>
After both tasks:
1. `mix compile` produces zero errors and zero warnings
2. `lib/agent_com/agent_supervisor.ex` exists with DynamicSupervisor behavior
3. `lib/agent_com/agent_fsm.ex` exists with GenServer behavior, @valid_transitions, @acceptance_timeout_ms
4. `lib/agent_com/application.ex` includes AgentFSMRegistry and AgentSupervisor in children list
5. AgentFSM.child_spec returns restart: :temporary
</verification>

<success_criteria>
- AgentSupervisor can dynamically start/stop AgentFSM processes
- AgentFSM enforces validated state transitions (rejects invalid ones)
- AgentFSM monitors WebSocket pid and stops on disconnect
- 60-second acceptance timeout is armed on task assignment and cancelled on acceptance
- Capabilities normalized on init (strings -> maps)
- All modules compile without warnings
</success_criteria>

<output>
After completion, create `.planning/phases/03-agent-state/03-01-SUMMARY.md`
</output>
