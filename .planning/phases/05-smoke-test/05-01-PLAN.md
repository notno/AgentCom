---
phase: 05-smoke-test
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - sidecar/index.js
  - mix.exs
  - mix.lock
  - test/smoke/helpers/agent_sim.ex
  - test/smoke/helpers/http_helpers.ex
  - test/smoke/helpers/assertions.ex
  - test/smoke/helpers/setup.ex
  - test/smoke_test_helper.exs
autonomous: true

must_haves:
  truths:
    - "Sidecar sendTaskComplete includes generation field from task_assign message"
    - "Sidecar sendTaskFailed includes generation field from task_assign message"
    - "Fresh WebSocket dependency available in dev/test"
    - "Simulated agent can connect, identify, receive task, and complete it via WebSocket"
    - "HTTP helper can submit tasks and query task status via the API"
    - "DETS state is cleanly reset between test runs"
  artifacts:
    - path: "sidecar/index.js"
      provides: "Generation tracking in task lifecycle messages"
      contains: "generation"
    - path: "mix.exs"
      provides: "Fresh WebSocket client dependency"
      contains: "fresh"
    - path: "test/smoke/helpers/agent_sim.ex"
      provides: "Simulated WebSocket agent GenServer"
      exports: ["start_link", "stop", "completed_count", "received_tasks", "kill_connection"]
    - path: "test/smoke/helpers/http_helpers.ex"
      provides: "HTTP task submission and query helpers"
      exports: ["submit_task", "get_task", "list_tasks", "get_stats"]
    - path: "test/smoke/helpers/assertions.ex"
      provides: "Polling assertions with timeout"
      exports: ["assert_all_completed", "assert_task_completed", "wait_for"]
    - path: "test/smoke/helpers/setup.ex"
      provides: "DETS cleanup and token generation for tests"
      exports: ["reset_task_queue", "create_test_tokens", "cleanup_agents"]
    - path: "test/smoke_test_helper.exs"
      provides: "ExUnit configuration for smoke tests"
      contains: "ExUnit.start"
  key_links:
    - from: "test/smoke/helpers/agent_sim.ex"
      to: "lib/agent_com/socket.ex"
      via: "WebSocket connection using Fresh"
      pattern: "Fresh\\.start_link|ws://localhost"
    - from: "test/smoke/helpers/http_helpers.ex"
      to: "lib/agent_com/endpoint.ex"
      via: "HTTP requests using :httpc"
      pattern: "httpc\\.request|/api/tasks"
    - from: "test/smoke/helpers/setup.ex"
      to: "lib/agent_com/task_queue.ex"
      via: "DETS cleanup and TaskQueue restart"
      pattern: "TaskQueue|dets|File\\.rm"
---

<objective>
Fix the sidecar generation bug and build the complete smoke test infrastructure (simulated WebSocket agent, HTTP helpers, assertion utilities, DETS cleanup).

Purpose: This is the foundation for all 3 smoke test scenarios. The AgentSim GenServer simulates real agents by connecting via WebSocket, identifying, receiving task_assign messages, and automatically completing tasks. The generation bug fix ensures real sidecars can also complete tasks correctly.

Output: Fixed sidecar, Fresh dependency, and 5 test helper modules ready for smoke test scenarios.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-smoke-test/05-RESEARCH.md
@.planning/phases/04-scheduler/04-01-SUMMARY.md
@lib/agent_com/socket.ex
@lib/agent_com/task_queue.ex
@lib/agent_com/auth.ex
@lib/agent_com/agent_fsm.ex
@lib/agent_com/scheduler.ex
@sidecar/index.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix sidecar generation bug and add Fresh dependency</name>
  <files>sidecar/index.js, mix.exs</files>
  <action>
**Sidecar generation bug fix (sidecar/index.js):**

1. In the `handleTaskAssign(msg)` method, store `msg.generation` on the task object (e.g., `this.currentTaskGeneration = msg.generation` or store in a Map keyed by task_id). The task_assign message from the hub includes a `generation` field (see socket.ex line 162).

2. Update `sendTaskComplete(taskId, result)` to include the stored generation:
```javascript
sendTaskComplete(taskId, result) {
  return this.send({ type: 'task_complete', task_id: taskId, result, generation: this.getTaskGeneration(taskId) });
}
```

3. Update `sendTaskFailed(taskId, reason)` to include the stored generation:
```javascript
sendTaskFailed(taskId, reason) {
  return this.send({ type: 'task_failed', task_id: taskId, reason, generation: this.getTaskGeneration(taskId) });
}
```

4. Add a generation tracking mechanism. Simplest approach: add a `taskGenerations` Map to the constructor, set in handleTaskAssign, read in sendTaskComplete/sendTaskFailed, clean up after send. Since only one task is active per sidecar at a time, a simple `this.currentGeneration` field also works.

5. Also check `handleTaskReassign` and `handleTaskContinue` -- if they include a generation, update the stored generation.

**Fresh dependency (mix.exs):**

Add Fresh to deps in mix.exs as dev/test only:
```elixir
{:fresh, "~> 0.4.4", only: [:dev, :test]}
```

Also add `:inets` to extra_applications in application/0 (needed for :httpc in test helpers):
```elixir
extra_applications: [:logger, :runtime_tools, :inets]
```

Run `mix deps.get` to fetch Fresh and update mix.lock.
  </action>
  <verify>
1. `grep "generation" sidecar/index.js` shows generation in sendTaskComplete and sendTaskFailed
2. `grep "fresh" mix.exs` shows the Fresh dependency
3. `cd C:/Users/nrosq/src/AgentCom && mix deps.get` succeeds without errors
4. `mix compile` succeeds
  </verify>
  <done>
Sidecar sendTaskComplete and sendTaskFailed include the generation field tracked from task_assign. Fresh ~> 0.4.4 is in mix.exs deps (dev/test only). :inets is in extra_applications. mix deps.get and mix compile both succeed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create smoke test helper modules and ExUnit configuration</name>
  <files>test/smoke_test_helper.exs, test/smoke/helpers/agent_sim.ex, test/smoke/helpers/http_helpers.ex, test/smoke/helpers/assertions.ex, test/smoke/helpers/setup.ex</files>
  <action>
**test/smoke_test_helper.exs:**
ExUnit configuration for smoke tests. Start ExUnit with appropriate settings:
```elixir
# Ensure :inets is started for :httpc
:inets.start()
ExUnit.start(exclude: [:skip], capture_log: true)
```
Tag smoke tests with `@moduletag :smoke` so they can be run selectively with `mix test test/smoke/ --include smoke`.

**test/smoke/helpers/setup.ex (Smoke.Setup):**
- `reset_task_queue/0`: Stop AgentCom.TaskQueue GenServer, delete DETS files at `priv/task_queue.dets` and `priv/task_dead_letter.dets`, restart TaskQueue via `AgentCom.TaskQueue.start_link([])`. Also stop and restart AgentCom.Scheduler (it needs TaskQueue running).
- `create_test_tokens(agent_ids)`: For each agent_id in the list, call `AgentCom.Auth.generate(agent_id)` and return `%{agent_id => token}` map.
- `cleanup_agents(agent_ids)`: For each agent_id, call `AgentCom.Auth.revoke(agent_id)` if it exists. Also clean up any lingering AgentFSM processes.
- `reset_all/0`: Calls reset_task_queue, useful as a setup callback.

**test/smoke/helpers/http_helpers.ex (Smoke.Http):**
Use :httpc (built into Erlang, no extra deps). All functions take an optional `hub_url` defaulting to `"http://localhost:4000"`.
- `submit_task(description, token, opts \\ [])`: POST to `/api/tasks` with JSON body `%{description, priority (default "normal"), needed_capabilities (default []), metadata (default %{})}`. Return `{:ok, decoded_body}` or `{:error, reason}`. Include `Authorization: Bearer #{token}` header and `Content-Type: application/json`.
- `get_task(task_id, token)`: GET `/api/tasks/#{task_id}` with auth header. Return decoded body.
- `list_tasks(token, opts \\ [])`: GET `/api/tasks` with optional query params (status filter). Return decoded body.
- `get_stats(token)`: GET `/api/tasks/stats` with auth header. Return decoded body.
- Internal `parse_response/1` helper to handle :httpc response tuples and decode JSON.

Note: :httpc uses charlists for URLs and headers, not strings. Use `~c"..."` or `String.to_charlist/1`.

**test/smoke/helpers/assertions.ex (Smoke.Assertions):**
- `assert_all_completed(task_ids, opts \\ [])`: Poll TaskQueue.get for each task_id until all reach `:completed` status. Options: `timeout` (default 30_000ms), `interval` (default 200ms). Raise descriptive error on timeout showing which tasks are incomplete and their current status.
- `assert_task_completed(task_id, opts \\ [])`: Single-task version of above.
- `wait_for(fun, opts \\ [])`: Generic polling helper. Call `fun.()` repeatedly until it returns truthy. Options: `timeout` (default 10_000ms), `interval` (default 100ms). Raise on timeout.

**test/smoke/helpers/agent_sim.ex (Smoke.AgentSim):**
GenServer wrapping a Fresh WebSocket client that simulates an agent.

Constructor opts:
- `agent_id` (required): Agent identifier string
- `token` (required): Auth token from Smoke.Setup.create_test_tokens
- `hub_url` (default `"ws://localhost:4000/ws"`): Hub WebSocket URL
- `on_task_assign` (default `:complete`): Behavior when task is assigned. Options:
  - `:complete` -- immediately send task_accepted then task_complete with generation
  - `:fail` -- send task_accepted then task_failed
  - `:ignore` -- do nothing (simulate unresponsive)
  - `{:delay, ms}` -- send task_accepted, then wait ms before task_complete
- `capabilities` (default `[]`): Capabilities to report in identify message

State tracks:
- `tasks_received`: list of `%{task_id, generation, received_at}` for all received task_assign messages
- `tasks_completed`: count of successfully completed tasks
- `ws_conn`: the WebSocket connection process/state
- `identified`: boolean, set to true after receiving "identified" response

Lifecycle:
1. `init/1`: Connect to hub via WebSocket using Fresh (or Mint.WebSocket if Fresh doesn't work cleanly as a wrapped client). Send identify message: `%{type: "identify", agent_id: agent_id, token: token, name: "smoke-#{agent_id}", status: "idle", capabilities: capabilities}`.
2. On receiving `task_assign` message: store task_id and generation in tasks_received. Based on `on_task_assign`:
   - `:complete`: Send `task_accepted` then `task_complete` with correct generation, tokens_used: 0.
   - `:fail`: Send `task_accepted` then `task_failed` with generation.
   - `:ignore`: Do nothing.
   - `{:delay, ms}`: Send `task_accepted`, schedule delayed completion via Process.send_after.
3. On receiving `identified` message: set identified to true.

Public API:
- `start_link(opts)`: Start the GenServer.
- `stop(pid)`: Graceful stop (closes WebSocket).
- `completed_count(pid)`: Return number of completed tasks.
- `received_tasks(pid)`: Return list of received task maps.
- `kill_connection(pid)`: Abruptly kill the WebSocket process (for failure testing). Do NOT send a clean close frame -- just terminate the underlying connection process so the hub sees an abrupt disconnect, triggering AgentFSM :DOWN handler.
- `identified?(pid)`: Check if the agent has been identified.

IMPORTANT: For WebSocket implementation, if Fresh's API is too opinionated for wrapping in a GenServer, use Mint.HTTP + Mint.WebSocket directly (mint_web_socket is a transitive dep of Fresh). The research shows both approaches. The key requirement is: connect, send JSON frames, receive JSON frames, and abruptly kill the connection.

IMPORTANT: The generation from the task_assign message MUST be stored and sent back in task_complete/task_failed. This is the critical pitfall identified in research (Pitfall 3).
  </action>
  <verify>
1. All 5 files exist: `ls test/smoke_test_helper.exs test/smoke/helpers/agent_sim.ex test/smoke/helpers/http_helpers.ex test/smoke/helpers/assertions.ex test/smoke/helpers/setup.ex`
2. `mix compile` succeeds (all helper modules compile cleanly)
3. Quick sanity: `mix run -e "Smoke.Setup.create_test_tokens([\"test-1\"]) |> IO.inspect()"` returns a map with a token
  </verify>
  <done>
All 5 helper files exist and compile. Smoke.AgentSim can connect via WebSocket, identify, and handle task_assign messages with correct generation tracking. Smoke.Http can submit and query tasks via :httpc. Smoke.Assertions provides polling helpers with timeout. Smoke.Setup can reset DETS and generate test tokens. ExUnit is configured in smoke_test_helper.exs.
  </done>
</task>

</tasks>

<verification>
1. `mix compile` passes with no errors
2. `grep -r "generation" sidecar/index.js` shows generation in sendTaskComplete and sendTaskFailed
3. All test helper files exist under test/smoke/
4. `mix deps.tree` shows fresh as a dependency
</verification>

<success_criteria>
- Sidecar generation bug is fixed (sendTaskComplete and sendTaskFailed include generation from task_assign)
- Fresh dependency added to mix.exs (dev/test only)
- :inets added to extra_applications
- Smoke.AgentSim GenServer connects, identifies, receives task_assign, sends task_complete with correct generation
- Smoke.Http submits tasks via POST /api/tasks and queries via GET
- Smoke.Assertions polls TaskQueue with configurable timeout
- Smoke.Setup resets DETS state and generates auth tokens
- All modules compile cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/05-smoke-test/05-01-SUMMARY.md`
</output>
