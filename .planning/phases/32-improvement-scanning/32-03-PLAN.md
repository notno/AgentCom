---
phase: 32-improvement-scanning
plan: 03
type: execute
wave: 2
depends_on: ["32-01", "32-02"]
files_modified:
  - lib/agent_com/self_improvement/llm_scanner.ex
  - lib/agent_com/self_improvement.ex
  - lib/agent_com/hub_fsm.ex
  - lib/agent_com/hub_fsm/predicates.ex
autonomous: true

must_haves:
  truths:
    - "LlmScanner uses ClaudeClient.identify_improvements/2 to find refactoring opportunities from git diffs"
    - "LlmScanner limits diff size to 50KB and scopes to recent 5 commits"
    - "SelfImprovement.scan_repo/2 orchestrates all 4 scanners with budget enforcement"
    - "SelfImprovement.scan_all/1 cycles through repos in RepoRegistry priority order"
    - "Findings are filtered through ImprovementHistory cooldowns and oscillation detection"
    - "Filtered findings are submitted as low-priority goals to GoalBacklog"
    - "HubFSM has :improving state with valid transitions from/to :resting and :executing"
    - "HubFSM transitions to :improving when resting with no pending goals but improving budget available"
  artifacts:
    - path: "lib/agent_com/self_improvement/llm_scanner.ex"
      provides: "LLM-assisted improvement scanner via ClaudeClient"
      contains: "identify_improvements"
    - path: "lib/agent_com/self_improvement.ex"
      provides: "Main orchestrator module with scan_repo and scan_all"
      contains: "scan_repo"
    - path: "lib/agent_com/hub_fsm.ex"
      provides: "Updated FSM with improving state in valid_transitions"
      contains: ":improving"
    - path: "lib/agent_com/hub_fsm/predicates.ex"
      provides: "Updated predicates with improving state evaluation"
      contains: ":improving"
  key_links:
    - from: "lib/agent_com/self_improvement/llm_scanner.ex"
      to: "lib/agent_com/claude_client.ex"
      via: "ClaudeClient.identify_improvements/2 call"
      pattern: "ClaudeClient\\.identify_improvements"
    - from: "lib/agent_com/self_improvement.ex"
      to: "lib/agent_com/goal_backlog.ex"
      via: "GoalBacklog.submit/1 for finding-to-goal conversion"
      pattern: "GoalBacklog\\.submit"
    - from: "lib/agent_com/self_improvement.ex"
      to: "lib/agent_com/repo_registry.ex"
      via: "RepoRegistry.list_repos/0 for priority-ordered repo cycling"
      pattern: "RepoRegistry\\.list_repos"
    - from: "lib/agent_com/hub_fsm/predicates.ex"
      to: "lib/agent_com/cost_ledger.ex"
      via: "CostLedger.check_budget(:improving) for transition predicate"
      pattern: "check_budget.*:improving"
---

<objective>
Implement the LLM scanner, main SelfImprovement orchestrator, and add the Improving state to HubFSM.

Purpose: This plan wires everything together. The LLM scanner adds the third scanning layer (git diff analysis via Claude). The SelfImprovement module orchestrates all scanners, applies filters, and converts findings to goals. The HubFSM Improving state enables the FSM to autonomously enter improvement scanning mode.

Output: Complete improvement scanning pipeline from scan trigger (HubFSM tick) through finding generation, filtering, and goal submission.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-improvement-scanning/32-RESEARCH.md
@.planning/phases/32-improvement-scanning/32-01-SUMMARY.md
@.planning/phases/32-improvement-scanning/32-02-SUMMARY.md
@lib/agent_com/hub_fsm.ex
@lib/agent_com/hub_fsm/predicates.ex
@lib/agent_com/claude_client.ex
@lib/agent_com/goal_backlog.ex
@lib/agent_com/repo_registry.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create LlmScanner and SelfImprovement orchestrator</name>
  <files>
    lib/agent_com/self_improvement/llm_scanner.ex
    lib/agent_com/self_improvement.ex
  </files>
  <action>
**Create `lib/agent_com/self_improvement/llm_scanner.ex`:**
- Module: `AgentCom.SelfImprovement.LlmScanner`
- @moduledoc describing LLM-assisted code review via git diff
- Public API: `scan(repo_path, repo_name)` -- returns `{:ok, [Finding.t()]}` or `{:error, term()}`

Implementation:
1. Check CostLedger budget first: `AgentCom.CostLedger.check_budget(:improving)`. If `:budget_exhausted`, return `{:ok, []}`.
2. Generate git diff: `System.cmd("git", ["diff", "HEAD~5..HEAD", "--stat"], cd: repo_path, stderr_to_stdout: true)`. If error (e.g., less than 5 commits), try `HEAD~1..HEAD`, then fall back to `{:ok, []}`.
3. Get detailed diff for changed files: `System.cmd("git", ["diff", "HEAD~5..HEAD"], cd: repo_path)`. Cap output to 50KB (take first 50_000 bytes via `String.slice/3`).
4. Call `AgentCom.ClaudeClient.identify_improvements(repo_name, diff_text)`.
5. On `{:ok, improvements}`, map each improvement to a Finding struct:
   - `file_path`: improvement["files"] |> List.first() || "unknown" (ClaudeClient returns files list)
   - `line_number`: 0
   - `scan_type`: "llm_" <> (improvement["category"] || "suggestion")
   - `description`: improvement["title"] <> ": " <> improvement["description"]
   - `severity`: "low" (LLM suggestions default low per research recommendation)
   - `suggested_action`: improvement["description"]
   - `effort`: improvement["effort"] || "medium"
   - `scanner`: :llm
6. On `{:error, reason}`, log warning, return `{:error, reason}`.
7. Wrap System.cmd in try/rescue for :enoent.

**Create `lib/agent_com/self_improvement.ex`:**
- Module: `AgentCom.SelfImprovement`
- @moduledoc: Stateless library module for autonomous codebase improvement scanning. Called by HubFSM during Improving state. Three scanning layers: Elixir tools (Credo, Dialyzer), deterministic analysis, and LLM-assisted review.
- @default_max_findings 5

Public API:

`scan_repo(repo_path, opts \\ [])` -- returns `{:ok, [Finding.t()]}`:
1. Extract options: `max_findings` (default 5), `repo_name` (default Path.basename(repo_path))
2. Initialize ImprovementHistory if not already open (safe re-init)
3. Layer 1: `CredoScanner.scan(repo_path)` ++ `DialyzerScanner.scan(repo_path)`
4. Layer 2: `DeterministicScanner.scan(repo_path)`
5. Combine all deterministic findings
6. Filter: `ImprovementHistory.filter_cooled_down(findings, repo_name)` then `ImprovementHistory.filter_oscillating(findings, repo_name)`
7. Sort by severity (high > medium > low) for priority ordering
8. Take up to max_findings from deterministic (track remaining budget)
9. Layer 3 (only if budget remains): `LlmScanner.scan(repo_path, repo_name)` -- on {:ok, findings}, filter and take remaining budget
10. Return combined findings

`scan_all(opts \\ [])` -- returns `{:ok, [Finding.t()]}`:
1. Get repos from `AgentCom.RepoRegistry.list_repos()` (already priority-ordered)
2. Resolve local paths: `base_dir` option (default from Config or "."), derive repo name from URL, build `Path.join(base_dir, repo_name)`
3. Skip repos where local path doesn't exist (`File.dir?/1`)
4. Call `scan_repo/2` for each repo with accumulated max_findings budget
5. Aggregate all findings

`submit_findings_as_goals(findings, repo_name)` -- returns `[{:ok, goal} | {:error, term()}]`:
1. For each finding, call `AgentCom.GoalBacklog.submit/1` with:
   - `description`: finding.description
   - `success_criteria`: finding.suggested_action
   - `priority`: "low" (per locked decision: self-improvement goals default to "low")
   - `source`: "self_improvement"
   - `tags`: [finding.scan_type, "auto-scan"]
   - `repo`: repo_name
2. For each successfully submitted goal, call `ImprovementHistory.record_improvement(repo_name, finding.file_path, finding.scan_type, finding.description)`
3. Return list of submit results

`run_improvement_cycle(opts \\ [])` -- full cycle, returns `{:ok, %{findings: integer, goals_submitted: integer}}`:
1. Call scan_all(opts)
2. Group findings by repo
3. For each repo's findings, call submit_findings_as_goals
4. Return summary counts
  </action>
  <verify>
    `mix compile --warnings-as-errors` passes for both modules.
  </verify>
  <done>
    LlmScanner wraps ClaudeClient.identify_improvements with budget checking and diff size limits. SelfImprovement orchestrates all 4 scanners with cooldown/oscillation filtering, repo cycling via RepoRegistry, and finding-to-goal conversion via GoalBacklog. Max findings budget prevents goal flooding.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Improving state to HubFSM and Predicates</name>
  <files>
    lib/agent_com/hub_fsm.ex
    lib/agent_com/hub_fsm/predicates.ex
  </files>
  <action>
**Update `lib/agent_com/hub_fsm.ex`:**

1. Update `@valid_transitions` to include :improving:
   ```elixir
   @valid_transitions %{
     resting: [:executing, :improving],
     executing: [:resting],
     improving: [:resting, :executing]
   }
   ```
   Transitions: resting -> improving (when no goals but improving budget available), improving -> executing (when goal submitted), improving -> resting (scan complete or budget exhausted).

2. Update @moduledoc: change "2-state FSM" to "3-state FSM", add :improving to the States table with meaning "Scanning codebases for improvements".

3. In `gather_system_state/0`, add improving budget check:
   ```elixir
   improving_budget_available =
     try do
       AgentCom.CostLedger.check_budget(:improving) == :ok
     catch
       :exit, _ -> false
     end
   ```
   Add `improving_budget_available: improving_budget_available` to the returned map.

4. In `do_transition/2`, update the ClaudeClient hub state notification:
   - Instead of always setting `:executing`, set the actual `new_state` if it's in ClaudeClient's valid states.
   - `:resting` is NOT a valid hub state for ClaudeClient, so only set for `:executing` and `:improving`:
   ```elixir
   if new_state in [:executing, :improving] do
     AgentCom.ClaudeClient.set_hub_state(new_state)
   end
   ```

5. In `handle_info(:tick, state)` for the active (non-paused) case, when the FSM is in `:improving` state and a transition to `:improving` doesn't happen (stays), trigger the improvement scan. Add after the Predicates evaluation:
   - When `state.fsm_state == :improving` and result is `:stay`, call `AgentCom.SelfImprovement.run_improvement_cycle()` in a Task.async/yield pattern (like ClaudeClient uses) to avoid blocking the GenServer. On completion, force transition to `:resting`. This means the improving state does ONE scan cycle per entry, then returns to resting.
   - Actually, simpler: on transition INTO :improving, spawn a Task that runs the improvement cycle, then sends a message back to the GenServer to transition to :resting. Add a `handle_info({:improvement_cycle_complete, result}, state)` callback.

   In `do_transition/2`, when `new_state == :improving`:
   ```elixir
   if new_state == :improving do
     pid = self()
     Task.start(fn ->
       result = AgentCom.SelfImprovement.run_improvement_cycle()
       send(pid, {:improvement_cycle_complete, result})
     end)
   end
   ```

   Add handler:
   ```elixir
   def handle_info({:improvement_cycle_complete, result}, state) do
     Logger.info("improvement_cycle_complete", result: inspect(result))
     if state.fsm_state == :improving do
       updated = do_transition(state, :resting, "improvement cycle complete")
       {:noreply, updated}
     else
       {:noreply, state}
     end
   end
   ```

**Update `lib/agent_com/hub_fsm/predicates.ex`:**

1. Update @moduledoc: change "2-state core" to "3-state core", add :improving to parameter docs.

2. Add improving predicates:
   ```elixir
   # Resting -> improving: no pending goals, no active goals, but improving budget available
   def evaluate(:resting, %{pending_goals: 0, active_goals: 0, improving_budget_available: true}) do
     {:transition, :improving, "no goals, improving budget available"}
   end
   ```
   This clause must come AFTER the existing `evaluate(:resting, %{budget_exhausted: true})` and `evaluate(:resting, %{pending_goals: pending}) when pending > 0` clauses, but BEFORE the catch-all `evaluate(:resting, _system_state)`.

   ```elixir
   # Improving -> executing: goals submitted (new work to do)
   def evaluate(:improving, %{pending_goals: pending}) when pending > 0 do
     {:transition, :executing, "goals submitted while improving"}
   end

   # Improving -> resting: budget exhausted
   def evaluate(:improving, %{budget_exhausted: true}) do
     {:transition, :resting, "budget exhausted while improving"}
   end

   # Improving: stay (scan in progress)
   def evaluate(:improving, _system_state), do: :stay
   ```

3. Update @spec doc to include :improving as valid current_state.
  </action>
  <verify>
    `mix compile --warnings-as-errors` passes.
    Verify HubFSM valid_transitions includes :improving with correct from/to states.
    Verify Predicates handles :improving state correctly.
  </verify>
  <done>
    HubFSM is now a 3-state FSM (resting, executing, improving). When resting with no goals and improving budget available, it transitions to improving. The improving state spawns an async improvement cycle, then transitions back to resting on completion. Goals submitted during improving trigger transition to executing. Predicates correctly evaluate all three states.
  </done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` passes for all 4 modified/created files
2. LlmScanner checks CostLedger budget before making API calls
3. SelfImprovement.scan_repo/2 calls all 4 scanners in correct order
4. SelfImprovement.submit_findings_as_goals/2 creates "low" priority goals
5. HubFSM @valid_transitions includes :improving
6. Predicates.evaluate(:resting, %{pending_goals: 0, active_goals: 0, improving_budget_available: true}) returns {:transition, :improving, _}
7. Full improvement cycle: resting -> improving -> scan -> submit goals -> resting
</verification>

<success_criteria>
LLM scanner wraps ClaudeClient with budget checks and diff size limits. SelfImprovement module orchestrates all scanning layers with filtering and goal submission. HubFSM has a working :improving state that triggers autonomous improvement scanning when idle. The complete pipeline from FSM tick to goal creation works end-to-end.
</success_criteria>

<output>
After completion, create `.planning/phases/32-improvement-scanning/32-03-SUMMARY.md`
</output>
