---
phase: 32-improvement-scanning
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/agent_com/self_improvement/credo_scanner.ex
  - lib/agent_com/self_improvement/dialyzer_scanner.ex
  - lib/agent_com/self_improvement/deterministic_scanner.ex
autonomous: true

must_haves:
  truths:
    - "CredoScanner runs mix credo --format json and parses structured output into findings"
    - "CredoScanner skips repos without :credo in mix.exs deps"
    - "DialyzerScanner runs mix dialyzer --format short and parses file:line:warning output"
    - "DialyzerScanner skips repos without :dialyxir in mix.exs and repos without PLT"
    - "DeterministicScanner identifies test gaps (modules without test files)"
    - "DeterministicScanner identifies doc gaps (modules without @moduledoc)"
    - "DeterministicScanner identifies dead dependencies (deps not referenced in source)"
  artifacts:
    - path: "lib/agent_com/self_improvement/credo_scanner.ex"
      provides: "Credo JSON integration scanner"
      contains: "mix.*credo.*json"
    - path: "lib/agent_com/self_improvement/dialyzer_scanner.ex"
      provides: "Dialyzer short-format integration scanner"
      contains: "mix.*dialyzer.*short"
    - path: "lib/agent_com/self_improvement/deterministic_scanner.ex"
      provides: "Test gap, doc gap, dead dep scanner"
      contains: "test_gap"
  key_links:
    - from: "lib/agent_com/self_improvement/credo_scanner.ex"
      to: "System.cmd"
      via: "Shell out to mix credo"
      pattern: "System\\.cmd"
    - from: "lib/agent_com/self_improvement/deterministic_scanner.ex"
      to: "File system"
      via: "File.read and Path operations for gap detection"
      pattern: "File\\.(read|exists)"
---

<objective>
Implement the three deterministic scanning sub-modules: Credo integration, Dialyzer integration, and custom deterministic analysis (test gaps, doc gaps, dead deps).

Purpose: These scanners form the first two layers of the improvement scanning pipeline. They run without LLM cost, producing findings that get filtered through ImprovementHistory before becoming goals. Each scanner returns a list of Finding structs with consistent structure.

Output: Three scanner modules that can independently scan an Elixir repo and return findings.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-improvement-scanning/32-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CredoScanner and DialyzerScanner modules</name>
  <files>
    lib/agent_com/self_improvement/credo_scanner.ex
    lib/agent_com/self_improvement/dialyzer_scanner.ex
  </files>
  <action>
Create `lib/agent_com/self_improvement/credo_scanner.ex`:
- Module: `AgentCom.SelfImprovement.CredoScanner`
- @moduledoc describing Credo JSON integration
- Public API: `scan(repo_path)` -- returns list of Finding structs (never errors, returns [] on failure)

Implementation:
1. `has_credo?(repo_path)` -- read mix.exs, check for `:credo` in content. Return false if file unreadable.
2. If no credo, return [].
3. Run `System.cmd("mix", ["credo", "--format", "json", "--all"], cd: repo_path, stderr_to_stdout: true, env: [{"MIX_ENV", "dev"}])`.
   - Credo returns exit code 1 when issues found -- that's normal, not an error.
4. Parse output with `Jason.decode/1`. Extract `"issues"` array.
5. Map each issue to a Finding struct:
   - `file_path`: issue["filename"] -- already relative
   - `line_number`: issue["line_no"] || 0
   - `scan_type`: "credo_" <> (issue["category"] || "unknown")
   - `description`: issue["message"]
   - `severity`: convert Credo priority (>=10 -> "high", >=1 -> "medium", else "low")
   - `suggested_action`: issue["message"]
   - `effort`: "small" (Credo issues are typically small fixes)
   - `scanner`: :credo
6. On Jason decode error, return [].

Create `lib/agent_com/self_improvement/dialyzer_scanner.ex`:
- Module: `AgentCom.SelfImprovement.DialyzerScanner`
- @moduledoc describing Dialyzer short-format integration
- Public API: `scan(repo_path)` -- returns list of Finding structs

Implementation:
1. `has_dialyxir?(repo_path)` -- read mix.exs, check for `:dialyxir` in content.
2. `has_plt?(repo_path)` -- check if `Path.join([repo_path, "_build", "dev", "dialyxir_erlang-*.plt"])` or `Path.join([repo_path, "_build", "dev", "dialyzer", "plt"])` directory exists via Path.wildcard. Skip if no PLT exists (avoid 30-min PLT build time).
3. If no dialyxir or no PLT, return [].
4. Run `System.cmd("mix", ["dialyzer", "--format", "short", "--quiet"], cd: repo_path, stderr_to_stdout: true, env: [{"MIX_ENV", "dev"}])`.
   - Exit 0 = no warnings -> return []
   - Exit 2 = warnings found -> parse output
   - Other exit codes -> return []
5. Parse short format: each line matches `~r/^(.+):(\d+):(\w+)\s+(.+)$/`
   - file, line_no, warning_type, message
6. Map to Finding struct:
   - `file_path`: captured file
   - `line_number`: String.to_integer(line_no)
   - `scan_type`: "dialyzer_#{warning_type}"
   - `description`: message
   - `severity`: "medium" (all Dialyzer warnings are medium by default; "high" for pattern_match and no_return types)
   - `suggested_action`: "Fix Dialyzer warning: #{message}"
   - `effort`: "medium"
   - `scanner`: :dialyzer

Both scanners: wrap System.cmd in try/rescue for :enoent (mix binary not found). Return [] on any unexpected error. Add Logger.debug for scan start/end.
  </action>
  <verify>
    `mix compile --warnings-as-errors` passes for both modules.
  </verify>
  <done>
    CredoScanner parses Credo JSON output into findings. DialyzerScanner parses Dialyzer short format. Both gracefully skip repos without the required dependency or PLT. Both return [] on any error.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DeterministicScanner for test gaps, doc gaps, dead deps</name>
  <files>lib/agent_com/self_improvement/deterministic_scanner.ex</files>
  <action>
Create `lib/agent_com/self_improvement/deterministic_scanner.ex`:
- Module: `AgentCom.SelfImprovement.DeterministicScanner`
- @moduledoc describing the three deterministic analysis types
- Public API: `scan(repo_path)` -- returns list of Finding structs

Implementation - three analysis types combined:

**test_gaps(repo_path):**
1. Find all .ex files under `lib/` (not .exs) using Path.wildcard
2. For each module file, compute expected test path: replace `lib/` with `test/`, replace `.ex` with `_test.exs`
3. Check if the test file exists. If not, create a finding:
   - `scan_type`: "test_gap"
   - `severity`: "medium"
   - `effort`: "medium"
   - `scanner`: :deterministic
4. Skip files in `lib/*/application.ex` and `lib/*/repo.ex` (boilerplate modules unlikely to need dedicated tests)

**doc_gaps(repo_path):**
1. Find all .ex files under `lib/`
2. Read each file, check if it contains `defmodule` but NOT `@moduledoc`
3. Skip files that are pure struct definitions (only have defstruct, no public functions)
4. Create finding for missing @moduledoc:
   - `scan_type`: "doc_gap"
   - `severity`: "low"
   - `effort`: "small"
   - `scanner`: :deterministic

**dead_deps(repo_path):**
1. Read `mix.exs`, extract dependency names using regex: `~r/\{:(\w+),/`
2. Read all source files (lib/ + test/) into concatenated string
3. For each dep, convert atom name to PascalCase module name via `Macro.camelize/1`
4. If module name not found in any source file, flag as potentially dead
5. Skip common false positives: `:phoenix`, `:plug`, `:jason`, `:telemetry` (often used implicitly via macros or configs). Maintain a `@implicit_deps` module attribute list.
6. Create finding:
   - `scan_type`: "dead_dep"
   - `severity`: "low"
   - `effort`: "small"
   - `scanner`: :deterministic

Main `scan/1` function: call all three, concatenate results. Wrap each in try/rescue returning [] on failure. If repo_path doesn't have a `lib/` directory, return [].
  </action>
  <verify>
    `mix compile --warnings-as-errors` passes.
  </verify>
  <done>
    DeterministicScanner identifies three types of codebase issues without any LLM calls: modules without test files, modules without @moduledoc, and mix.exs dependencies not referenced in source code. Each finding type has appropriate severity and effort classification.
  </done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` passes for all three scanner modules
2. CredoScanner.scan/1 returns [] for a repo without Credo
3. DialyzerScanner.scan/1 returns [] for a repo without Dialyxir
4. DeterministicScanner.scan/1 returns findings with proper Finding struct format
5. All scanners handle missing repos/files gracefully (no crashes)
</verification>

<success_criteria>
Three deterministic scanner modules exist, each returning lists of Finding structs. Credo and Dialyzer scanners check for tool availability before running. DeterministicScanner finds test gaps, doc gaps, and dead dependencies. All scanners are resilient to errors and never crash.
</success_criteria>

<output>
After completion, create `.planning/phases/32-improvement-scanning/32-02-SUMMARY.md`
</output>
