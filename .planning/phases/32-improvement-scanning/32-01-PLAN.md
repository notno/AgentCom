---
phase: 32-improvement-scanning
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/agent_com/self_improvement/finding.ex
  - lib/agent_com/self_improvement/improvement_history.ex
  - lib/agent_com/dets_backup.ex
autonomous: true

must_haves:
  truths:
    - "Finding struct captures all scan metadata (file, severity, effort, scanner, scan_type)"
    - "ImprovementHistory persists records in DETS keyed by {repo, file_path}"
    - "File cooldowns block re-scanning files improved within configurable window (default 24h)"
    - "Anti-oscillation detection flags files with 3+ consecutive inverse-pattern improvements"
    - "DETS table :improvement_history is registered in DetsBackup for backup/recovery"
  artifacts:
    - path: "lib/agent_com/self_improvement/finding.ex"
      provides: "Common finding struct with typed fields"
      contains: "defstruct"
    - path: "lib/agent_com/self_improvement/improvement_history.ex"
      provides: "DETS-backed history with cooldown and oscillation detection"
      contains: "improvement_history"
    - path: "lib/agent_com/dets_backup.ex"
      provides: "Updated tables list including :improvement_history"
      contains: ":improvement_history"
  key_links:
    - from: "lib/agent_com/self_improvement/improvement_history.ex"
      to: ":dets"
      via: "DETS operations for persistent storage"
      pattern: "dets\\.(open_file|insert|lookup|sync)"
    - from: "lib/agent_com/dets_backup.ex"
      to: "lib/agent_com/self_improvement/improvement_history.ex"
      via: "table_owner and get_table_path clauses"
      pattern: ":improvement_history"
---

<objective>
Create the foundation data structures and persistence layer for improvement scanning.

Purpose: All scanners need a common Finding struct to return results, and ImprovementHistory provides the anti-Sisyphus protections (cooldowns, oscillation detection) that every scanner's output gets filtered through. DetsBackup registration ensures the history table is backed up and recoverable.

Output: Finding struct, ImprovementHistory module with DETS persistence, DetsBackup updated with :improvement_history table.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-improvement-scanning/32-RESEARCH.md
@lib/agent_com/dets_backup.ex
@lib/agent_com/repo_scanner/finding.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Finding struct and ImprovementHistory module</name>
  <files>
    lib/agent_com/self_improvement/finding.ex
    lib/agent_com/self_improvement/improvement_history.ex
  </files>
  <action>
Create `lib/agent_com/self_improvement/finding.ex`:
- Define `AgentCom.SelfImprovement.Finding` struct with fields:
  - `file_path` (String.t) -- relative path within repo
  - `line_number` (non_neg_integer) -- 0 if not applicable
  - `scan_type` (String.t) -- e.g. "credo_refactor", "test_gap", "dialyzer_unknown_type", "llm_suggestion"
  - `description` (String.t) -- human-readable finding description
  - `severity` (String.t) -- "high", "medium", "low"
  - `suggested_action` (String.t) -- what to do about it
  - `effort` (String.t) -- "small", "medium", "large" (for tiered autonomy Phase 34)
  - `scanner` (atom) -- :credo, :dialyzer, :deterministic, :llm
- Add @type t() and @enforce_keys for required fields
- Add @moduledoc

Create `lib/agent_com/self_improvement/improvement_history.ex`:
- Define `AgentCom.SelfImprovement.ImprovementHistory` as a library module (not GenServer)
- DETS table name: `:improvement_history`
- Data directory: `Application.get_env(:agent_com, :improvement_history_data_dir, "priv/data/improvement_history")`
- DETS type: `:set`, keyed by `{repo_name, file_path}` tuple
- Each record stores a list of up to 10 most recent entries: `%{scan_type: atom, description: String.t, timestamp: integer}`

Public API:
- `init/0` -- open DETS file, mkdir_p data dir. Returns `:ok` or `{:error, term()}`
- `close/0` -- close DETS table
- `record_improvement(repo, file_path, scan_type, description)` -- prepend new entry, keep last 10, sync
- `cooled_down?(repo, file_path, cooldown_ms \\ @default_cooldown_ms)` -- returns true if file was improved within cooldown window. Default 24 hours (86_400_000 ms). Configurable via `AgentCom.Config.get(:improvement_cooldown_ms)` with fallback to default.
- `oscillating?(repo, file_path)` -- returns true if file has 3+ records and consecutive descriptions contain inverse patterns
- `filter_cooled_down(findings, repo_name)` -- Enum.reject findings where cooled_down? is true
- `filter_oscillating(findings, repo_name)` -- Enum.reject findings where oscillating? is true
- `clear/0` -- delete all records (for testing)
- `all_records/0` -- dump all records (for testing/debugging)

Oscillation detection (per research):
- Define inverse pairs as module attribute: `[{"add", "remove"}, {"extract", "inline"}, {"increase", "decrease"}, {"enable", "disable"}, {"split", "merge"}, {"expand", "collapse"}]`
- Take last 3 records for a file
- Downcase descriptions and check if any two consecutive descriptions contain terms from an inverse pair
- Return true if oscillation detected

For cooled_down?, try reading cooldown from Config GenServer with catch :exit fallback to default, matching the fail-open pattern used by CostLedger.
  </action>
  <verify>
    Run `mix compile --warnings-as-errors` -- both modules compile without warnings.
    Verify struct can be created: `%AgentCom.SelfImprovement.Finding{file_path: "test.ex", line_number: 1, scan_type: "test", description: "test", severity: "low", suggested_action: "fix", effort: "small", scanner: :deterministic}`
  </verify>
  <done>
    Finding struct exists with all 8 fields. ImprovementHistory module provides init/close/record/cooldown/oscillation/filter APIs backed by DETS. Oscillation detection uses inverse-pattern matching on consecutive improvement descriptions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register :improvement_history in DetsBackup</name>
  <files>lib/agent_com/dets_backup.ex</files>
  <action>
Update `lib/agent_com/dets_backup.ex`:

1. Add `:improvement_history` to the `@tables` list (after `:goal_backlog`). Update the @moduledoc table count from "11 DETS tables" to "12 DETS tables" in both the moduledoc and the compaction/backup descriptions.

2. Add `table_owner/1` clause:
   ```elixir
   defp table_owner(:improvement_history), do: AgentCom.SelfImprovement.ImprovementHistory
   ```
   Note: ImprovementHistory is NOT a GenServer, so compaction via GenServer.call won't work. Add a special case in `compact_table/1`: if `table_owner(table_atom)` is `AgentCom.SelfImprovement.ImprovementHistory`, call `:dets.sync(table_atom)` directly instead of GenServer.call, since the table is opened by a library module, not a GenServer. The sync-then-compact approach: `:dets.sync(:improvement_history)` then skip (compaction not needed for library-owned tables -- DETS auto-compacts on close).

   Actually, simpler approach: since ImprovementHistory is a library module, add it to a `@library_tables` list. In `compact_table/1`, if `table_atom in @library_tables`, just do `:dets.sync(table_atom)` and return `{:compacted, 0}`.

3. Add `get_table_path/1` clause:
   ```elixir
   :improvement_history ->
     dir = Application.get_env(:agent_com, :improvement_history_data_dir, "priv/data/improvement_history")
     Path.join(dir, "improvement_history.dets")
   ```

4. For backup_table: the table will be opened by ImprovementHistory.init/0 which is called during application startup or by the SelfImprovement module. The backup logic uses `:dets.info(table_atom, :type)` which returns `:undefined` if not open -- this is fine, backup will skip it with an error result.

5. For restore: since ImprovementHistory is not supervised, the restore flow (terminate_child/restart_child) won't work. In `perform_restore/2`, add a special case: if `table_owner(table_atom)` is in `@library_tables`, close DETS directly, copy backup, reopen. Pattern:
   ```elixir
   :dets.close(table_atom)
   File.cp!(backup_path, original_path)
   ImprovementHistory.init()
   ```
  </action>
  <verify>
    Run `mix compile --warnings-as-errors` -- DetsBackup compiles without warnings.
    Verify `:improvement_history` appears in the @tables list.
  </verify>
  <done>
    DetsBackup @tables includes :improvement_history. table_owner, get_table_path, compact_table, and restore all handle the library-module-owned DETS table correctly. Backup runs include the improvement_history table.
  </done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` passes
2. Finding struct is constructable with all required fields
3. ImprovementHistory.init/0 creates DETS file
4. record_improvement/4, cooled_down?/3, oscillating?/2 work correctly
5. DetsBackup.@tables includes :improvement_history
6. DetsBackup compaction handles library-owned table gracefully
</verification>

<success_criteria>
Finding struct and ImprovementHistory module exist with full DETS-backed persistence. Anti-Sisyphus protections (cooldowns + oscillation detection) are implemented. DetsBackup is updated to include the new DETS table for backup/recovery/compaction.
</success_criteria>

<output>
After completion, create `.planning/phases/32-improvement-scanning/32-01-SUMMARY.md`
</output>
