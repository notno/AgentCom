---
phase: 33-contemplation-and-scalability
plan: 03
type: tdd
wave: 2
depends_on: ["33-01", "33-02"]
files_modified:
  - test/agent_com/hub_fsm/predicates_test.exs
  - test/agent_com/contemplation_test.exs
  - test/agent_com/contemplation/proposal_writer_test.exs
  - test/agent_com/contemplation/scalability_analyzer_test.exs
  - test/agent_com/xml/schemas/proposal_test.exs
autonomous: true

must_haves:
  truths:
    - "Predicates tests cover all :contemplating transitions"
    - "Contemplation orchestrator tests verify full cycle behavior"
    - "ProposalWriter tests verify XML file output"
    - "ScalabilityAnalyzer tests verify metric analysis"
    - "Proposal schema tests verify enriched field round-trip"
  artifacts:
    - path: "test/agent_com/hub_fsm/predicates_test.exs"
      provides: "Contemplating predicate tests"
      contains: "contemplating"
    - path: "test/agent_com/contemplation_test.exs"
      provides: "Contemplation orchestrator tests"
      contains: "Contemplation"
    - path: "test/agent_com/contemplation/proposal_writer_test.exs"
      provides: "ProposalWriter file output tests"
      contains: "ProposalWriter"
    - path: "test/agent_com/contemplation/scalability_analyzer_test.exs"
      provides: "ScalabilityAnalyzer metric analysis tests"
      contains: "ScalabilityAnalyzer"
    - path: "test/agent_com/xml/schemas/proposal_test.exs"
      provides: "Enriched Proposal schema round-trip tests"
      contains: "why_now"
  key_links:
    - from: "test/agent_com/hub_fsm/predicates_test.exs"
      to: "lib/agent_com/hub_fsm/predicates.ex"
      via: "Pure function unit tests"
      pattern: "Predicates\\.evaluate"
    - from: "test/agent_com/xml/schemas/proposal_test.exs"
      to: "lib/agent_com/xml/schemas/proposal.ex"
      via: "Struct creation and XML round-trip"
      pattern: "Proposal\\.new"
---

<objective>
Write comprehensive TDD test suite for all contemplation and HubFSM expansion modules, covering predicates, proposal schema enrichment, scalability analysis, proposal writing, and the contemplation orchestrator.

Purpose: No tests exist for any contemplation modules. The HubFSM predicates test needs expansion for the new :contemplating state. All modules implemented in Plans 01 and 02 need verification through tests.

Output: Full test coverage for the contemplation subsystem with all tests passing.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/33-contemplation-and-scalability/33-01-SUMMARY.md
@.planning/phases/33-contemplation-and-scalability/33-02-SUMMARY.md

@lib/agent_com/hub_fsm/predicates.ex
@lib/agent_com/xml/schemas/proposal.ex
@lib/agent_com/contemplation.ex
@lib/agent_com/contemplation/proposal_writer.ex
@lib/agent_com/contemplation/scalability_analyzer.ex
@lib/agent_com/claude_client/prompt.ex
@lib/agent_com/claude_client/response.ex
@test/agent_com/hub_fsm/predicates_test.exs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Predicates contemplating tests and Proposal schema round-trip tests</name>
  <files>
    test/agent_com/hub_fsm/predicates_test.exs
    test/agent_com/xml/schemas/proposal_test.exs
  </files>
  <action>
### A. Expand Predicates test (test/agent_com/hub_fsm/predicates_test.exs)

Add a new `describe` block for `:contemplating` state predicates. Follow the exact pattern of existing describe blocks. async: true (pure functions).

Tests to add:

```elixir
describe "evaluate/2 when :contemplating" do
  test "stays when no pending goals and budget ok (cycle in progress)" do
    system_state = %{pending_goals: 0, active_goals: 0, budget_exhausted: false}
    assert :stay = Predicates.evaluate(:contemplating, system_state)
  end

  test "transitions to :executing when pending goals exist" do
    system_state = %{pending_goals: 3, active_goals: 0, budget_exhausted: false}
    assert {:transition, :executing, reason} = Predicates.evaluate(:contemplating, system_state)
    assert reason =~ "goals"
  end

  test "transitions to :resting when budget exhausted" do
    system_state = %{pending_goals: 0, active_goals: 0, budget_exhausted: true}
    assert {:transition, :resting, reason} = Predicates.evaluate(:contemplating, system_state)
    assert reason =~ "budget"
  end

  test "goals take priority over budget when both present" do
    # When goals are submitted and budget is exhausted, goals submitted check fires first
    system_state = %{pending_goals: 2, active_goals: 0, budget_exhausted: true}
    result = Predicates.evaluate(:contemplating, system_state)
    # Should transition to :executing (goals submitted check is first clause)
    assert {:transition, :executing, _reason} = result
  end
end

describe "evaluate/2 with unknown state" do
  test "returns :stay for unknown state (defensive catch-all)" do
    system_state = %{pending_goals: 0, active_goals: 0, budget_exhausted: false}
    assert :stay = Predicates.evaluate(:unknown_state, system_state)
  end
end
```

Also update the existing improving tests that now fail due to the richer system_state. The existing tests may need `improving_budget_available` and `contemplating_budget_available` keys added to their system_state maps if pattern matching requires them. Check compilation first -- if they pass without changes, leave them.

### B. Create Proposal schema test (test/agent_com/xml/schemas/proposal_test.exs)

New file. async: true (pure struct operations).

```elixir
defmodule AgentCom.XML.Schemas.ProposalTest do
  use ExUnit.Case, async: true

  alias AgentCom.XML.Schemas.Proposal

  describe "new/1" do
    test "creates proposal with all enriched fields" do
      attrs = %{
        id: "prop-test-1",
        title: "Test Proposal",
        problem: "Things break under load",
        solution: "Add circuit breaker",
        description: "Implement circuit breaker pattern",
        rationale: "3 failures in 24 hours",
        why_now: "Approaching production scale",
        why_not: "Adds complexity",
        impact: "high",
        effort: "medium",
        repo: "AgentCom",
        related_files: ["lib/agent_com/claude_client.ex"],
        dependencies: ["ClaudeClient refactor"],
        proposed_at: "2026-02-13T00:00:00Z"
      }

      assert {:ok, proposal} = Proposal.new(attrs)
      assert proposal.problem == "Things break under load"
      assert proposal.solution == "Add circuit breaker"
      assert proposal.why_now == "Approaching production scale"
      assert proposal.why_not == "Adds complexity"
      assert proposal.dependencies == ["ClaudeClient refactor"]
      assert proposal.related_files == ["lib/agent_com/claude_client.ex"]
    end

    test "creates proposal with minimal required fields" do
      attrs = %{id: "p1", title: "Title", description: "Desc"}
      assert {:ok, proposal} = Proposal.new(attrs)
      assert proposal.problem == nil
      assert proposal.why_now == nil
      assert proposal.dependencies == []
    end

    test "rejects missing id" do
      assert {:error, _} = Proposal.new(%{title: "T", description: "D"})
    end

    test "rejects missing title" do
      assert {:error, _} = Proposal.new(%{id: "1", description: "D"})
    end

    test "rejects invalid impact" do
      attrs = %{id: "1", title: "T", description: "D", impact: "extreme"}
      assert {:error, msg} = Proposal.new(attrs)
      assert msg =~ "impact"
    end
  end

  describe "XML round-trip" do
    test "encode and decode preserves enriched fields" do
      {:ok, proposal} = Proposal.new(%{
        id: "rt-1",
        title: "Round Trip",
        problem: "Test problem",
        solution: "Test solution",
        description: "Test desc",
        rationale: "Test rationale",
        why_now: "Test why now",
        why_not: "Test why not",
        impact: "high",
        effort: "small",
        repo: "AgentCom",
        related_files: ["lib/foo.ex", "lib/bar.ex"],
        dependencies: ["dep-a", "dep-b"],
        proposed_at: "2026-02-13T00:00:00Z"
      })

      assert {:ok, xml} = AgentCom.XML.encode(proposal)
      assert is_binary(xml)
      assert xml =~ "why-now"
      assert xml =~ "why-not"
      assert xml =~ "dependencies"

      # Decode back
      assert {:ok, decoded} = AgentCom.XML.decode(xml, Proposal)
      assert decoded.id == "rt-1"
      assert decoded.problem == "Test problem"
      assert decoded.solution == "Test solution"
      assert decoded.why_now == "Test why now"
      assert decoded.why_not == "Test why not"
      assert decoded.dependencies == ["dep-a", "dep-b"]
      assert decoded.related_files == ["lib/foo.ex", "lib/bar.ex"]
    end

    test "encode and decode with nil optional fields" do
      {:ok, proposal} = Proposal.new(%{
        id: "rt-2",
        title: "Minimal",
        description: "Minimal desc"
      })

      assert {:ok, xml} = AgentCom.XML.encode(proposal)
      assert {:ok, decoded} = AgentCom.XML.decode(xml, Proposal)
      assert decoded.id == "rt-2"
      assert decoded.problem == nil
      assert decoded.dependencies == []
    end
  end
end
```
  </action>
  <verify>RED: `mix test test/agent_com/hub_fsm/predicates_test.exs test/agent_com/xml/schemas/proposal_test.exs --trace` -- all tests should pass (code was implemented in Plans 01 and 02). If any fail, fix the source code first, then re-run.</verify>
  <done>Predicates tests cover all :contemplating transitions (stay, goals-submitted, budget-exhausted, priority). Proposal schema tests verify struct creation with enriched fields and XML round-trip preservation.</done>
</task>

<task type="auto">
  <name>Task 2: Contemplation module tests (orchestrator, writer, analyzer)</name>
  <files>
    test/agent_com/contemplation_test.exs
    test/agent_com/contemplation/proposal_writer_test.exs
    test/agent_com/contemplation/scalability_analyzer_test.exs
  </files>
  <action>
### A. ScalabilityAnalyzer test (test/agent_com/contemplation/scalability_analyzer_test.exs)

New file. async: true (pure function, no GenServer deps when snapshot provided).

```elixir
defmodule AgentCom.Contemplation.ScalabilityAnalyzerTest do
  use ExUnit.Case, async: true

  alias AgentCom.Contemplation.ScalabilityAnalyzer

  @healthy_snapshot %{
    queue_depth: %{current: 2, trend: [1, 1, 2, 2, 2], max_1h: 3, avg_1h: 1.5},
    task_latency: %{window: %{p50: 5000, p90: 10000, p99: 20000, count: 10, min: 1000, max: 25000, mean: 8000}},
    agent_utilization: %{system: %{total_agents: 4, agents_online: 4, agents_idle: 2, agents_working: 2, utilization_pct: 50.0}},
    error_rates: %{window: %{total_tasks: 100, failed: 2, dead_letter: 0, failure_rate_pct: 2.0}}
  }

  @critical_snapshot %{
    queue_depth: %{current: 60, trend: [10, 20, 30, 40, 60], max_1h: 60, avg_1h: 40.0},
    task_latency: %{window: %{p50: 60000, p90: 150000, p99: 300000, count: 50, min: 5000, max: 350000, mean: 80000}},
    agent_utilization: %{system: %{total_agents: 4, agents_online: 4, agents_idle: 0, agents_working: 4, utilization_pct: 95.0}},
    error_rates: %{window: %{total_tasks: 100, failed: 20, dead_letter: 5, failure_rate_pct: 20.0}}
  }

  describe "analyze/1" do
    test "healthy system returns healthy state" do
      result = ScalabilityAnalyzer.analyze(@healthy_snapshot)
      assert result.current_state == :healthy
      assert result.recommendation =~ "healthy"
      assert result.bottleneck_analysis == []
    end

    test "critical system returns critical state with bottlenecks" do
      result = ScalabilityAnalyzer.analyze(@critical_snapshot)
      assert result.current_state == :critical
      assert length(result.bottleneck_analysis) > 0
      bottleneck_types = Enum.map(result.bottleneck_analysis, & &1.type)
      assert :queue_depth in bottleneck_types
      assert :utilization in bottleneck_types
    end

    test "metrics_summary contains expected keys" do
      result = ScalabilityAnalyzer.analyze(@healthy_snapshot)
      summary = result.metrics_summary
      assert Map.has_key?(summary, :queue_depth_current)
      assert Map.has_key?(summary, :utilization_pct)
      assert Map.has_key?(summary, :latency_p90)
      assert Map.has_key?(summary, :error_rate_pct)
    end

    test "nil snapshot uses empty defaults" do
      result = ScalabilityAnalyzer.analyze(nil)
      assert result.current_state == :healthy
    end

    test "warning state detected for elevated utilization" do
      snap = put_in(@healthy_snapshot, [:agent_utilization, :system, :utilization_pct], 75.0)
      result = ScalabilityAnalyzer.analyze(snap)
      assert result.current_state == :warning
      assert result.recommendation =~ "agent"
    end

    test "recommendation distinguishes agents vs machines" do
      # High utilization -> add agents
      agent_snap = put_in(@healthy_snapshot, [:agent_utilization, :system, :utilization_pct], 92.0)
      result = ScalabilityAnalyzer.analyze(agent_snap)
      assert result.recommendation =~ "agent" or result.recommendation =~ "machine"
    end
  end
end
```

### B. ProposalWriter test (test/agent_com/contemplation/proposal_writer_test.exs)

New file. async: true (uses temp dirs for isolation).

```elixir
defmodule AgentCom.Contemplation.ProposalWriterTest do
  use ExUnit.Case, async: true

  alias AgentCom.Contemplation.ProposalWriter
  alias AgentCom.XML.Schemas.Proposal

  setup do
    # Use System.tmp_dir with unique suffix for test isolation
    dir = Path.join([System.tmp_dir!(), "proposal_writer_test_#{System.unique_integer([:positive])}"])
    on_cleanup = fn -> File.rm_rf!(dir) end

    on_exit(on_cleanup)
    {:ok, dir: dir}
  end

  defp make_proposal(id, title) do
    {:ok, p} = Proposal.new(%{
      id: id,
      title: title,
      description: "Test description for #{title}",
      problem: "Test problem",
      solution: "Test solution",
      impact: "medium",
      effort: "small"
    })
    p
  end

  describe "write_proposals/2" do
    test "writes proposals as XML files", %{dir: dir} do
      proposals = [make_proposal("p1", "First"), make_proposal("p2", "Second")]
      assert {:ok, paths} = ProposalWriter.write_proposals(proposals, dir: dir)
      assert length(paths) == 2
      Enum.each(paths, fn path ->
        assert File.exists?(path)
        content = File.read!(path)
        assert content =~ "<proposal"
        assert content =~ "</proposal>"
      end)
    end

    test "enforces max 3 proposals per cycle", %{dir: dir} do
      proposals = for i <- 1..5, do: make_proposal("p#{i}", "Proposal #{i}")
      assert {:ok, paths} = ProposalWriter.write_proposals(proposals, dir: dir)
      assert length(paths) == 3
    end

    test "creates directory if it does not exist", %{dir: dir} do
      nested = Path.join(dir, "nested/deep")
      proposals = [make_proposal("p1", "One")]
      assert {:ok, [path]} = ProposalWriter.write_proposals(proposals, dir: nested)
      assert File.exists?(path)
    end

    test "empty list writes zero files", %{dir: dir} do
      assert {:ok, []} = ProposalWriter.write_proposals([], dir: dir)
    end
  end

  describe "max_per_cycle/0" do
    test "returns 3" do
      assert ProposalWriter.max_per_cycle() == 3
    end
  end
end
```

### C. Contemplation orchestrator test (test/agent_com/contemplation_test.exs)

New file. async: false (may touch GenServers via catch blocks).

```elixir
defmodule AgentCom.ContemplationTest do
  @moduledoc """
  Tests for the Contemplation orchestrator module.

  Uses skip_llm: true to avoid ClaudeClient dependency.
  async: false because it accesses GenServers (HubFSM, MetricsCollector) via catch blocks.
  """

  use ExUnit.Case, async: false

  alias AgentCom.Contemplation

  describe "run/1" do
    test "returns ok with report structure when skip_llm" do
      assert {:ok, report} = Contemplation.run(skip_llm: true)
      assert Map.has_key?(report, :proposals)
      assert Map.has_key?(report, :proposal_paths)
      assert Map.has_key?(report, :scalability)
      assert Map.has_key?(report, :generated_at)
      assert report.proposals == []
      assert report.proposal_paths == []
    end

    test "scalability analysis always runs even with skip_llm" do
      assert {:ok, report} = Contemplation.run(skip_llm: true)
      assert is_map(report.scalability)
      assert Map.has_key?(report.scalability, :current_state)
      assert Map.has_key?(report.scalability, :recommendation)
    end

    test "respects custom context" do
      context = %{
        tech_stack: "Test Stack",
        codebase_summary: "Test summary",
        fsm_history: "",
        out_of_scope: "everything"
      }

      # skip_llm so context is accepted but not used for LLM call
      assert {:ok, report} = Contemplation.run(context: context, skip_llm: true)
      assert report.proposals == []
    end

    test "generated_at is a recent millisecond timestamp" do
      assert {:ok, report} = Contemplation.run(skip_llm: true)
      now = System.system_time(:millisecond)
      # Should be within last 5 seconds
      assert report.generated_at > now - 5_000
      assert report.generated_at <= now
    end
  end
end
```

Note: Do NOT test the full LLM path (ClaudeClient.generate_proposals) in these tests -- that requires a running ClaudeClient GenServer and actual CLI. Test the skip_llm path to verify orchestration, and test individual pure modules (ScalabilityAnalyzer, ProposalWriter, Proposal schema) in their own test files.
  </action>
  <verify>Run `mix test test/agent_com/contemplation_test.exs test/agent_com/contemplation/proposal_writer_test.exs test/agent_com/contemplation/scalability_analyzer_test.exs --trace` -- all tests should pass. Then run full suite: `mix test` to verify no regressions.</verify>
  <done>All contemplation module tests pass. ScalabilityAnalyzer tested with fixture snapshots. ProposalWriter tested with temp directory isolation. Contemplation orchestrator tested with skip_llm mode. Predicates tested for all :contemplating transitions. Proposal schema tested for enriched field round-trip.</done>
</task>

</tasks>

<verification>
1. `mix test test/agent_com/hub_fsm/predicates_test.exs` -- all tests pass including new :contemplating tests
2. `mix test test/agent_com/xml/schemas/proposal_test.exs` -- enriched field and round-trip tests pass
3. `mix test test/agent_com/contemplation_test.exs` -- orchestrator tests pass
4. `mix test test/agent_com/contemplation/proposal_writer_test.exs` -- writer tests pass
5. `mix test test/agent_com/contemplation/scalability_analyzer_test.exs` -- analyzer tests pass
6. `mix test` -- full suite passes with no regressions
</verification>

<success_criteria>
- All new test files exist and pass
- Predicates test covers :contemplating state with 4+ test cases
- Proposal schema test verifies enriched fields and XML round-trip
- ScalabilityAnalyzer test uses fixture snapshots (no GenServer deps)
- ProposalWriter test uses temp dirs and verifies XML file output
- Contemplation test uses skip_llm mode for orchestration verification
- Full test suite passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/33-contemplation-and-scalability/33-03-SUMMARY.md`
</output>
