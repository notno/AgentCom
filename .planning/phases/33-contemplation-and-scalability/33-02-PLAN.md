---
phase: 33-contemplation-and-scalability
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/agent_com/xml/schemas/proposal.ex
  - lib/agent_com/claude_client/prompt.ex
  - lib/agent_com/claude_client/response.ex
  - lib/agent_com/contemplation.ex
autonomous: true

must_haves:
  truths:
    - "Proposals contain problem, solution, why_now, why_not, and dependencies fields"
    - "Prompt instructs LLM to produce enriched proposals with all required fields"
    - "Response parser extracts all enriched fields from LLM output"
    - "Contemplation reads PROJECT.md out-of-scope to exclude forbidden features"
    - "to_proposal_struct maps all enriched fields from LLM response to Proposal struct"
  artifacts:
    - path: "lib/agent_com/xml/schemas/proposal.ex"
      provides: "Enriched Proposal struct with problem, solution, why_now, why_not, dependencies"
      contains: "why_now"
    - path: "lib/agent_com/claude_client/prompt.ex"
      provides: "Enriched generate_proposals prompt with all fields"
      contains: "why-now"
    - path: "lib/agent_com/claude_client/response.ex"
      provides: "Enriched proposal parser extracting all new fields"
      contains: "why_now"
    - path: "lib/agent_com/contemplation.ex"
      provides: "Context enrichment with PROJECT.md out-of-scope reading"
      contains: "PROJECT.md"
  key_links:
    - from: "lib/agent_com/claude_client/prompt.ex"
      to: "lib/agent_com/claude_client/response.ex"
      via: "Prompt requests fields that response parser extracts"
      pattern: "why.now"
    - from: "lib/agent_com/contemplation.ex"
      to: "lib/agent_com/xml/schemas/proposal.ex"
      via: "to_proposal_struct maps LLM response to enriched Proposal struct"
      pattern: "Proposal\\.new"
---

<objective>
Enrich the Proposal schema with user-required fields (problem, solution, why_now, why_not, dependencies), update the LLM prompt and response parser to handle these fields, and enhance Contemplation context gathering to read PROJECT.md out-of-scope section.

Purpose: Proposals must be grounded in actual codebase analysis with "why now" and "why not" sections per user decisions. The enriched schema ensures proposals are actionable and scope-constrained.

Output: Complete proposal generation pipeline producing enriched XML proposals with all required fields.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@lib/agent_com/xml/schemas/proposal.ex
@lib/agent_com/claude_client/prompt.ex
@lib/agent_com/claude_client/response.ex
@lib/agent_com/contemplation.ex
@lib/agent_com/contemplation/proposal_writer.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enrich Proposal schema with new fields and update XML serialization</name>
  <files>lib/agent_com/xml/schemas/proposal.ex</files>
  <action>
Add the user-required fields to the Proposal struct and update all serialization:

1. **Add new fields to `defstruct`:**
   ```elixir
   defstruct [
     :id,
     :title,
     :problem,          # NEW: problem statement
     :solution,         # NEW: proposed solution
     :description,      # Kept: summary/overview
     :rationale,        # Kept: evidence-based motivation
     :why_now,          # NEW: why this should be done now
     :why_not,          # NEW: risks/reasons not to do this
     :impact,
     :effort,
     :repo,
     :proposed_at,
     :metadata,
     related_files: [],
     dependencies: []   # NEW: list of dependency strings
   ]
   ```

2. **Update the `@type t`** typespec to include all new fields:
   - `problem: String.t() | nil`
   - `solution: String.t() | nil`
   - `why_now: String.t() | nil`
   - `why_not: String.t() | nil`
   - `dependencies: [String.t()]`

3. **Update `from_simple_form/1`** to parse new fields from XML:
   ```elixir
   problem: Parser.find_child_text(children, "problem"),
   solution: Parser.find_child_text(children, "solution"),
   why_now: Parser.find_child_text(children, "why-now"),
   why_not: Parser.find_child_text(children, "why-not"),
   dependencies: Parser.find_child_list(children, "dependencies", "dependency"),
   ```
   Note: XML uses kebab-case (`why-now`, `why-not`), Elixir uses snake_case (`why_now`, `why_not`).

4. **Update `Saxy.Builder` implementation** to encode new fields:
   - Add `maybe_add_element` calls for `:problem`, `:solution`, `:why_now`, `:why_not` in the children list (between rationale and metadata)
   - Add `maybe_add_dependencies` helper similar to `maybe_add_files`:
     ```elixir
     defp maybe_add_dependencies(acc, []), do: acc
     defp maybe_add_dependencies(acc, deps) do
       items = Enum.map(deps, &element("dependency", [], &1))
       [element("dependencies", [], items) | acc]
     end
     ```
   - Wire it into the children pipeline: `|> maybe_add_dependencies(proposal.dependencies)`

5. **Update `@moduledoc`** XML example to show the enriched structure with all new elements.

6. **Validation in `new/1`** -- the existing `description` required check stays. `problem` and `solution` are optional (LLM may not always produce them). No new required field validation needed.
  </action>
  <verify>Run `mix compile --warnings-as-errors`. Create a test struct in iex: `AgentCom.XML.Schemas.Proposal.new(%{id: "test", title: "Test", description: "desc", problem: "prob", solution: "sol", why_now: "now", why_not: "risk", dependencies: ["dep1"]})` should return `{:ok, %Proposal{...}}` with all fields populated.</verify>
  <done>Proposal struct has problem, solution, why_now, why_not, dependencies fields. from_simple_form parses them from XML. Saxy.Builder encodes them. Round-trip is possible.</done>
</task>

<task type="auto">
  <name>Task 2: Enrich prompt, response parser, and contemplation context</name>
  <files>
    lib/agent_com/claude_client/prompt.ex
    lib/agent_com/claude_client/response.ex
    lib/agent_com/contemplation.ex
  </files>
  <action>
Update the prompt template, response parser, and contemplation context in three files:

### A. Prompt (lib/agent_com/claude_client/prompt.ex)

Update the `build(:generate_proposals, ...)` clause:

1. **Add new context fields** extraction at the top of the function:
   ```elixir
   scalability_summary = get_field(context, :scalability_summary, "")
   error_summary = get_field(context, :error_summary, "")
   ```

2. **Add new context XML sections** in the prompt body (after out-of-scope section):
   ```xml
   <scalability-summary>
   #{escape_xml(to_string(scalability_summary))}
   </scalability-summary>

   <error-summary>
   #{escape_xml(to_string(error_summary))}
   </error-summary>
   ```

3. **Update the response format instructions** to require all enriched fields:
   ```
   Each `<proposal>` must contain:
   - `<title>` -- Short descriptive name
   - `<problem>` -- What problem this addresses
   - `<solution>` -- What the proposed solution is
   - `<description>` -- Brief summary of the feature
   - `<rationale>` -- Evidence or patterns that motivate this proposal
   - `<why-now>` -- Why this should be done in the current phase
   - `<why-not>` -- Risks or reasons this might not be worth doing
   - `<impact>` -- One of: low, medium, high
   - `<effort>` -- One of: small, medium, large
   - `<dependencies>` -- List of `<dependency>` elements (things this depends on)
   - `<related-files>` -- List of `<file>` elements (actual codebase files)
   ```

4. **Update the example XML** in the prompt to show the enriched structure.

5. **Add instruction**: "Each proposal must be achievable in one milestone phase. Do NOT propose features that are listed in the out-of-scope section. Ground proposals in actual codebase files."

### B. Response (lib/agent_com/claude_client/response.ex)

Update `parse_proposal_element/1` to extract all new fields:

```elixir
defp parse_proposal_element(prop_xml) do
  # Extract dependencies list
  deps_str = extract_child_text(prop_xml, "dependencies") || ""
  dependencies =
    Regex.scan(~r/<dependency>\s*(.*?)\s*<\/dependency>/s, deps_str)
    |> Enum.map(fn [_, content] -> String.trim(content) end)
    |> Enum.reject(&(&1 == ""))

  # Extract related files list
  files_str = extract_child_text(prop_xml, "related-files") || ""
  related_files =
    Regex.scan(~r/<file>\s*(.*?)\s*<\/file>/s, files_str)
    |> Enum.map(fn [_, content] -> String.trim(content) end)
    |> Enum.reject(&(&1 == ""))

  %{
    title: extract_child_text(prop_xml, "title") || "",
    problem: extract_child_text(prop_xml, "problem") || "",
    solution: extract_child_text(prop_xml, "solution") || "",
    description: extract_child_text(prop_xml, "description") || "",
    rationale: extract_child_text(prop_xml, "rationale") || "",
    why_now: extract_child_text(prop_xml, "why-now") || "",
    why_not: extract_child_text(prop_xml, "why-not") || "",
    impact: extract_child_text(prop_xml, "impact") || "medium",
    effort: extract_child_text(prop_xml, "effort") || "medium",
    dependencies: dependencies,
    related_files: related_files
  }
end
```

Note: Use `extract_child_text` for the container element, then Regex.scan for the nested list items. This follows the lenient regex approach already used in this module.

### C. Contemplation (lib/agent_com/contemplation.ex)

1. **Update `default_context/0`** to read PROJECT.md out-of-scope section:
   ```elixir
   defp default_context do
     # ... existing fsm_history code stays ...

     out_of_scope = read_project_out_of_scope()

     # Add scalability summary from analyzer
     scalability = AgentCom.Contemplation.ScalabilityAnalyzer.analyze()
     scalability_summary = scalability.recommendation

     %{
       tech_stack: "Elixir/Phoenix/OTP",
       codebase_summary: "AgentCom autonomous hub with FSM-driven goal execution, self-improvement scanning, and multi-agent task scheduling.",
       fsm_history: fsm_history,
       out_of_scope: out_of_scope,
       scalability_summary: scalability_summary,
       error_summary: ""
     }
   end
   ```

2. **Add `read_project_out_of_scope/0`** private function:
   ```elixir
   defp read_project_out_of_scope do
     path = Path.join([File.cwd!(), ".planning", "PROJECT.md"])
     case File.read(path) do
       {:ok, content} ->
         # Extract "Out of Scope" section
         case Regex.run(~r/## Out of Scope\s*\n(.*?)(?=\n## |\z)/s, content) do
           [_, section] -> String.trim(section)
           nil -> ""
         end
       {:error, _} -> ""
     end
   end
   ```

3. **Update `to_proposal_struct/2`** to map all new fields from the LLM response map:
   ```elixir
   defp to_proposal_struct(map, idx) do
     now = DateTime.utc_now() |> DateTime.to_iso8601()

     Proposal.new(%{
       id: "prop-#{System.system_time(:millisecond)}-#{idx}",
       title: Map.get(map, :title, ""),
       problem: Map.get(map, :problem),
       solution: Map.get(map, :solution),
       description: Map.get(map, :description, ""),
       rationale: Map.get(map, :rationale),
       why_now: Map.get(map, :why_now),
       why_not: Map.get(map, :why_not),
       impact: Map.get(map, :impact, "medium"),
       effort: Map.get(map, :effort, "medium"),
       repo: "AgentCom",
       related_files: Map.get(map, :related_files, []),
       dependencies: Map.get(map, :dependencies, []),
       proposed_at: now
     })
   end
   ```
  </action>
  <verify>Run `mix compile --warnings-as-errors`. Verify prompt.ex `build(:generate_proposals, ...)` mentions "why-now", "why-not", "problem", "solution", "dependencies" in the response format section. Verify response.ex `parse_proposal_element` extracts all new fields. Verify contemplation.ex `default_context` calls `read_project_out_of_scope`.</verify>
  <done>Prompt requests all enriched proposal fields. Response parser extracts them. Contemplation context reads PROJECT.md out-of-scope and feeds scalability summary to the prompt. to_proposal_struct maps all enriched fields.</done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` passes
2. Proposal struct has `problem`, `solution`, `why_now`, `why_not`, `dependencies` fields
3. Proposal XML round-trip preserves new fields (encode -> decode)
4. Prompt template includes all enriched field instructions and out-of-scope context
5. Response parser extracts all enriched fields including nested lists
6. Contemplation reads PROJECT.md out-of-scope section
7. to_proposal_struct maps all LLM response fields to Proposal struct
</verification>

<success_criteria>
- Proposal schema has 5 new fields with XML serialization
- Prompt instructs LLM to produce enriched proposals with problem, solution, why-now, why-not, dependencies, and related-files
- Response parser extracts all enriched fields including nested list elements
- Contemplation context includes PROJECT.md out-of-scope exclusions and scalability summary
</success_criteria>

<output>
After completion, create `.planning/phases/33-contemplation-and-scalability/33-02-SUMMARY.md`
</output>
