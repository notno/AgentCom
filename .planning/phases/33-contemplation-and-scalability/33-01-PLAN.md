---
phase: 33-contemplation-and-scalability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/agent_com/hub_fsm.ex
  - lib/agent_com/hub_fsm/predicates.ex
autonomous: true

must_haves:
  truths:
    - "HubFSM supports 4 states: resting, executing, improving, contemplating"
    - "Improving transitions to contemplating when zero findings and contemplating budget available"
    - "Contemplating transitions to resting on cycle completion"
    - "Contemplating transitions to executing if goals submitted during contemplation"
    - "Contemplation cycle spawns via Task.start and sends completion message"
  artifacts:
    - path: "lib/agent_com/hub_fsm.ex"
      provides: "4-state FSM with contemplating state, transitions, and cycle spawn"
      contains: "contemplating"
    - path: "lib/agent_com/hub_fsm/predicates.ex"
      provides: "Contemplating predicates and improved improving->contemplating transition"
      contains: "contemplating"
  key_links:
    - from: "lib/agent_com/hub_fsm.ex"
      to: "lib/agent_com/contemplation.ex"
      via: "Task.start spawn in do_transition"
      pattern: "Contemplation\\.run"
    - from: "lib/agent_com/hub_fsm.ex"
      to: "lib/agent_com/hub_fsm/predicates.ex"
      via: "Predicates.evaluate/2 with :contemplating clauses"
      pattern: "evaluate.*contemplating"
---

<objective>
Expand HubFSM from 3-state to 4-state by adding the `:contemplating` state with proper transitions, predicates, and async cycle spawn.

Purpose: The contemplating state is the foundation for feature proposal generation and scalability analysis. Without it, the hub cannot enter contemplation mode after exhausting improvement opportunities.

Output: HubFSM with 4 working states and correct transition logic between improving->contemplating->resting.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@lib/agent_com/hub_fsm.ex
@lib/agent_com/hub_fsm/predicates.ex
@lib/agent_com/self_improvement.ex
@lib/agent_com/contemplation.ex
@lib/agent_com/cost_ledger.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand HubFSM to 4-state with contemplating transitions and cycle spawn</name>
  <files>lib/agent_com/hub_fsm.ex</files>
  <action>
Expand HubFSM from 3-state to 4-state FSM by adding `:contemplating` state:

1. **Update `@valid_transitions`** map:
   ```elixir
   @valid_transitions %{
     resting: [:executing, :improving],
     executing: [:resting],
     improving: [:resting, :executing, :contemplating],
     contemplating: [:resting, :executing]
   }
   ```
   Note: `:contemplating -> :executing` handles goals submitted during contemplation.

2. **Update `@moduledoc`** to reference 4 states instead of 3. Add `:contemplating` to the States table with meaning "Generating feature proposals and analyzing scalability".

3. **Update `gather_system_state/0`** to include `contemplating_budget_available`:
   ```elixir
   contemplating_budget_available =
     try do
       AgentCom.CostLedger.check_budget(:contemplating) == :ok
     catch
       :exit, _ -> false
     end
   ```
   Add `contemplating_budget_available: contemplating_budget_available` to the returned map.

4. **Modify `handle_info({:improvement_cycle_complete, result}, state)`** to implement the improving-to-contemplating transition logic:
   - Extract `findings` count from result (default 0 if not present): `findings_count = Map.get(result, :findings, 0)`
   - Gather fresh system state via `gather_system_state()`
   - Decision tree:
     - If `system_state.pending_goals > 0` -> transition to `:executing` with reason "goals submitted during improvement"
     - Else if `findings_count == 0` AND `system_state.contemplating_budget_available` -> transition to `:contemplating` with reason "no improvements found, contemplating"
     - Else -> transition to `:resting` with reason "improvement cycle complete"
   - Per user decision: "Hub enters Contemplating when Improving finds nothing to improve"

5. **Add `handle_info({:contemplation_cycle_complete, result}, state)`** handler:
   - Log the result: `Logger.info("contemplation_cycle_complete", result: inspect(result))`
   - Only process if `state.fsm_state == :contemplating` (ignore stale messages)
   - Gather fresh system state
   - If `system_state.pending_goals > 0` -> transition to `:executing` with reason "goals submitted during contemplation"
   - Else -> transition to `:resting` with reason "contemplation cycle complete"
   - Per user decision: "Generates max 3 proposals per cycle, then transitions to Resting" (resting is default; executing only if goals arrived)
   - Place this handler BEFORE the PubSub catch-all handlers.

6. **Add contemplation cycle spawn in `do_transition/3`** after the existing improving spawn block:
   ```elixir
   if new_state == :contemplating do
     pid = self()
     Task.start(fn ->
       result = AgentCom.Contemplation.run()
       send(pid, {:contemplation_cycle_complete, result})
     end)
   end
   ```
   This mirrors the existing improving pattern exactly.

7. **Update `do_transition/3` ClaudeClient notification** to include `:contemplating`:
   Change `if new_state in [:executing, :improving]` to `if new_state in [:executing, :improving, :contemplating]`.
   ClaudeClient already accepts `:contemplating` as a valid hub state.
  </action>
  <verify>Run `mix compile --warnings-as-errors` -- should compile without warnings. Grep for `:contemplating` in hub_fsm.ex and confirm it appears in @valid_transitions, gather_system_state, do_transition spawn, and both handle_info handlers.</verify>
  <done>HubFSM has 4 states. `:contemplating` appears in valid transitions map, system state gathering includes contemplating budget, do_transition spawns contemplation cycle, and both improvement_cycle_complete and contemplation_cycle_complete handlers use conditional transition logic.</done>
</task>

<task type="auto">
  <name>Task 2: Add contemplating predicates and modify improving transition</name>
  <files>lib/agent_com/hub_fsm/predicates.ex</files>
  <action>
Expand Predicates module to handle the `:contemplating` state:

1. **Update `@moduledoc`** to reference 4 states. Add `:contemplating` description: "generating feature proposals and scalability analysis". Update the `system_state` parameter docs to include `:contemplating_budget_available` key.

2. **Add `:contemplating` predicate clauses** after the existing `:improving` clauses:
   ```elixir
   # Contemplating -> executing: goals submitted (new work to do)
   def evaluate(:contemplating, %{pending_goals: pending}) when pending > 0 do
     {:transition, :executing, "goals submitted while contemplating"}
   end

   # Contemplating -> resting: budget exhausted
   def evaluate(:contemplating, %{budget_exhausted: true}) do
     {:transition, :resting, "budget exhausted while contemplating"}
   end

   # Contemplating: stay (cycle in progress)
   def evaluate(:contemplating, _system_state), do: :stay
   ```

   Note: The contemplating state is primarily driven by the `{:contemplation_cycle_complete, result}` message in HubFSM, not by tick predicates. The tick predicates here serve as safety nets for budget exhaustion and goal arrival during contemplation. The contemplation cycle itself handles the normal completion transition.

3. **The existing `:improving` predicates remain unchanged.** The improving-to-contemplating transition is handled in HubFSM's `handle_info({:improvement_cycle_complete, ...})` handler (Task 1), NOT in tick predicates. This is because the improvement cycle completion is an event (message), not a periodic state evaluation. The tick predicate for `:improving` correctly handles goals-arrived and budget-exhausted cases.

4. **Add a catch-all for unknown states** at the bottom (defensive):
   ```elixir
   # Unknown state: stay (defensive)
   def evaluate(_unknown, _system_state), do: :stay
   ```
  </action>
  <verify>Run `mix compile --warnings-as-errors`. Grep predicates.ex for "contemplating" -- should appear in 3+ clause heads plus moduledoc.</verify>
  <done>Predicates module handles `:contemplating` state with goals-submitted, budget-exhausted, and stay clauses. Unknown states default to `:stay`.</done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` passes
2. HubFSM `@valid_transitions` contains `:contemplating` key with `[:resting, :executing]` targets
3. HubFSM `@valid_transitions` `:improving` key includes `:contemplating` as a target
4. `gather_system_state/0` returns `:contemplating_budget_available` key
5. `handle_info({:improvement_cycle_complete, ...})` conditionally transitions to `:contemplating` when findings==0 and budget available
6. `handle_info({:contemplation_cycle_complete, ...})` exists and transitions to `:resting` or `:executing`
7. `do_transition/3` spawns `Contemplation.run()` via `Task.start` when entering `:contemplating`
8. Predicates has `evaluate(:contemplating, ...)` clauses
</verification>

<success_criteria>
- HubFSM compiles as a 4-state FSM with `:contemplating` fully wired
- Predicates handle all 4 states with correct transition logic
- Contemplation cycle spawn follows the exact same Task.start pattern as improvement cycle
- Improving-to-contemplating transition only happens when zero findings AND budget available
</success_criteria>

<output>
After completion, create `.planning/phases/33-contemplation-and-scalability/33-01-SUMMARY.md`
</output>
