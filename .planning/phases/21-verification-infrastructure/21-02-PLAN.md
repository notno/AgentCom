---
phase: 21-verification-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - sidecar/verification.js
  - sidecar/index.js
autonomous: true

must_haves:
  truths:
    - "Sidecar runs verification checks locally after task execution completes"
    - "Four check types (file_exists, test_passes, git_clean, command_succeeds) execute correctly on Windows and Unix"
    - "Global timeout kills long-running verification and produces a timeout report"
    - "Tasks with skip_verification or no verification_steps bypass checks cleanly"
    - "Verification report is sent with task_complete message to hub"
  artifacts:
    - path: "sidecar/verification.js"
      provides: "Verification runner with 4 check types, global timeout, report builder"
      exports: ["runVerification"]
    - path: "sidecar/index.js"
      provides: "Integration of verification into handleResult flow"
      contains: "runVerification"
  key_links:
    - from: "sidecar/index.js"
      to: "sidecar/verification.js"
      via: "require('./verification')"
      pattern: "require.*verification"
    - from: "sidecar/verification.js"
      to: "child_process.execSync"
      via: "Shell command execution for test_passes, git_clean, command_succeeds"
      pattern: "execSync|exec"
    - from: "sidecar/index.js handleResult"
      to: "hub.sendTaskComplete"
      via: "verification_report field added to task_complete message"
      pattern: "verification_report"
---

<objective>
Implement the sidecar-side verification runner that executes mechanical checks after task completion and sends a structured report to the hub.

Purpose: Verification checks must run on the sidecar because they need local filesystem access (file_exists, git_clean) and local test execution (test_passes). The sidecar is the only component with access to the task's working directory. This plan builds the runner that sits between task result parsing and hub notification.

Output: `sidecar/verification.js` module with check execution and report building, integrated into handleResult flow in `sidecar/index.js`.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-verification-infrastructure/21-RESEARCH.md
@sidecar/index.js (handleResult flow, sendTaskComplete, active task structure)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sidecar verification runner module</name>
  <files>sidecar/verification.js</files>
  <action>
Create `sidecar/verification.js` exporting a single async function `runVerification(task, config)` that:

**Parameters:**
- `task`: the active task object from _queue.active (has `verification_steps`, `skip_verification`, `verification_timeout_ms`)
- `config`: sidecar config object (has `repo_dir` for working directory context)

**Flow:**
1. If `task.skip_verification === true`, return report with status "skip", empty checks
2. If `!task.verification_steps || task.verification_steps.length === 0`, return report with status "auto_pass", empty checks
3. Otherwise, run all checks with a global timeout:
   - `timeout_ms = task.verification_timeout_ms || 120000` (default 120s)
   - Use `Promise.race([runAllChecks(), timeoutPromise(timeout_ms)])` pattern
   - If timeout fires, return report with status "timeout"

**Check type implementations using `child_process.execSync` (synchronous is fine -- checks run sequentially in submission order):**

- `file_exists`: `fs.existsSync(step.target)` -- pass if true, fail with "File not found: {path}" if false
- `test_passes`: If target is "auto", detect from repo_dir (mix.exs -> "mix test", package.json -> "npm test", Makefile -> "make test", else echo "No test runner detected"). If target is specific command string, use that. Execute via shell, capture stdout+stderr, pass if exit code 0.
- `git_clean`: Run `git status --porcelain` in step.target directory (or repo_dir or "."). Pass if exit code 0 AND output is empty string. Fail with the dirty file list as output.
- `command_succeeds`: Run step.target as a shell command. Capture stdout+stderr. Pass if exit code 0, fail otherwise. Always include output in result.

**Shell execution helper:**
```javascript
function runShellCommand(command, cwd) {
  try {
    const output = execSync(command, {
      cwd: cwd || process.cwd(),
      encoding: 'utf8',
      timeout: 0,  // No per-command timeout; global timeout handles it
      stdio: ['pipe', 'pipe', 'pipe']  // capture stdin/stdout/stderr
    });
    return { status: 'pass', output: output || '' };
  } catch (err) {
    // execSync throws on non-zero exit code
    const output = (err.stdout || '') + (err.stderr || '');
    return { status: 'fail', output };
  }
}
```

Note: Use `stderr: 'pipe'` and merge stdout+stderr in catch block. `execSync` throws an error when the command exits with non-zero, so the catch path handles failures.

**Per-check timing:** Capture `Date.now()` before and after each check. Include `duration_ms` in each check result.

**Report structure** (matches hub-side Report format):
```javascript
{
  task_id: task.task_id,
  run_number: 1,  // Always 1 for Phase 21; Phase 22 will increment
  status: 'pass' | 'fail' | 'error' | 'skip' | 'auto_pass' | 'timeout',
  started_at: timestamp_ms,
  duration_ms: total_ms,
  timeout_ms: configured_timeout,
  checks: [
    { type, target, description, status, output, duration_ms }
  ],
  summary: { total, passed, failed, errors, timed_out }
}
```

**Overall status derivation:** If any check is "error" -> "error". If any check is "fail" -> "fail". Otherwise "pass". (Run-all strategy: do NOT stop on first failure.)

**Logging:** Use the sidecar's existing `log()` function pattern (passed via config or imported). Log verification start/complete at info level, individual check results at debug level.

Export: `module.exports = { runVerification }`
  </action>
  <verify>
    Manually verify the module loads without syntax errors: `cd C:/Users/nrosq/src/AgentCom/sidecar && node -e "const v = require('./verification'); console.log(typeof v.runVerification);"` outputs "function"
  </verify>
  <done>sidecar/verification.js exports runVerification that executes 4 check types with global timeout and returns structured report</done>
</task>

<task type="auto">
  <name>Task 2: Integrate verification into sidecar handleResult flow</name>
  <files>sidecar/index.js</files>
  <action>
Wire verification into the existing `handleResult` function in sidecar/index.js:

1. **Import at top of file:** `const { runVerification } = require('./verification');`

2. **Modify handleResult:** After parsing the result JSON and confirming `result.status === 'success'`, but BEFORE the git workflow and sendTaskComplete, insert verification:

```javascript
// Current flow: parse result -> git push -> sendTaskComplete
// New flow: parse result -> run verification -> git push (only if passed) -> sendTaskComplete (always, with report)

if (result.status === 'success') {
  // Run verification checks before git push
  const verificationReport = await runVerification(_queue.active, _config);
  result.verification_report = verificationReport;

  log('info', 'verification_complete', {
    task_id: taskId,
    status: verificationReport.status,
    passed: verificationReport.summary?.passed || 0,
    failed: verificationReport.summary?.failed || 0
  });

  // Only do git workflow if verification passed or was skipped/auto-passed
  const skipGit = verificationReport.status === 'fail' || verificationReport.status === 'error';
  if (_config.repo_dir && !skipGit) {
    // existing git workflow unchanged
  }

  // Always send task_complete with verification_report
  // (hub decides task status based on report)
  hub.sendTaskComplete(taskId, result);
}
```

3. **Make handleResult async:** Change `function handleResult(taskId, filePath, hub)` to `async function handleResult(taskId, filePath, hub)`. The callers in the result watcher's `on('add')` handler don't await, so this is backward-compatible.

4. **Pass verification_steps from task_assign to active task:** Verify that `_queue.active` already carries `verification_steps` (from Phase 17-03 wiring: `sidecar/index.js` line ~545 stores `verification_steps: msg.verification_steps || []`). Also ensure `skip_verification` and `verification_timeout_ms` are stored if present. Add to the handleTaskAssign function:
   - `skip_verification: msg.skip_verification || false`
   - `verification_timeout_ms: msg.verification_timeout_ms || null`

5. **Update sendTaskComplete:** Modify `HubConnection.sendTaskComplete` to include `verification_report` as a top-level field in the WebSocket message (not nested inside `result`):
```javascript
sendTaskComplete(taskId, result) {
  const generation = this.taskGenerations.get(taskId) || 0;
  const verificationReport = result.verification_report;
  // Remove from result to keep it clean
  const cleanResult = { ...result };
  delete cleanResult.verification_report;

  const sent = this.send({
    type: 'task_complete',
    task_id: taskId,
    result: cleanResult,
    generation,
    verification_report: verificationReport || null
  });
  this.taskGenerations.delete(taskId);
  return sent;
}
```

This sends verification_report as a separate top-level field per the research recommendation, keeping it cleanly separated from the LLM's execution output.
  </action>
  <verify>
    `cd C:/Users/nrosq/src/AgentCom/sidecar && node -e "require('./index')" 2>&1` loads without syntax errors (may fail on missing config/connection -- that's OK, just verify no require/parse errors).
    Also: `node -e "const v = require('./verification'); console.log('OK');"` prints "OK"
  </verify>
  <done>Sidecar runs verification after task execution, sends report as top-level field in task_complete message, and skips git push on verification failure</done>
</task>

</tasks>

<verification>
- `sidecar/verification.js` loads without errors and exports `runVerification`
- `sidecar/index.js` loads without syntax errors
- handleResult calls runVerification before sendTaskComplete
- sendTaskComplete includes verification_report as top-level WS message field
- Tasks with skip_verification=true bypass checks
- Tasks with empty verification_steps auto-pass
</verification>

<success_criteria>
- Four check types (file_exists, test_passes, git_clean, command_succeeds) implemented in JS
- Global timeout via Promise.race prevents runaway checks
- Verification runs between task result parsing and hub notification
- Report structure matches hub-side format (task_id, run_number, status, checks, summary)
- Git push skipped when verification fails (broken code stays local)
</success_criteria>

<output>
After completion, create `.planning/phases/21-verification-infrastructure/21-02-SUMMARY.md`
</output>
