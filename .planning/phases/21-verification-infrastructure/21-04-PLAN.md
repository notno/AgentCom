---
phase: 21-verification-infrastructure
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/agent_com/verification/store.ex
  - lib/agent_com/task_queue.ex
  - test/agent_com/verification/store_test.exs
autonomous: true
gap_closure: true
must_haves:
  truths:
    - "Verification.Store is callable by registered name from TaskQueue without a pid"
    - "TaskQueue.complete_task persists verification_report to Store without crashing"
    - "Existing Store tests pass after name registration and save/2 signature change"
  artifacts:
    - path: "lib/agent_com/verification/store.ex"
      provides: "Name-registered GenServer with save/2 accepting (task_id, raw_report_map)"
      contains: "name: __MODULE__"
    - path: "lib/agent_com/task_queue.ex"
      provides: "Store.save call using module name"
      contains: "Store.save(task_id, verification_report)"
    - path: "test/agent_com/verification/store_test.exs"
      provides: "Tests updated for name-based API"
  key_links:
    - from: "lib/agent_com/task_queue.ex"
      to: "lib/agent_com/verification/store.ex"
      via: "AgentCom.Verification.Store.save(task_id, verification_report)"
      pattern: "Verification\\.Store\\.save\\(task_id"
---

<objective>
Fix broken Verification.Store wiring identified during phase verification (4/5 must-haves, 1 gap).

The Store GenServer starts in the supervisor but is not registered with a name, so TaskQueue cannot call it. Additionally, Store.save/2 expects (pid, report_struct) but TaskQueue calls it with (task_id, raw_map). This plan fixes both issues and updates tests.

Purpose: Unblock Phase 22 self-verification retry loop which needs Store for multi-run history.
Output: Working Store.save pipeline from TaskQueue through to DETS persistence.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-verification-infrastructure/21-VERIFICATION.md
@.planning/phases/21-verification-infrastructure/21-03-SUMMARY.md

@lib/agent_com/verification/store.ex
@lib/agent_com/verification/report.ex
@lib/agent_com/task_queue.ex
@test/agent_com/verification/store_test.exs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Store name registration and save/2 signature</name>
  <files>
    lib/agent_com/verification/store.ex
    test/agent_com/verification/store_test.exs
  </files>
  <action>
**Fix 1: Register Store with module name**

In `store.ex`, update `start_link/1` to register with the module name:

```elixir
def start_link(opts \\ []) do
  name = Keyword.get(opts, :name, __MODULE__)
  GenServer.start_link(__MODULE__, opts, name: name)
end
```

Using `Keyword.get(opts, :name, __MODULE__)` so:
- Production: supervisor starts with `{AgentCom.Verification.Store, []}` -> registers as `AgentCom.Verification.Store`
- Tests: can pass `name: nil` or omit name and use pid directly, OR tests can skip the name option and use the pid returned from start_link

**Fix 2: Add name-based save/2 overload**

Add a new `save/2` clause that accepts `(task_id, raw_report_map)` where task_id is a string and raw_report_map is a map. This is what TaskQueue calls. The function should:

1. Accept `(task_id, report_map)` when task_id is a binary string
2. Construct a proper report: set `task_id` on the map, default `run_number` to 1 if not present, ensure the map has the keys the Store handle_call expects (`:task_id` and `:run_number`)
3. Call `GenServer.call(__MODULE__, {:save, report})` using the registered name

Keep the existing `save(pid, report)` for backward compatibility with tests that use a pid.

The updated client API should be:

```elixir
# Called by TaskQueue with registered name (task_id is a binary string)
def save(task_id, report_map) when is_binary(task_id) and is_map(report_map) do
  report = report_map
    |> normalize_keys()
    |> Map.put(:task_id, task_id)
    |> Map.put_new(:run_number, 1)
  GenServer.call(__MODULE__, {:save, report})
end

# Called by tests with explicit pid
def save(pid, report) when is_pid(pid) do
  GenServer.call(pid, {:save, report})
end
```

Add a private `normalize_keys/1` helper that converts string keys to atom keys (since the sidecar sends JSON with string keys like "status", "checks", "summary", etc.):

```elixir
defp normalize_keys(map) when is_map(map) do
  Map.new(map, fn
    {k, v} when is_binary(k) -> {String.to_existing_atom(k), v}
    {k, v} -> {k, v}
  end)
rescue
  ArgumentError -> map  # If atom doesn't exist, keep string keys
end
```

Wait -- `String.to_existing_atom/1` will fail on arbitrary keys. Use `String.to_atom/1` instead since the set of keys is bounded (task_id, run_number, status, checks, summary, etc.) and this is only called on task completion, not a DoS vector. Or better yet, only convert the keys the Store actually needs:

```elixir
defp ensure_atom_keys(map) when is_map(map) do
  map
  |> ensure_key(:task_id, "task_id")
  |> ensure_key(:run_number, "run_number")
  |> ensure_key(:status, "status")
  |> ensure_key(:started_at, "started_at")
end

defp ensure_key(map, atom_key, string_key) do
  cond do
    Map.has_key?(map, atom_key) -> map
    Map.has_key?(map, string_key) -> Map.put(map, atom_key, Map.get(map, string_key))
    true -> map
  end
end
```

Actually, simplify. The handle_call({:save, report}) only accesses `report.task_id` and `report.run_number` for the DETS key. So we just need those two as atom keys. Keep it minimal:

```elixir
def save(task_id, report_map) when is_binary(task_id) and is_map(report_map) do
  report = report_map
    |> Map.put(:task_id, task_id)
    |> Map.put_new(:run_number, 1)
    |> Map.put_new("run_number", 1)
  # Ensure :run_number is set from string key if present
  run = Map.get(report, :run_number) || Map.get(report, "run_number", 1)
  report = Map.put(report, :run_number, run)
  GenServer.call(__MODULE__, {:save, report})
end
```

**Fix 3: Update tests for name registration**

Tests currently start Store with `Store.start_link(dets_path: ..., max_reports: 5)` and use pid. Since we added `name: __MODULE__` as default, multiple test processes would conflict. Fix by passing explicit name to avoid conflicts:

In `store_test.exs`, update the setup block to pass a unique registered name per test (or `nil` to skip registration):

```elixir
setup do
  # ... existing tmp_dir / dets_path setup ...
  test_name = :"store_test_#{:erlang.unique_integer([:positive])}"
  {:ok, pid} = Store.start_link(dets_path: dets_path, max_reports: 5, name: test_name)
  # ... existing on_exit ...
  %{pid: pid, dets_path: dets_path, tmp_dir: tmp_dir}
end
```

Tests continue using `pid` for GenServer calls -- the existing `save(pid, report)` clause still works. No test logic changes needed, just the start_link opts.
  </action>
  <verify>
Run the Store tests:
```
mix test test/agent_com/verification/store_test.exs --trace
```
All existing tests must pass. The Store GenServer must accept the `name` option and register accordingly.
  </verify>
  <done>
Store registers with `name: __MODULE__` by default. Tests pass with unique names to avoid conflicts. Both `save(pid, report)` and `save(task_id, raw_map)` function clauses exist.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify TaskQueue -> Store integration</name>
  <files>
    lib/agent_com/task_queue.ex
  </files>
  <action>
**Verify the existing call in task_queue.ex is correct.**

Line 433 in task_queue.ex already has:
```elixir
AgentCom.Verification.Store.save(task_id, verification_report)
```

This matches the new `save(task_id, report_map) when is_binary(task_id) and is_map(report_map)` clause we added in Task 1. The `task_id` here is a string (format "task-XXXX"), and `verification_report` is a raw map from the sidecar JSON.

**No changes needed to task_queue.ex** -- the call site is already correct. The gap was on the Store side (no name registration, wrong save/2 signature), both fixed in Task 1.

**Verify end-to-end by running full test suite:**

```
mix test
```

Confirm no regressions. The TaskQueue tests don't exercise the Store.save path (it requires a running Store GenServer with name registration), but compilation must succeed and existing tests must pass.

If any test fails related to Store name conflict (e.g., another test file starts Store with default name), add a guard or update that test to use explicit name.
  </action>
  <verify>
```
mix test
```
Full test suite passes. No compilation warnings related to Store. `AgentCom.Verification.Store.save/2` is callable with `(binary, map)` args when Store is running under its registered name.
  </verify>
  <done>
TaskQueue's existing `Store.save(task_id, verification_report)` call on line 433 works with the fixed Store. Full test suite passes with zero failures.
  </done>
</task>

</tasks>

<verification>
1. `mix test test/agent_com/verification/store_test.exs --trace` -- all Store tests pass
2. `mix test` -- full suite passes, no regressions
3. `grep -n "name:" lib/agent_com/verification/store.ex` confirms name registration in start_link
4. `grep -n "def save" lib/agent_com/verification/store.ex` shows both save/2 clauses (pid-based and task_id-based)
5. `grep -n "Store.save" lib/agent_com/task_queue.ex` confirms call matches new signature
</verification>

<success_criteria>
- Verification.Store starts with registered name `AgentCom.Verification.Store`
- Store.save/2 accepts (task_id_string, raw_map) from TaskQueue
- Store.save/2 still accepts (pid, report_struct) for tests
- All existing tests pass (Store tests + full suite)
- No scope creep: only Store wiring fixed, nothing else changed
</success_criteria>

<output>
After completion, create `.planning/phases/21-verification-infrastructure/21-04-SUMMARY.md`
</output>
