---
phase: 21-verification-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["21-01", "21-02"]
files_modified:
  - lib/agent_com/validation/schemas.ex
  - lib/agent_com/socket.ex
  - lib/agent_com/task_queue.ex
  - lib/agent_com/endpoint.ex
  - lib/agent_com/application.ex
  - lib/agent_com/dashboard.ex
  - lib/agent_com/telemetry.ex
autonomous: true

must_haves:
  truths:
    - "Verification report sent by sidecar arrives at hub and is stored on the task and in the Store"
    - "Task detail API response includes verification_report with per-check pass/fail"
    - "Dashboard shows green/red indicators per check with expandable output"
    - "Telemetry event fires on verification completion with pass/fail counts"
    - "Tasks with no verification report (old sidecars) continue working unchanged"
  artifacts:
    - path: "lib/agent_com/validation/schemas.ex"
      provides: "Updated task_complete schema with optional verification_report field"
      contains: "verification_report"
    - path: "lib/agent_com/socket.ex"
      provides: "Extraction of verification_report from task_complete and passing to TaskQueue"
      contains: "verification_report"
    - path: "lib/agent_com/task_queue.ex"
      provides: "verification_report stored on task map, persisted to Store"
      contains: "verification_report"
    - path: "lib/agent_com/endpoint.ex"
      provides: "format_task includes verification_report field"
      contains: "verification_report"
    - path: "lib/agent_com/application.ex"
      provides: "Verification.Store added to supervisor children"
      contains: "Verification.Store"
    - path: "lib/agent_com/dashboard.ex"
      provides: "Verification report rendering with colored indicators"
      contains: "verification"
    - path: "lib/agent_com/telemetry.ex"
      provides: "Verification telemetry event documentation"
      contains: "verification"
  key_links:
    - from: "lib/agent_com/socket.ex"
      to: "lib/agent_com/task_queue.ex"
      via: "verification_report passed in result_params to complete_task"
      pattern: "verification_report"
    - from: "lib/agent_com/task_queue.ex"
      to: "lib/agent_com/verification/store.ex"
      via: "Store.save called on task completion with verification_report"
      pattern: "Store\\.save"
    - from: "lib/agent_com/endpoint.ex"
      to: "task.verification_report"
      via: "format_task serializes verification_report"
      pattern: "verification_report"
---

<objective>
Wire verification reports through the hub pipeline and render them on the dashboard.

Purpose: Verification reports generated by the sidecar must flow through the hub's WebSocket handler, get stored on the task and in the Verification Store, appear in API responses, emit telemetry, and render on the dashboard with green/red check indicators. This plan completes the end-to-end verification pipeline.

Output: Full hub-side integration -- schema validation, socket extraction, task storage, API serialization, dashboard rendering, and telemetry events for verification reports.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-verification-infrastructure/21-RESEARCH.md
@.planning/phases/21-verification-infrastructure/21-01-SUMMARY.md
@.planning/phases/21-verification-infrastructure/21-02-SUMMARY.md
@lib/agent_com/validation/schemas.ex (task_complete schema)
@lib/agent_com/socket.ex (handle_msg task_complete handler)
@lib/agent_com/task_queue.ex (complete_task handler, format_task)
@lib/agent_com/endpoint.ex (format_task function)
@lib/agent_com/application.ex (supervisor children)
@lib/agent_com/dashboard.ex (dashboard rendering)
@lib/agent_com/telemetry.ex (telemetry events list)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire verification_report through schema, socket, TaskQueue, and supervisor</name>
  <files>
    lib/agent_com/validation/schemas.ex
    lib/agent_com/socket.ex
    lib/agent_com/task_queue.ex
    lib/agent_com/endpoint.ex
    lib/agent_com/application.ex
    lib/agent_com/telemetry.ex
  </files>
  <action>
**1. Validation schema** (`lib/agent_com/validation/schemas.ex`):
Add `"verification_report" => :map` to the `task_complete` schema's optional fields. This allows the sidecar to send it without breaking validation, and old sidecars that don't send it will still validate.

**2. Socket handler** (`lib/agent_com/socket.ex`):
In `handle_msg(%{"type" => "task_complete", ...})`, extract `verification_report` from the message and pass it through to `complete_task`:
```elixir
verification_report = msg["verification_report"]

case AgentCom.TaskQueue.complete_task(task_id, generation, %{
  result: result,
  tokens_used: tokens_used,
  verification_report: verification_report
}) do
```

**3. TaskQueue complete_task** (`lib/agent_com/task_queue.ex`):
In `handle_call({:complete_task, ...})`, extract verification_report from result_params and:
- Store on the task map as `verification_report` field
- Persist to Verification.Store if report is non-nil
- Emit telemetry event

```elixir
verification_report = Map.get(result_params, :verification_report, Map.get(result_params, "verification_report"))

updated = %{task |
  status: :completed,
  result: result,
  tokens_used: tokens_used,
  verification_report: verification_report,
  updated_at: now,
  history: cap_history([{:completed, now, %{tokens_used: tokens_used}} | task.history])
}

# Persist verification report separately for queryable history
if verification_report do
  AgentCom.Verification.Store.save(task_id, verification_report)

  # Emit verification telemetry
  summary = Map.get(verification_report, "summary", %{})
  :telemetry.execute(
    [:agent_com, :verification, :run],
    %{
      duration_ms: Map.get(verification_report, "duration_ms", 0),
      checks_passed: Map.get(summary, "passed", 0),
      checks_failed: Map.get(summary, "failed", 0)
    },
    %{task_id: task_id, status: Map.get(verification_report, "status", "unknown"), total_checks: Map.get(summary, "total", 0)}
  )
end

# Broadcast verification event for dashboard
if verification_report do
  Phoenix.PubSub.broadcast(AgentCom.PubSub, "verification", {
    :verification_complete,
    %{task_id: task_id, report: verification_report, timestamp: now}
  })
end
```

Also add `verification_report: nil` to the task map in `submit` (default nil for new tasks, backward compatible).

**4. Endpoint format_task** (`lib/agent_com/endpoint.ex`):
Add to the format_task map:
```elixir
"verification_report" => Map.get(task, :verification_report)
```
No transformation needed -- the report is already a JSON-compatible map from the sidecar.

**5. Application supervisor** (`lib/agent_com/application.ex`):
Add `AgentCom.Verification.Store` to the children list, before TaskQueue (so the Store is available when TaskQueue starts processing completions):
```elixir
AgentCom.Verification.Store,
```

**6. Telemetry docs** (`lib/agent_com/telemetry.ex`):
Add `[:agent_com, :verification, :run]` to the telemetry events documentation with measurements (duration_ms, checks_passed, checks_failed) and metadata (task_id, status, total_checks).
  </action>
  <verify>
    `cd C:/Users/nrosq/src/AgentCom && mix compile --no-start` succeeds with no errors.
    `mix test test/agent_com/validation_test.exs test/agent_com/task_queue_test.exs` passes (no regressions from adding optional field).
  </verify>
  <done>Verification reports flow from sidecar through WebSocket -> TaskQueue -> Store -> API -> telemetry, with backward compatibility for old sidecars</done>
</task>

<task type="auto">
  <name>Task 2: Dashboard verification report rendering</name>
  <files>
    lib/agent_com/dashboard.ex
  </files>
  <action>
Add verification report display to the dashboard's task detail section in `lib/agent_com/dashboard.ex`:

**1. Find where completed tasks render their details** (likely in the task card/row HTML). Add a verification section that shows:

- If verification_report is nil: nothing shown (old tasks, backward compatible)
- If status is "auto_pass" or "skip": small gray badge "No checks" or "Skipped"
- If status is "pass": green badge "Verified" with expandable check list
- If status is "fail" or "error": red badge "Failed" with expandable check list
- If status is "timeout": orange badge "Timeout" with note

**2. Check list rendering** (inside expandable section):
For each check in the report's `checks` list:
- Green circle (&#x2705; or CSS) + check type + target for passing checks
- Red circle (&#x274C; or CSS) + check type + target + expandable output for failing checks
- Show `duration_ms` next to each check in gray text

**3. Summary line:** "3/4 checks passed (12.5s)" format

**4. Integration with existing dashboard patterns:**
- Use the same HTML rendering style as existing dashboard elements
- Follow the existing pattern of building HTML strings in the render function
- Keep the verification section collapsible/expandable using `<details><summary>` HTML elements (no JavaScript needed)
- Color scheme: green (#22c55e) for pass, red (#ef4444) for fail, orange (#f59e0b) for timeout, gray (#6b7280) for skip/auto_pass

**5. Subscribe to verification PubSub** in DashboardState if needed to update the dashboard snapshot when verification completes. Check if the existing task_completed event already carries enough data (it should, since verification_report is now on the task map). If so, no additional PubSub subscription is needed -- the dashboard already re-renders on task state changes.
  </action>
  <verify>
    `cd C:/Users/nrosq/src/AgentCom && mix compile --no-start` succeeds.
    Verify the dashboard.ex compiles cleanly and the verification rendering HTML is present in the render function output.
  </verify>
  <done>Dashboard shows verification status badges and expandable check results inline with task details, using green/red/orange color coding</done>
</task>

</tasks>

<verification>
- `mix compile --no-start` succeeds with no warnings from modified files
- `mix test` passes with no regressions
- task_complete schema accepts optional verification_report map
- format_task includes verification_report in API response
- Verification.Store is in supervisor tree
- Dashboard renders verification indicators for completed tasks
- Telemetry event documented for [:agent_com, :verification, :run]
</verification>

<success_criteria>
- Verification report flows end-to-end: sidecar -> WS -> TaskQueue -> Store + task map -> API -> dashboard
- Old sidecars (no verification_report in message) continue working unchanged
- Dashboard shows green/red per-check indicators with expandable stdout/stderr
- Telemetry captures verification pass/fail counts per task
- Verification.Store starts in supervisor and persists reports to DETS
</success_criteria>

<output>
After completion, create `.planning/phases/21-verification-infrastructure/21-03-SUMMARY.md`
</output>
