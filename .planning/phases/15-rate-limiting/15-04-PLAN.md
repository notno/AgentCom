---
phase: 15-rate-limiting
plan: 04
type: execute
wave: 3
depends_on: ["15-02", "15-03"]
files_modified:
  - lib/agent_com/dashboard_state.ex
  - lib/agent_com/dashboard.ex
  - lib/agent_com/rate_limiter/sweeper.ex
  - lib/agent_com/application.ex
autonomous: true

must_haves:
  truths:
    - "Dashboard snapshot includes per-agent rate limit status (usage %, violation count) in agent cards"
    - "Dashboard snapshot includes a system-wide rate limits summary with total violations and top offenders"
    - "Push notifications fire when an agent exceeds a violation threshold (10 violations in 5 min), not on every single violation"
    - "Stale bucket entries for disconnected agents are cleaned up periodically"
    - "Pre-warning at 80% is visible in dashboard agent cards"
  artifacts:
    - path: "lib/agent_com/dashboard_state.ex"
      provides: "Rate limit data in snapshot: per-agent status and system-wide summary"
      contains: "rate_limit"
    - path: "lib/agent_com/dashboard.ex"
      provides: "Rate Limits summary card and per-agent rate limit indicators in HTML"
      contains: "Rate Limits"
    - path: "lib/agent_com/rate_limiter/sweeper.ex"
      provides: "Periodic cleanup of stale bucket entries"
      contains: "defmodule AgentCom.RateLimiter.Sweeper"
    - path: "lib/agent_com/application.ex"
      provides: "Sweeper added to supervision tree"
      contains: "RateLimiter.Sweeper"
  key_links:
    - from: "lib/agent_com/dashboard_state.ex"
      to: "lib/agent_com/rate_limiter.ex"
      via: "Reading rate limit status for snapshot"
      pattern: "RateLimiter\\."
    - from: "lib/agent_com/rate_limiter/sweeper.ex"
      to: ":rate_limit_buckets ETS"
      via: "Periodic sweep of stale entries"
      pattern: "ets.*rate_limit_buckets"
---

<objective>
Add dashboard visibility for rate limiting (per-agent cards + system summary) and periodic cleanup of stale bucket entries.

Purpose: Operators need to see rate limit status at a glance -- which agents are approaching limits, which have violations, and a system-wide overview. Stale buckets from disconnected agents need cleanup to prevent unbounded ETS growth. Push notifications alert operators to sustained abuse patterns.
Output: Enhanced dashboard with rate limit visibility, Sweeper GenServer for cleanup, push notifications for violation thresholds.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-rate-limiting/15-RESEARCH.md
@.planning/phases/15-rate-limiting/15-CONTEXT.md
@.planning/phases/15-rate-limiting/15-01-SUMMARY.md
@.planning/phases/15-rate-limiting/15-02-SUMMARY.md
@.planning/phases/15-rate-limiting/15-03-SUMMARY.md
@lib/agent_com/dashboard_state.ex
@lib/agent_com/dashboard.ex
@lib/agent_com/application.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add rate limit data to DashboardState snapshot and push notifications</name>
  <files>
    lib/agent_com/dashboard_state.ex
    lib/agent_com/rate_limiter.ex
  </files>
  <action>
**Add rate limit functions to `lib/agent_com/rate_limiter.ex`:**

Add a public function for dashboard consumption:

- `agent_rate_status(agent_id)` -- Returns a map with rate limit status for display:
  ```elixir
  %{
    ws: %{
      light: %{remaining: 118, capacity: 120, usage_pct: 1.7},
      normal: %{remaining: 55, capacity: 60, usage_pct: 8.3},
      heavy: %{remaining: 10, capacity: 10, usage_pct: 0.0}
    },
    http: %{...same structure...},
    violations: %{consecutive: 0, total_in_window: 0},
    rate_limited: false,
    exempt: false
  }
  ```
  Read from ETS `:rate_limit_buckets` for each `{agent_id, channel, tier}` combination. If no entry exists (agent hasn't used that tier yet), show full capacity. Compute usage_pct as `(1 - remaining/capacity) * 100`.

- `system_rate_summary()` -- Returns a system-wide summary:
  ```elixir
  %{
    total_violations_1h: 42,
    active_rate_limited: 1,
    exempt_count: 2,
    top_offenders: [
      %{agent_id: "buggy-agent", violations: 35, rate_limited: true},
      ...
    ]
  }
  ```
  Scan `:rate_limit_buckets` ETS for violation entries. Count agents with `rate_limited?: true`. List top 3 by violation count.

**Modify `lib/agent_com/dashboard_state.ex`:**

1. Subscribe to PubSub "rate_limits" topic in `init/1` (add alongside existing subscriptions).

2. Add rate limit tracking to GenServer state:
   ```elixir
   rate_limit_violations: [],  # ring buffer of recent violations
   rate_limit_violation_counts: %{}  # %{agent_id => count} for notification threshold
   ```

3. Handle rate limit violation events (PubSub broadcast from RateLimiter):
   ```elixir
   def handle_info({:rate_limit_violation, %{agent_id: agent_id} = event}, state) do
     # Add to ring buffer (capped at 100 like validation_failures)
     violations = Enum.take([event | state.rate_limit_violations], 100)

     # Track per-agent count for notification threshold
     counts = Map.update(state.rate_limit_violation_counts, agent_id, 1, &(&1 + 1))

     # Check notification threshold: 10 violations in tracking window
     new_state = %{state | rate_limit_violations: violations, rate_limit_violation_counts: counts}

     if rem(Map.get(counts, agent_id, 0), 10) == 0 do
       # Send push notification every 10th violation per agent
       AgentCom.DashboardNotifier.notify(%{
         title: "Rate Limit Alert",
         body: "Agent #{agent_id} has #{counts[agent_id]} rate limit violations",
         tag: "rate-limit-#{agent_id}"
       })
     end

     {:noreply, new_state}
   end
   ```

4. In the `snapshot/0` handler, add rate limit data to the snapshot map:
   ```elixir
   # In the snapshot computation, add:
   rate_limits: %{
     summary: AgentCom.RateLimiter.system_rate_summary(),
     per_agent: Enum.map(agents, fn a ->
       {a.agent_id, AgentCom.RateLimiter.agent_rate_status(a.agent_id)}
     end) |> Enum.into(%{})
   }
   ```

5. Add a periodic reset for violation counts (every 5 minutes) to prevent unbounded growth:
   ```elixir
   # In init, add:
   Process.send_after(self(), :reset_rate_limit_counts, 300_000)

   # Handler:
   def handle_info(:reset_rate_limit_counts, state) do
     Process.send_after(self(), :reset_rate_limit_counts, 300_000)
     {:noreply, %{state | rate_limit_violation_counts: %{}}}
   end
   ```

**Add PubSub broadcast to `RateLimiter.record_violation/1`:**

In the `record_violation/1` function, after updating the ETS violation entry, broadcast to PubSub:
```elixir
Phoenix.PubSub.broadcast(AgentCom.PubSub, "rate_limits", {:rate_limit_violation, %{
  agent_id: agent_id,
  consecutive: consecutive_count,
  retry_after_ms: retry_ms,
  timestamp: System.system_time(:millisecond)
}})
```

Commit: `feat(15-04): add rate limit data to DashboardState snapshot with push notifications`
  </action>
  <verify>`mix compile --warnings-as-errors` succeeds. `mix test --exclude smoke` passes.</verify>
  <done>DashboardState snapshot includes per-agent rate limit status and system-wide summary. Push notifications fire every 10th violation per agent. Violation events broadcast via PubSub for dashboard real-time updates.</done>
</task>

<task type="auto">
  <name>Task 2: Create Sweeper GenServer and add rate limit card to Dashboard HTML</name>
  <files>
    lib/agent_com/rate_limiter/sweeper.ex
    lib/agent_com/application.ex
    lib/agent_com/dashboard.ex
  </files>
  <action>
**Create `lib/agent_com/rate_limiter/sweeper.ex`:**

A simple GenServer that periodically cleans up stale bucket entries from disconnected agents. Follow the Reaper pattern.

```elixir
defmodule AgentCom.RateLimiter.Sweeper do
  @moduledoc """
  Periodic cleanup of stale rate limit bucket entries.

  Removes ETS entries for agents that are no longer connected.
  Runs every 5 minutes. Follows the Reaper pattern.
  """
  use GenServer
  require Logger

  @sweep_interval_ms 300_000  # 5 minutes

  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  @impl true
  def init(_opts) do
    Logger.metadata(module: __MODULE__)
    schedule_sweep()
    Logger.info("started", sweep_interval_ms: @sweep_interval_ms)
    {:ok, %{sweeps: 0, last_swept: 0}}
  end

  @impl true
  def handle_info(:sweep, state) do
    swept = sweep_stale_buckets()
    schedule_sweep()
    new_state = %{state | sweeps: state.sweeps + 1, last_swept: swept}
    if swept > 0 do
      Logger.info("sweep_complete", swept: swept, total_sweeps: new_state.sweeps)
    end
    {:noreply, new_state}
  end

  defp schedule_sweep do
    Process.send_after(self(), :sweep, @sweep_interval_ms)
  end

  defp sweep_stale_buckets do
    # Get currently connected agent_ids
    connected = AgentCom.Presence.list()
               |> Enum.map(fn a -> a.agent_id end)
               |> MapSet.new()

    # Scan bucket table for agents not in connected set
    # ETS entries: {{agent_id, channel, tier}, tokens, last_refill, capacity, refill_rate}
    :ets.foldl(
      fn
        {{agent_id, _channel, _tier} = key, _, _, _, _}, acc when is_binary(agent_id) ->
          if not MapSet.member?(connected, agent_id) do
            :ets.delete(:rate_limit_buckets, key)
            acc + 1
          else
            acc
          end

        # Violation entries: {{agent_id, :violations}, ...}
        {{agent_id, :violations} = key, _, _, _}, acc when is_binary(agent_id) ->
          if not MapSet.member?(connected, agent_id) do
            :ets.delete(:rate_limit_buckets, key)
            acc + 1
          else
            acc
          end

        _, acc -> acc
      end,
      0,
      :rate_limit_buckets
    )
  end
end
```

**Modify `lib/agent_com/application.ex`:**

Add `AgentCom.RateLimiter.Sweeper` to the children list in the supervision tree. Place it after `AgentCom.Alerter` and before `AgentCom.DashboardState`:

```elixir
{AgentCom.Alerter, []},
{AgentCom.RateLimiter.Sweeper, []},   # NEW
{AgentCom.DashboardState, []},
```

**Modify `lib/agent_com/dashboard.ex`:**

Add a "Rate Limits" card to the dashboard HTML. Find the existing card layout and add a new card alongside the queue stats and agent cards.

The Rate Limits card should display:
- Total violations in the last tracking window
- Number of currently rate-limited agents
- Number of exempt agents
- Top offenders list (if any)

For per-agent cards (existing agent list), add a rate limit status indicator:
- Green dot or bar when usage < 50%
- Yellow when 50-80%
- Red when > 80%
- Show violation count if > 0

The exact HTML/CSS follows the existing dashboard card patterns. Use the `rate_limits` data from the DashboardState snapshot. The dashboard HTML uses inline styles and vanilla JS with WebSocket updates -- follow that existing pattern.

Look at how the existing dashboard renders cards (likely in a `render/0` function that returns an HTML string) and add:

1. A "Rate Limits" section in the summary area:
```html
<div class="card" id="rate-limits-card">
  <h3>Rate Limits</h3>
  <div class="stat"><span class="label">Violations (window):</span> <span id="rl-violations">0</span></div>
  <div class="stat"><span class="label">Rate Limited:</span> <span id="rl-limited">0</span></div>
  <div class="stat"><span class="label">Exempt:</span> <span id="rl-exempt">0</span></div>
  <div id="rl-top-offenders"></div>
</div>
```

2. In the JS WebSocket update handler (where DashboardSocket pushes updates), add parsing for rate_limits data and update the card's inner text.

3. Per-agent rate limit indicators: In the agent list rendering, add a small badge showing the highest usage percentage tier with color coding.

Keep the dashboard changes minimal -- focus on data display, not visual polish. Follow whatever card/grid pattern already exists.

Commit: `feat(15-04): add Sweeper GenServer and Rate Limits dashboard card`
  </action>
  <verify>`mix compile --warnings-as-errors` succeeds. `mix test --exclude smoke` passes. The Sweeper starts in the supervision tree.</verify>
  <done>Sweeper GenServer runs every 5 minutes cleaning stale bucket entries. Dashboard HTML includes Rate Limits summary card and per-agent rate limit indicators. Rate limit data flows from ETS through DashboardState snapshot to dashboard WebSocket.</done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` -- no warnings
2. `mix test --exclude smoke` -- all tests pass
3. Dashboard snapshot includes `rate_limits` key with summary and per-agent data
4. Sweeper starts in supervision tree and runs periodic cleanup
5. Push notifications fire on violation threshold
</verification>

<success_criteria>
- Dashboard shows per-agent rate limit usage and violations
- Dashboard shows system-wide rate limit summary card
- Push notifications fire every 10th violation per agent (not every violation)
- Stale bucket entries for disconnected agents are cleaned up every 5 minutes
- All data flows through DashboardState snapshot for WebSocket real-time updates
</success_criteria>

<output>
After completion, create `.planning/phases/15-rate-limiting/15-04-SUMMARY.md`
</output>
