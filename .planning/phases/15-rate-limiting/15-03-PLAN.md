---
phase: 15-rate-limiting
plan: 03
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - lib/agent_com/endpoint.ex
  - lib/agent_com/rate_limiter.ex
  - lib/agent_com/config.ex
autonomous: true

must_haves:
  truths:
    - "Admin can GET current default rate limits and all per-agent overrides"
    - "Admin can PUT per-agent rate limit overrides that take effect immediately on the agent's current connection"
    - "Admin can DELETE per-agent overrides to revert agent to defaults"
    - "Admin can GET the current whitelist of exempt agent_ids"
    - "Admin can PUT/POST/DELETE whitelist entries; dashboard is always exempt"
    - "Overrides and whitelist persist across restarts via Config DETS"
    - "On startup, overrides and whitelist are loaded from DETS into ETS cache"
  artifacts:
    - path: "lib/agent_com/endpoint.ex"
      provides: "Admin API endpoints for rate limit overrides and whitelist CRUD"
      contains: "rate-limits"
    - path: "lib/agent_com/rate_limiter.ex"
      provides: "Override/whitelist management functions with DETS+ETS dual write"
      contains: "update_whitelist"
    - path: "lib/agent_com/config.ex"
      provides: "DETS storage for rate_limit_overrides and rate_limit_whitelist keys"
      contains: "rate_limit"
  key_links:
    - from: "lib/agent_com/endpoint.ex"
      to: "lib/agent_com/rate_limiter.ex"
      via: "Admin endpoints call RateLimiter override/whitelist functions"
      pattern: "RateLimiter\\.(set_override|remove_override|update_whitelist|get_overrides)"
    - from: "lib/agent_com/rate_limiter.ex"
      to: "lib/agent_com/config.ex"
      via: "DETS persistence for overrides and whitelist"
      pattern: "Config\\.(put|get)"
---

<objective>
Add admin API endpoints for managing per-agent rate limit overrides and agent whitelist, with DETS persistence and ETS cache for runtime performance.

Purpose: Admins need to set custom limits for specific agents, exempt certain agents (dashboard is always exempt), and have changes take effect immediately on current connections. Per user decision, this follows the same admin endpoint pattern as PUT /api/admin/log-level.
Output: Admin API endpoints for overrides and whitelist, plus persistence layer in Config DETS with ETS cache.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-rate-limiting/15-RESEARCH.md
@.planning/phases/15-rate-limiting/15-CONTEXT.md
@.planning/phases/15-rate-limiting/15-01-SUMMARY.md
@lib/agent_com/endpoint.ex
@lib/agent_com/rate_limiter.ex
@lib/agent_com/config.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add override and whitelist management to RateLimiter with DETS persistence</name>
  <files>
    lib/agent_com/rate_limiter.ex
  </files>
  <action>
Add public functions to `AgentCom.RateLimiter` for managing overrides and whitelist. Each function must write to BOTH Config DETS (persistence) AND `:rate_limit_overrides` ETS (runtime cache).

**Override management:**

- `set_override(agent_id, overrides_map)` -- Set per-agent rate limit overrides.
  - `overrides_map` is a map like `%{light: %{capacity: 200_000, refill_rate: ...}, normal: %{...}, heavy: %{...}}`
  - For each tier in the map: write `{{agent_id, tier}, capacity, refill_rate}` to `:rate_limit_overrides` ETS
  - Save the full overrides to Config DETS under key `:rate_limit_overrides` (a map of `%{agent_id => overrides_map}`)
  - Call `delete_agent_buckets(agent_id)` to reset current buckets so new limits take effect immediately
  - Returns `:ok`

- `remove_override(agent_id)` -- Remove per-agent override, revert to defaults.
  - Delete all ETS entries matching `{agent_id, :_}` from `:rate_limit_overrides`
  - Remove agent_id from the DETS overrides map
  - Call `delete_agent_buckets(agent_id)` to reset buckets
  - Returns `:ok`

- `get_overrides()` -- Return all current overrides as a map. Read from ETS for speed, or from DETS if needed.
  - Returns `%{agent_id => %{light: %{capacity: ..., refill_rate: ...}, ...}}`

- `get_defaults()` -- Return the default rate limits for display.
  - Returns `%{light: %{capacity: 120, refill_rate_per_min: 120}, normal: %{capacity: 60, ...}, heavy: %{capacity: 10, ...}}`
  - Convert internal units (capacity / 1000) to human-readable tokens

**Whitelist management:**

- `get_whitelist()` -- Return current whitelist as list of agent_id strings. Read from ETS `{:whitelist, list}`.

- `update_whitelist(agent_ids)` -- Replace entire whitelist.
  - Write `{:whitelist, agent_ids}` to `:rate_limit_overrides` ETS
  - Save to Config DETS under key `:rate_limit_whitelist`
  - Returns `:ok`

- `add_to_whitelist(agent_id)` -- Add single agent to whitelist.
  - Read current list, add agent_id if not present, write back to both ETS and DETS
  - Returns `:ok`

- `remove_from_whitelist(agent_id)` -- Remove single agent from whitelist.
  - Read current list, remove agent_id, write back to both ETS and DETS
  - Returns `:ok`

**Startup initialization:**

Add a `load_from_config()` function that loads overrides and whitelist from Config DETS into ETS. This should be called... but since RateLimiter is NOT a GenServer, it cannot have an `init/1`. Instead:
- Add `load_persisted_config/0` as a public function
- Call it from `Application.start/2` right after the ETS table creation lines:
  ```elixir
  :ets.new(:rate_limit_buckets, [:named_table, :public, :set])
  :ets.new(:rate_limit_overrides, [:named_table, :public, :set])
  AgentCom.RateLimiter.load_persisted_config()
  ```
- The function reads `:rate_limit_overrides` and `:rate_limit_whitelist` from `AgentCom.Config.get/1`
- BUT: Config GenServer may not be started yet at this point in Application.start (it's listed later in children). So instead, call `load_persisted_config/0` lazily:
  - Option A: Check if Config is alive with `Process.whereis(AgentCom.Config)` -- if nil, skip and load later.
  - Option B (better): Don't call from Application.start. Instead, add a one-shot `Process.send_after(self(), :load_rate_limits, 1000)` somewhere... but there's no GenServer.
  - Option C (simplest): Have the `get_limits/3` function lazily load from DETS on first miss. The first time `check/3` runs and there's no override in ETS, it calls Config.get. Cache the result in ETS. Whitelist loads similarly in `exempt?/1`.
  - **Go with Option C** -- lazy loading with ETS cache. First call to `exempt?/1` or `get_limits/3` when ETS is empty triggers a Config.get and populates ETS. Add a module attribute `@config_loaded_key :_config_loaded` and check for it in ETS. If not present, call `load_persisted_config/0` which reads from Config and populates ETS, then writes `{:_config_loaded, true}` to mark as done.

  Actually, even simpler: the `exempt?/1` function already checks ETS for `{:whitelist, list}`. If the entry doesn't exist, it returns false (non-exempt). On first admin API call to set a whitelist, it gets populated. On restart, the whitelist is gone from ETS until loaded. **This is a problem -- a whitelisted agent would be rate limited after restart until an admin re-sets the whitelist.**

  **Best approach:** Add a function `ensure_config_loaded/0` that's called at the top of `check/3`. It uses a module-level ETS key `{:_loaded, true}` to avoid re-loading on every call. If not loaded, read from Config DETS and populate ETS. This is called on every check but the ETS lookup for the loaded flag is O(1) and essentially free.

  ```elixir
  defp ensure_config_loaded do
    case :ets.lookup(@override_table, :_loaded) do
      [{:_loaded, true}] -> :ok
      [] -> load_persisted_config()
    end
  end

  def load_persisted_config do
    # Load whitelist
    case AgentCom.Config.get(:rate_limit_whitelist) do
      nil -> :ok
      list when is_list(list) -> :ets.insert(@override_table, {:whitelist, list})
    end

    # Load per-agent overrides
    case AgentCom.Config.get(:rate_limit_overrides) do
      nil -> :ok
      overrides when is_map(overrides) ->
        Enum.each(overrides, fn {agent_id, tiers} ->
          Enum.each(tiers, fn {tier, %{capacity: cap, refill_rate: rate}} ->
            tier_atom = if is_binary(tier), do: String.to_existing_atom(tier), else: tier
            :ets.insert(@override_table, {{agent_id, tier_atom}, cap, rate})
          end)
        end)
    end

    :ets.insert(@override_table, {:_loaded, true})
    :ok
  end
  ```

  Call `ensure_config_loaded()` at the top of `check/3` (before exempt? check).

Commit: `feat(15-03): add override/whitelist management with DETS persistence to RateLimiter`
  </action>
  <verify>`mix compile --warnings-as-errors` succeeds.</verify>
  <done>RateLimiter has set_override, remove_override, get_overrides, get_defaults, get_whitelist, update_whitelist, add_to_whitelist, remove_from_whitelist functions. Overrides persist in Config DETS and are lazily loaded into ETS on first check. Setting an override resets the agent's buckets for immediate effect.</done>
</task>

<task type="auto">
  <name>Task 2: Add admin API endpoints for rate limit overrides and whitelist</name>
  <files>
    lib/agent_com/endpoint.ex
  </files>
  <action>
Add the following admin API endpoints to `lib/agent_com/endpoint.ex`. All admin endpoints require auth via RequireAuth plug (same pattern as PUT /api/admin/log-level). Place them near the existing admin endpoints section.

**Rate limit overview:**

```elixir
get "/api/admin/rate-limits" do
  conn = AgentCom.Plugs.RequireAuth.call(conn, [])
  if conn.halted do
    conn
  else
    defaults = AgentCom.RateLimiter.get_defaults()
    overrides = AgentCom.RateLimiter.get_overrides()
    whitelist = AgentCom.RateLimiter.get_whitelist()
    send_json(conn, 200, %{
      "defaults" => defaults,
      "overrides" => overrides,
      "whitelist" => whitelist
    })
  end
end
```

**Per-agent override management:**

```elixir
put "/api/admin/rate-limits/:agent_id" do
  conn = AgentCom.Plugs.RequireAuth.call(conn, [])
  if conn.halted do
    conn
  else
    # Body should contain tier overrides, e.g.:
    # {"light": {"capacity": 200, "refill_rate_per_min": 200}, "normal": {...}}
    params = conn.body_params
    overrides = parse_override_params(params)
    case overrides do
      {:ok, parsed} ->
        AgentCom.RateLimiter.set_override(agent_id, parsed)
        send_json(conn, 200, %{"status" => "updated", "agent_id" => agent_id, "overrides" => params})
      {:error, reason} ->
        send_json(conn, 422, %{"error" => "invalid_overrides", "detail" => reason})
    end
  end
end

delete "/api/admin/rate-limits/:agent_id" do
  conn = AgentCom.Plugs.RequireAuth.call(conn, [])
  if conn.halted do
    conn
  else
    AgentCom.RateLimiter.remove_override(agent_id)
    send_json(conn, 200, %{"status" => "removed", "agent_id" => agent_id})
  end
end
```

**Whitelist management:**

```elixir
get "/api/admin/rate-limits/whitelist" do
  conn = AgentCom.Plugs.RequireAuth.call(conn, [])
  if conn.halted do
    conn
  else
    whitelist = AgentCom.RateLimiter.get_whitelist()
    send_json(conn, 200, %{"whitelist" => whitelist})
  end
end

put "/api/admin/rate-limits/whitelist" do
  conn = AgentCom.Plugs.RequireAuth.call(conn, [])
  if conn.halted do
    conn
  else
    agent_ids = conn.body_params["agent_ids"] || []
    if is_list(agent_ids) and Enum.all?(agent_ids, &is_binary/1) do
      AgentCom.RateLimiter.update_whitelist(agent_ids)
      send_json(conn, 200, %{"status" => "updated", "whitelist" => agent_ids})
    else
      send_json(conn, 422, %{"error" => "invalid_whitelist", "detail" => "agent_ids must be a list of strings"})
    end
  end
end

post "/api/admin/rate-limits/whitelist" do
  conn = AgentCom.Plugs.RequireAuth.call(conn, [])
  if conn.halted do
    conn
  else
    agent_id_to_add = conn.body_params["agent_id"]
    if is_binary(agent_id_to_add) and agent_id_to_add != "" do
      AgentCom.RateLimiter.add_to_whitelist(agent_id_to_add)
      send_json(conn, 200, %{"status" => "added", "agent_id" => agent_id_to_add})
    else
      send_json(conn, 422, %{"error" => "invalid_agent_id", "detail" => "agent_id must be a non-empty string"})
    end
  end
end

delete "/api/admin/rate-limits/whitelist/:agent_id" do
  conn = AgentCom.Plugs.RequireAuth.call(conn, [])
  if conn.halted do
    conn
  else
    AgentCom.RateLimiter.remove_from_whitelist(agent_id)
    send_json(conn, 200, %{"status" => "removed", "agent_id" => agent_id})
  end
end
```

**IMPORTANT route ordering:** The whitelist routes (`/api/admin/rate-limits/whitelist`) must be defined BEFORE the parameterized route (`/api/admin/rate-limits/:agent_id`), otherwise "whitelist" would be captured as an agent_id parameter. This is the same pattern as `/api/tasks/dead-letter` being before `/api/tasks/:task_id`.

**Add helper function** `parse_override_params/1` as a private function:
```elixir
defp parse_override_params(params) do
  tiers = [:light, :normal, :heavy]
  parsed = Enum.reduce_while(tiers, %{}, fn tier, acc ->
    tier_str = to_string(tier)
    case Map.get(params, tier_str) do
      nil -> {:cont, acc}
      %{"capacity" => cap, "refill_rate_per_min" => rate} when is_number(cap) and is_number(rate) ->
        # Convert human-readable to internal units: capacity * 1000, rate * 1000 / 60_000
        internal_cap = trunc(cap * 1000)
        internal_rate = rate * 1000 / 60_000
        {:cont, Map.put(acc, tier, %{capacity: internal_cap, refill_rate: internal_rate})}
      _ ->
        {:halt, {:error, "each tier must have numeric 'capacity' and 'refill_rate_per_min'"}}
    end
  end)

  case parsed do
    {:error, _} = err -> err
    map when map == %{} -> {:error, "at least one tier (light, normal, heavy) must be specified"}
    map -> {:ok, map}
  end
end
```

**Update the @moduledoc** to include the new rate limit admin endpoints.

Commit: `feat(15-03): add admin API endpoints for rate limit overrides and whitelist`
  </action>
  <verify>`mix compile --warnings-as-errors` succeeds. `mix test --exclude smoke` passes.</verify>
  <done>Admin API endpoints exist for GET/PUT/DELETE rate limit overrides per agent, and GET/PUT/POST/DELETE whitelist management. Override changes take effect immediately by resetting agent buckets. Whitelist changes are persisted to Config DETS.</done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` -- no warnings
2. `mix test --exclude smoke` -- all tests pass
3. Rate limit admin endpoints are accessible and follow existing auth pattern
4. Overrides persist across restart via Config DETS
5. Setting an override resets agent's existing buckets
</verification>

<success_criteria>
- Per-agent overrides can be set/removed via authenticated admin API
- Whitelist can be managed via authenticated admin API
- Changes take effect immediately (bucket reset on override change)
- Overrides and whitelist persist across restarts via Config DETS
- Lazy loading populates ETS cache on first rate limit check
- All endpoints follow existing admin auth pattern (RequireAuth)
</success_criteria>

<output>
After completion, create `.planning/phases/15-rate-limiting/15-03-SUMMARY.md`
</output>
