---
phase: 19-model-aware-scheduler
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/agent_com/task_router.ex
  - lib/agent_com/task_router/tier_resolver.ex
  - lib/agent_com/task_router/load_scorer.ex
  - test/agent_com/task_router_test.exs
autonomous: true

must_haves:
  truths:
    - "A trivial task routes to :sidecar target type"
    - "A standard task routes to the highest-scored healthy Ollama endpoint"
    - "A complex task routes to :claude target type"
    - "An unknown tier defaults to :standard routing"
    - "When multiple Ollama endpoints are healthy, the less-loaded one scores higher"
    - "A warm model on an endpoint gets a 15% score bonus"
    - "Repo affinity gives a 5% bonus when load is similar"
    - "Routing decision includes all required fields for transparency"
  artifacts:
    - path: "lib/agent_com/task_router.ex"
      provides: "Top-level route/3 function returning routing decision or fallback signal"
      exports: ["route/3"]
    - path: "lib/agent_com/task_router/tier_resolver.ex"
      provides: "Tier resolution from complexity to target type, fallback chains"
      exports: ["resolve/1", "fallback_up/1", "fallback_down/1"]
    - path: "lib/agent_com/task_router/load_scorer.ex"
      provides: "Weighted endpoint scoring with load, capacity, VRAM, warm model, repo affinity"
      exports: ["score_and_rank/3"]
    - path: "test/agent_com/task_router_test.exs"
      provides: "Comprehensive tests for routing decisions, scoring, tier resolution"
  key_links:
    - from: "lib/agent_com/task_router.ex"
      to: "lib/agent_com/task_router/tier_resolver.ex"
      via: "TierResolver.resolve/1 call"
      pattern: "TierResolver\\.resolve"
    - from: "lib/agent_com/task_router.ex"
      to: "lib/agent_com/task_router/load_scorer.ex"
      via: "LoadScorer.score_and_rank/3 call"
      pattern: "LoadScorer\\.score_and_rank"
---

<objective>
Build the TaskRouter pure-function routing decision engine with tier resolution, weighted endpoint scoring, and structured routing decision output.

Purpose: Encapsulate all routing logic as testable pure functions (no GenServer state, no side effects). The Scheduler (Plan 02) calls TaskRouter.route/3 and gets back a routing decision or fallback signal.

Output: Three modules (TaskRouter, TierResolver, LoadScorer) with comprehensive TDD test coverage.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-model-aware-scheduler/19-CONTEXT.md
@.planning/phases/19-model-aware-scheduler/19-RESEARCH.md
@lib/agent_com/complexity.ex
@lib/agent_com/llm_registry.ex
</context>

<feature>
  <name>TaskRouter routing decision engine (TDD)</name>
  <files>
    lib/agent_com/task_router.ex
    lib/agent_com/task_router/tier_resolver.ex
    lib/agent_com/task_router/load_scorer.ex
    test/agent_com/task_router_test.exs
  </files>
  <behavior>
    ## TierResolver

    resolve(task) -> tier atom
    - task with effective_tier :trivial -> :trivial
    - task with effective_tier :standard -> :standard
    - task with effective_tier :complex -> :complex
    - task with effective_tier :unknown -> :standard (conservative default)
    - task with no complexity data (nil) -> :standard
    - task with complexity map missing effective_tier -> :standard

    fallback_up(tier) -> next tier or nil
    - :trivial -> :standard
    - :standard -> :complex
    - :complex -> nil (no further escalation)

    fallback_down(tier) -> next tier or nil
    - :complex -> :standard
    - :standard -> :trivial
    - :trivial -> nil (no further de-escalation)

    ## LoadScorer

    score_and_rank(candidates, resources, task) -> [{endpoint, score, details}]
    - Single endpoint with low load -> high score
    - Single endpoint with high load -> low score
    - Two endpoints: less loaded one ranks first
    - Warm model bonus: endpoint with model loaded gets 1.15x multiplier
    - Repo affinity: same repo on endpoint gets 1.05x bonus when load is similar
    - Capacity factor: host with more RAM gets proportionally higher score (capped at 1.5x)
    - VRAM factor: host with more free VRAM scores higher (range 0.8-1.0)
    - Missing resource data -> neutral defaults (not penalized)
    - Empty candidates -> empty list

    ## TaskRouter

    route(task, endpoints, endpoint_resources) -> {:ok, decision} | {:fallback, tier, reason}
    - Trivial task -> {:ok, %{target_type: :sidecar, ...}}
    - Standard task + healthy Ollama endpoints -> {:ok, %{target_type: :ollama, selected_endpoint: "host:port", ...}}
    - Standard task + no healthy endpoints -> {:fallback, :standard, :no_healthy_ollama_endpoints}
    - Complex task -> {:ok, %{target_type: :claude, ...}}
    - Unknown tier task -> routes as :standard
    - Routing decision includes: effective_tier, target_type, selected_endpoint, selected_model,
      fallback_used, fallback_from_tier, fallback_reason, candidate_count, classification_reason,
      estimated_cost_tier, decided_at

    ## Edge Cases
    - Endpoints with empty models list -> excluded from standard tier candidates
    - Endpoint status :unhealthy -> excluded
    - Endpoint status :unknown -> excluded (only :healthy passes)
    - All resource values nil -> scoring uses neutral defaults
  </behavior>
  <implementation>
    ### TierResolver (lib/agent_com/task_router/tier_resolver.ex)

    Pure module with three public functions. Uses pattern matching on effective_tier atom.
    Fallback chains implement the locked decision: one-step max (trivial<->standard<->complex).

    ### LoadScorer (lib/agent_com/task_router/load_scorer.ex)

    Pure module with score_and_rank/3. Scoring formula per research:
    - base_score = 1.0
    - load_factor = 1.0 - (cpu_percent / 100.0), default cpu 50.0
    - capacity_factor = min(ram_total / @reference_capacity, 1.5), reference 16GB
    - vram_factor = if vram data: 0.8 + 0.2 * vram_free_pct, else 0.9
    - warm_bonus = 1.15 if model loaded, else 1.0
    - affinity_bonus = 1.05 if same repo on similar load, else 1.0
    - final = base * load_factor * capacity_factor * vram_factor * warm_bonus * affinity_bonus

    Accept task repo from task.repo field, endpoint model list from endpoint.models.
    For warm model detection: check if default model (from task metadata or config) is in endpoint.models list.
    For repo affinity: check endpoint_resources for a last_repo field or match against assigned tasks (simplified: use resource metadata if available).

    Discretion: Repo affinity simplified for Phase 19 -- check if a `repo` field exists in resource metrics. If not, skip affinity bonus. Phase 20 sidecar can add repo to resource reports.

    ### TaskRouter (lib/agent_com/task_router.ex)

    Top-level route/3 takes (task_map, endpoints_list, resources_map).
    1. Call TierResolver.resolve(task) to get tier
    2. Call find_target(tier, task, endpoints, resources) for each tier:
       - :trivial -> always succeeds with :sidecar target
       - :standard -> filter healthy endpoints with models, score_and_rank, pick best
       - :complex -> always succeeds with :claude target
    3. Build routing decision map with all required fields
    4. Return {:ok, decision} or {:fallback, original_tier, reason}

    classification_reason built from task.complexity data:
    "#{source}:#{effective_tier} (confidence #{confidence}, word_count=#{wc}, files=#{fc})"

    estimated_cost_tier: :free for trivial/sidecar, :local for standard/ollama, :api for complex/claude.
  </implementation>
</feature>

<verification>
1. `mix test test/agent_com/task_router_test.exs` -- all tests pass
2. `mix compile --warnings-as-errors` -- no warnings
3. Tests cover: all three tiers, fallback signals, scoring ranking, warm model bonus, repo affinity, edge cases
</verification>

<success_criteria>
- TaskRouter.route/3 returns correct routing decisions for trivial, standard, and complex tasks
- LoadScorer correctly ranks endpoints by weighted score
- TierResolver correctly resolves tiers and fallback chains
- All tests pass with zero warnings
</success_criteria>

<output>
After completion, create `.planning/phases/19-model-aware-scheduler/19-01-SUMMARY.md`
</output>
