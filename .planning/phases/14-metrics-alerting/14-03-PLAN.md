---
phase: 14-metrics-alerting
plan: 03
type: execute
wave: 3
depends_on: ["14-01", "14-02"]
files_modified:
  - lib/agent_com/dashboard_socket.ex
  - lib/agent_com/dashboard_notifier.ex
  - lib/agent_com/dashboard_state.ex
autonomous: true
must_haves:
  truths:
    - "Dashboard WebSocket pushes metrics_snapshot events every 10 seconds and alert_fired/alert_cleared events in real time"
    - "Push notifications fire for all alert events (same pattern as DETS compaction failures)"
    - "DashboardSocket clients can acknowledge alerts via WebSocket message"
  artifacts:
    - path: "lib/agent_com/dashboard_socket.ex"
      provides: "Metrics and alert event streaming to dashboard browser clients"
      contains: "metrics_snapshot"
    - path: "lib/agent_com/dashboard_notifier.ex"
      provides: "Push notifications for alert events"
      contains: "alert_fired"
  key_links:
    - from: "lib/agent_com/dashboard_socket.ex"
      to: "Phoenix.PubSub"
      via: "Subscribes to 'metrics' and 'alerts' topics"
      pattern: "subscribe.*metrics"
    - from: "lib/agent_com/dashboard_notifier.ex"
      to: "Phoenix.PubSub"
      via: "Subscribes to 'alerts' topic for push notifications"
      pattern: "subscribe.*alerts"
    - from: "lib/agent_com/dashboard_socket.ex"
      to: "lib/agent_com/alerter.ex"
      via: "Calls Alerter.acknowledge/1 on client ack message"
      pattern: "Alerter.acknowledge"
---

<objective>
Integrate MetricsCollector and Alerter output into the dashboard WebSocket and push notification systems so browser clients receive real-time metrics updates and alert events.

Purpose: Connects the data pipeline (MetricsCollector -> Alerter -> PubSub) to the dashboard delivery layer. Required for the dashboard UI (plan 04) to display metrics and alerts in real time.
Output: Updated dashboard_socket.ex, dashboard_notifier.ex, dashboard_state.ex.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-metrics-alerting/14-RESEARCH.md
@.planning/phases/14-metrics-alerting/14-01-SUMMARY.md
@.planning/phases/14-metrics-alerting/14-02-SUMMARY.md
@lib/agent_com/dashboard_socket.ex
@lib/agent_com/dashboard_notifier.ex
@lib/agent_com/dashboard_state.ex
@lib/agent_com/alerter.ex
@lib/agent_com/metrics_collector.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend DashboardSocket for metrics and alert streaming</name>
  <files>lib/agent_com/dashboard_socket.ex</files>
  <action>
Modify DashboardSocket to subscribe to "metrics" and "alerts" PubSub topics and relay events to browser clients.

**In init/1:** Add two new PubSub subscriptions alongside the existing ones:
```elixir
Phoenix.PubSub.subscribe(AgentCom.PubSub, "metrics")
Phoenix.PubSub.subscribe(AgentCom.PubSub, "alerts")
```

**New handle_info clauses** (add BEFORE the catch-all `handle_info(_msg, state)`):

1. Metrics snapshot:
```elixir
def handle_info({:metrics_snapshot, snapshot}, state) do
  # Send compact snapshot -- only aggregated values, not raw data points
  # Keep payload under 5KB by excluding per-agent transition details
  compact = %{
    type: "metrics_snapshot",
    data: %{
      timestamp: snapshot.timestamp,
      queue_depth: snapshot.queue_depth,
      task_latency: snapshot.task_latency,
      agent_utilization: %{
        system: snapshot.agent_utilization.system,
        per_agent: Enum.map(snapshot.agent_utilization.per_agent, fn a ->
          Map.take(a, [:agent_id, :state, :idle_pct_1h, :working_pct_1h, :blocked_pct_1h, :tasks_completed_1h, :avg_task_duration_ms])
        end)
      },
      error_rates: snapshot.error_rates
    }
  }
  {:ok, %{state | pending_events: [compact | state.pending_events]}}
end
```

2. Alert fired:
```elixir
def handle_info({:alert_fired, alert}, state) do
  formatted = %{
    type: "alert_fired",
    data: %{
      rule_id: alert.rule_id,
      severity: to_string(alert.severity),
      message: alert.message,
      details: alert.details || %{},
      fired_at: alert.fired_at,
      acknowledged: false
    }
  }
  {:ok, %{state | pending_events: [formatted | state.pending_events]}}
end
```

3. Alert cleared:
```elixir
def handle_info({:alert_cleared, rule_id}, state) do
  formatted = %{type: "alert_cleared", rule_id: to_string(rule_id)}
  {:ok, %{state | pending_events: [formatted | state.pending_events]}}
end
```

4. Alert acknowledged:
```elixir
def handle_info({:alert_acknowledged, rule_id}, state) do
  formatted = %{type: "alert_acknowledged", rule_id: to_string(rule_id)}
  {:ok, %{state | pending_events: [formatted | state.pending_events]}}
end
```

**New client message handler** (in handle_in, add a new case to the Jason.decode match):
```elixir
{:ok, %{"type" => "acknowledge_alert", "rule_id" => rule_id}} ->
  result =
    case AgentCom.Alerter.acknowledge(rule_id) do
      :ok -> %{type: "alert_ack_result", rule_id: rule_id, status: "acknowledged"}
      {:error, :not_found} -> %{type: "alert_ack_result", rule_id: rule_id, status: "not_found"}
    end
  {:push, {:text, Jason.encode!(result)}, state}
```

**Update initial snapshot:** In init/1, include active alerts in the initial snapshot push. After getting the DashboardState snapshot, also fetch active alerts:
```elixir
alerts = try do
  AgentCom.Alerter.active_alerts()
rescue
  _ -> []
end
```
Include `alerts` in the initial push: `%{type: "snapshot", data: snapshot, alerts: alerts}`.

**Update @moduledoc** to document the new message types and client commands.
  </action>
  <verify>
Run `mix compile` -- no errors.
Run `mix test` -- existing tests still pass.
  </verify>
  <done>
DashboardSocket subscribes to "metrics" and "alerts" PubSub topics. Browser clients receive metrics_snapshot every 10s and alert events in real time. Clients can send acknowledge_alert messages via WebSocket.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend DashboardNotifier for alert push notifications and update DashboardState</name>
  <files>lib/agent_com/dashboard_notifier.ex, lib/agent_com/dashboard_state.ex</files>
  <action>
**dashboard_notifier.ex changes:**

1. Subscribe to "alerts" PubSub topic in init/1 (add alongside existing "presence" and "backups"):
```elixir
Phoenix.PubSub.subscribe(AgentCom.PubSub, "alerts")
```

2. Add handle_info for alert_fired (BEFORE the catch-all):
```elixir
def handle_info({:alert_fired, alert}, state) do
  severity_label = if alert.severity == :critical, do: "CRITICAL", else: "WARNING"
  payload = Jason.encode!(%{
    title: "AgentCom #{severity_label}",
    body: alert.message,
    icon: "/favicon.ico",
    data: %{rule_id: alert.rule_id, severity: to_string(alert.severity)}
  })
  new_subs = send_to_all(state.subscriptions, payload)
  {:noreply, %{state | subscriptions: new_subs}}
end
```

3. Add handle_info for alert_cleared (push notification only for CRITICAL-level clears):
```elixir
def handle_info({:alert_cleared, rule_id}, state) do
  # Only send "cleared" push for rules that were CRITICAL severity
  # This avoids notification spam for WARNING rules that oscillate
  # DashboardSocket handles real-time UI updates for all clears
  {:noreply, state}
end
```

4. Add handle_info for alert_acknowledged:
```elixir
def handle_info({:alert_acknowledged, _rule_id}, state) do
  # No push notification for acknowledgments -- UI-only
  {:noreply, state}
end
```

**dashboard_state.ex changes:**

Add active alerts to the snapshot. In the `snapshot/0` function or wherever the snapshot map is assembled, add an `:active_alerts` key:

```elixir
active_alerts = try do
  AgentCom.Alerter.active_alerts()
rescue
  _ -> []
end
```

Include `active_alerts: active_alerts` in the snapshot map. This ensures GET /api/dashboard/state includes alert information alongside the existing health data.

Keep the existing `compute_health/3` function intact (migration strategy: keep DashboardState functional alongside Alerter). The Alerter formalizes the same checks with configurable thresholds, but DashboardState's health heuristics continue working as a fallback.

Subscribe DashboardState to "alerts" topic in init so the snapshot stays current when alerts change (add PubSub subscription and handle_info for alert events to trigger a snapshot refresh, same pattern as backup_complete).
  </action>
  <verify>
Run `mix compile` -- no errors.
Run `mix test` -- existing tests still pass.
Verify GET /api/dashboard/state returns active_alerts key.
  </verify>
  <done>
DashboardNotifier sends push notifications for alert_fired events (CRITICAL labeled distinctly). DashboardState includes active_alerts in snapshots. Existing health heuristics remain functional as fallback alongside Alerter.
  </done>
</task>

</tasks>

<verification>
1. `mix compile` succeeds with no warnings
2. `mix test` passes (no regressions)
3. Connect to ws://localhost:4000/ws/dashboard -- initial snapshot includes `alerts` key
4. Metrics snapshots arrive every ~10 seconds with type "metrics_snapshot"
5. When an alert fires (simulate by stopping all agents), alert_fired event appears on WebSocket
6. Sending `{"type": "acknowledge_alert", "rule_id": "stuck_tasks"}` via WebSocket returns ack result
7. GET /api/dashboard/state includes active_alerts in response
</verification>

<success_criteria>
- DashboardSocket pushes metrics_snapshot events every 10s to connected browsers
- Alert events (fired/cleared/acknowledged) relay through DashboardSocket in real time
- DashboardNotifier sends push notifications for alert_fired events (CRITICAL and WARNING)
- DashboardState snapshot includes active_alerts for GET /api/dashboard/state consumers
- Browser clients can acknowledge alerts via WebSocket message
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-metrics-alerting/14-03-SUMMARY.md`
</output>
