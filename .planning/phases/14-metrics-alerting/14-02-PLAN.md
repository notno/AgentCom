---
phase: 14-metrics-alerting
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - lib/agent_com/alerter.ex
  - lib/agent_com/application.ex
  - lib/agent_com/endpoint.ex
autonomous: true
must_haves:
  truths:
    - "When a monitored threshold is exceeded, an alert broadcasts to PubSub 'alerts' topic within one check cycle (default 30s)"
    - "Alert thresholds can be changed via PUT /api/config/alert-thresholds and changes take effect on the next check cycle"
    - "CRITICAL alerts always fire immediately; WARNING alerts respect configurable cooldown periods"
    - "Alerts have inactive/active/acknowledged/cleared lifecycle; acknowledged alerts suppress repeat notifications until condition clears and returns"
  artifacts:
    - path: "lib/agent_com/alerter.ex"
      provides: "Configurable alert rule evaluator with cooldown and ack state"
      contains: "defmodule AgentCom.Alerter"
    - path: "lib/agent_com/endpoint.ex"
      provides: "Alert management API endpoints"
      contains: "get \"/api/alerts\""
  key_links:
    - from: "lib/agent_com/alerter.ex"
      to: "lib/agent_com/metrics_collector.ex"
      via: "AgentCom.MetricsCollector.snapshot/0 called on each check cycle"
      pattern: "MetricsCollector.snapshot"
    - from: "lib/agent_com/alerter.ex"
      to: "lib/agent_com/config.ex"
      via: "AgentCom.Config.get(:alert_thresholds) read on each check cycle"
      pattern: "Config.get.*alert_thresholds"
    - from: "lib/agent_com/alerter.ex"
      to: "Phoenix.PubSub"
      via: "Broadcasts alert_fired/alert_cleared/alert_acknowledged on 'alerts' topic"
      pattern: "PubSub.broadcast.*alerts"
---

<objective>
Build the Alerter GenServer that evaluates configurable alert rules against metrics, manages cooldown and acknowledgment state, broadcasts alerts on PubSub, and expose alert management via API endpoints.

Purpose: Satisfies success criteria #2 (alert broadcasts to dashboard within 60 seconds) and #3 (thresholds changeable via Config store without restart).
Output: alerter.ex, updated application.ex, updated endpoint.ex with alert endpoints.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-metrics-alerting/14-RESEARCH.md
@.planning/phases/14-metrics-alerting/14-01-SUMMARY.md
@lib/agent_com/metrics_collector.ex
@lib/agent_com/application.ex
@lib/agent_com/endpoint.ex
@lib/agent_com/config.ex
@lib/agent_com/dashboard_state.ex
@lib/agent_com/task_queue.ex
@lib/agent_com/agent_fsm.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Alerter GenServer with rule evaluation, cooldown, and ack state machine</name>
  <files>lib/agent_com/alerter.ex</files>
  <action>
Create `AgentCom.Alerter` GenServer with these components:

**GenServer State:**
```elixir
%{
  active_alerts: %{},      # rule_id => %{severity, message, details, fired_at, acknowledged}
  cooldown_state: %{},     # rule_id => last_fired_at timestamp
  consecutive_checks: %{}  # rule_id => count (for hysteresis-based rules like queue_growing)
}
```

**Default Thresholds** (exposed via `default_thresholds/0` public function):
```elixir
%{
  queue_growing_checks: 3,          # consecutive increases before WARNING
  failure_rate_pct: 50,             # >50% in window triggers WARNING
  stuck_task_ms: 300_000,           # 5 min -- matches existing @stuck_task_threshold_ms
  error_count_hour: 10,             # >10 failures/hour triggers WARNING
  check_interval_ms: 30_000,        # evaluate rules every 30s
  cooldowns: %{
    queue_growing: 300_000,         # 5 min cooldown for WARNING
    high_failure_rate: 600_000,     # 10 min cooldown for WARNING
    stuck_tasks: 0,                 # CRITICAL -- no cooldown
    no_agents_online: 0,            # CRITICAL -- no cooldown
    high_error_rate: 300_000        # 5 min cooldown for WARNING
  }
}
```

**Init:**
- Read thresholds from `AgentCom.Config.get(:alert_thresholds)` -- fall back to default_thresholds/0 if nil.
- Schedule first check with a 30-second startup delay (prevent false positives on fresh start before agents reconnect): `Process.send_after(self(), :check, 30_000)`.

**Check Cycle** (handle_info :check):
1. Read thresholds from Config on EVERY check (no caching -- per success criteria, changes must take effect on next cycle).
2. Call `AgentCom.MetricsCollector.snapshot/0` to get current metrics.
3. Evaluate each rule against metrics + thresholds.
4. For each rule:
   - If condition TRUE and rule is inactive: Fire alert (set active, record fired_at, broadcast `{:alert_fired, alert_map}` on "alerts" topic).
   - If condition TRUE and rule is active but not acknowledged: Check cooldown. If CRITICAL or cooldown expired, re-fire (broadcast again). If WARNING and cooldown not expired, skip.
   - If condition TRUE and rule is acknowledged: Do nothing (suppressed).
   - If condition FALSE and rule was active or acknowledged: Clear alert (remove from active, broadcast `{:alert_cleared, rule_id}` on "alerts" topic). Reset ack state so it can re-fire if condition returns.
5. Schedule next check using thresholds[:check_interval_ms] or default 30_000.

**5 Alert Rules** (implement as private functions):

1. `evaluate_queue_growing/3(metrics, thresholds, consecutive_checks)`:
   - Read queue_depth.trend from metrics snapshot.
   - Count consecutive increases in the trend list (compare adjacent pairs from end).
   - If consecutive increases >= thresholds.queue_growing_checks, condition is TRUE.
   - Severity: :warning. Message: "Queue growing: depth increased for N consecutive checks (current: M)".
   - Hysteresis for clearing: only clear when queue has been stable/decreasing for 3 consecutive checks.

2. `evaluate_high_failure_rate/2(metrics, thresholds)`:
   - Read error_rates.window.failure_rate_pct from metrics.
   - If > thresholds.failure_rate_pct and error_rates.window.total_tasks > 0, condition is TRUE.
   - Severity: :warning. Message: "High failure rate: X% (Y/Z tasks failed in last hour)".

3. `evaluate_stuck_tasks/2(metrics, thresholds)`:
   - Call `AgentCom.TaskQueue.list(status: :assigned)` wrapped in try/rescue.
   - Filter tasks where `now - task.updated_at > thresholds.stuck_task_ms`.
   - If any stuck tasks, condition is TRUE.
   - Severity: :critical. Message: "N tasks stuck: task_id1, task_id2 (>X min without progress)".
   - Details: %{task_ids: [...], stuck_duration_ms: max_duration}.

4. `evaluate_no_agents_online/1(metrics)`:
   - Read agent_utilization.system.agents_online from metrics.
   - If agents_online == 0 AND agent_utilization.system.total_agents > 0 (had agents before), condition is TRUE.
   - Severity: :critical. Message: "No agents online (X previously registered)".
   - Note: Don't fire on fresh start with no agents ever registered.

5. `evaluate_high_error_rate/2(metrics, thresholds)`:
   - Read error_rates.window.failed from metrics.
   - If > thresholds.error_count_hour, condition is TRUE.
   - Severity: :warning. Message: "High error count: X failures in the last hour (threshold: Y)".

**Cooldown Logic:**
- `should_fire?(rule_id, severity, cooldown_state, thresholds, now)`:
  - If severity == :critical, return true (bypass cooldown per locked decision).
  - If rule_id not in cooldown_state, return true (first fire).
  - If now - cooldown_state[rule_id] >= thresholds.cooldowns[rule_id], return true.
  - Otherwise return false.

**Public API:**
- `start_link/1` -- standard GenServer
- `active_alerts/0` -- returns list of active alerts as maps (for GET /api/alerts)
- `acknowledge/1` -- acknowledges an alert by rule_id. Returns :ok or {:error, :not_found}
- `default_thresholds/0` -- returns the default thresholds map
- `check_now/0` -- triggers an immediate check cycle (for testing/manual use)

**PubSub Broadcasts (on "alerts" topic):**
- `{:alert_fired, %{rule_id: S, severity: A, message: S, details: M, fired_at: N}}`
- `{:alert_cleared, rule_id}`
- `{:alert_acknowledged, rule_id}`
  </action>
  <verify>
Run `mix compile` -- no warnings or errors. Module compiles cleanly.
Verify the 5 default rules are all implemented with correct severity levels.
  </verify>
  <done>
Alerter GenServer exists with 5 configurable alert rules, cooldown logic (CRITICAL bypasses, WARNING respects), ack state machine (inactive/active/acknowledged/cleared), PubSub broadcasting on "alerts" topic, and Config DETS threshold loading on every check cycle.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Alerter to supervision tree and create alert API endpoints</name>
  <files>lib/agent_com/application.ex, lib/agent_com/endpoint.ex</files>
  <action>
**application.ex changes:**
Add `{AgentCom.Alerter, []}` to the children list AFTER `AgentCom.MetricsCollector` and BEFORE `AgentCom.DashboardState`. This ensures Alerter can read from MetricsCollector and broadcasts are available before DashboardState/DashboardNotifier start subscribing.

**endpoint.ex changes:**
Add these endpoints (placed after the /api/dashboard section):

1. `GET /api/alerts` (no auth -- same visibility as /api/dashboard/state):
```elixir
get "/api/alerts" do
  alerts = AgentCom.Alerter.active_alerts()
  send_json(conn, 200, %{
    "alerts" => alerts,
    "timestamp" => System.system_time(:millisecond)
  })
end
```

2. `POST /api/alerts/:rule_id/acknowledge` (auth required):
```elixir
post "/api/alerts/:rule_id/acknowledge" do
  conn = AgentCom.Plugs.RequireAuth.call(conn, [])
  if conn.halted do
    conn
  else
    case AgentCom.Alerter.acknowledge(rule_id) do
      :ok -> send_json(conn, 200, %{"status" => "acknowledged", "rule_id" => rule_id})
      {:error, :not_found} -> send_json(conn, 404, %{"error" => "alert_not_found"})
    end
  end
end
```

3. `GET /api/config/alert-thresholds` (auth required):
```elixir
get "/api/config/alert-thresholds" do
  conn = AgentCom.Plugs.RequireAuth.call(conn, [])
  if conn.halted do
    conn
  else
    thresholds = AgentCom.Config.get(:alert_thresholds) || AgentCom.Alerter.default_thresholds()
    send_json(conn, 200, thresholds)
  end
end
```

4. `PUT /api/config/alert-thresholds` (auth required):
```elixir
put "/api/config/alert-thresholds" do
  conn = AgentCom.Plugs.RequireAuth.call(conn, [])
  if conn.halted do
    conn
  else
    thresholds = conn.body_params
    :ok = AgentCom.Config.put(:alert_thresholds, thresholds)
    send_json(conn, 200, %{"status" => "updated", "effective" => "next_check_cycle"})
  end
end
```

**IMPORTANT:** Place these endpoints BEFORE the `match _` catch-all. Place the `POST /api/alerts/:rule_id/acknowledge` BEFORE any `GET /api/alerts/:something` parameterized route to avoid conflicts. Since we only have GET /api/alerts (no params), this should be fine.

Update the @moduledoc route listing to include all new endpoints:
- `GET    /api/metrics                 -- System metrics (no auth)`
- `GET    /api/alerts                  -- Active alerts (no auth)`
- `POST   /api/alerts/:rule_id/acknowledge -- Acknowledge alert (auth required)`
- `GET    /api/config/alert-thresholds -- Get alert thresholds (auth required)`
- `PUT    /api/config/alert-thresholds -- Update alert thresholds (auth required)`
  </action>
  <verify>
Run `mix compile` -- no errors.
Run `mix test` -- existing tests still pass.
  </verify>
  <done>
Alerter is in the supervision tree after MetricsCollector. API endpoints for alerts (GET list, POST acknowledge) and thresholds (GET/PUT) are functional. Threshold changes via PUT take effect on the next Alerter check cycle without restart.
  </done>
</task>

</tasks>

<verification>
1. `mix compile` succeeds with no warnings
2. `mix test` passes (no regressions)
3. Start app, `curl http://localhost:4000/api/alerts` returns JSON with alerts array (empty initially)
4. `curl http://localhost:4000/api/config/alert-thresholds -H "Authorization: Bearer TOKEN"` returns default thresholds
5. `curl -X PUT http://localhost:4000/api/config/alert-thresholds -H "Authorization: Bearer TOKEN" -H "Content-Type: application/json" -d '{"check_interval_ms": 15000}'` returns status updated
6. In IEx: `AgentCom.Alerter.check_now()` triggers immediate evaluation without waiting for timer
</verification>

<success_criteria>
- Alerter GenServer starts in supervision tree and evaluates 5 rules on a configurable check cycle
- CRITICAL alerts (stuck_tasks, no_agents_online) fire immediately; WARNING alerts respect cooldown
- Alerts broadcast on PubSub "alerts" topic as alert_fired/alert_cleared/alert_acknowledged
- GET /api/alerts returns active alerts; POST /api/alerts/:rule_id/acknowledge marks alert acknowledged
- PUT /api/config/alert-thresholds updates thresholds in Config DETS; changes take effect on next check cycle
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-metrics-alerting/14-02-SUMMARY.md`
</output>
