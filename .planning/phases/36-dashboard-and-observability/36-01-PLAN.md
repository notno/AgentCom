---
phase: 36-dashboard-and-observability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/agent_com/dashboard_state.ex
  - lib/agent_com/dashboard_socket.ex
autonomous: true

must_haves:
  truths:
    - "DashboardState snapshot includes GoalBacklog stats (by_status counts) and active goal summaries with task progress"
    - "DashboardState snapshot includes CostLedger stats (hourly/daily/session breakdowns and budget limits)"
    - "DashboardSocket subscribes to 'goals' PubSub topic and forwards goal events as WebSocket messages"
    - "DashboardState subscribes to 'goals' PubSub topic for state tracking"
  artifacts:
    - path: "lib/agent_com/dashboard_state.ex"
      provides: "GoalBacklog and CostLedger data in snapshot, goals PubSub subscription"
      contains: "goal_stats"
    - path: "lib/agent_com/dashboard_socket.ex"
      provides: "Goals PubSub subscription and goal_event forwarding"
      contains: "goal_event"
  key_links:
    - from: "lib/agent_com/dashboard_state.ex"
      to: "AgentCom.GoalBacklog"
      via: "GenServer.call in snapshot"
      pattern: "GoalBacklog\\.stats|GoalBacklog\\.list"
    - from: "lib/agent_com/dashboard_state.ex"
      to: "AgentCom.CostLedger"
      via: "GenServer.call in snapshot"
      pattern: "CostLedger\\.stats"
    - from: "lib/agent_com/dashboard_socket.ex"
      to: "AgentCom.PubSub"
      via: "PubSub subscribe"
      pattern: "subscribe.*goals"
---

<objective>
Add GoalBacklog and CostLedger data sources to the dashboard backend pipeline so the frontend can render goal progress and cost tracking panels.

Purpose: The dashboard currently shows Hub FSM state but has no visibility into goal backlog depth, per-goal progress, or hub CLI invocation costs. This plan wires the existing GoalBacklog and CostLedger GenServer APIs into the DashboardState snapshot and DashboardSocket real-time event pipeline.

Output: Updated DashboardState.snapshot/0 includes goal_stats, active_goals, and cost_stats fields. DashboardSocket forwards goal_event messages to connected browsers.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-dashboard-and-observability/36-RESEARCH.md
@lib/agent_com/dashboard_state.ex
@lib/agent_com/dashboard_socket.ex
@lib/agent_com/goal_backlog.ex
@lib/agent_com/cost_ledger.ex
@lib/agent_com/task_queue.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add GoalBacklog and CostLedger data to DashboardState snapshot</name>
  <files>lib/agent_com/dashboard_state.ex</files>
  <action>
In DashboardState:

1. **Add "goals" PubSub subscription in init/1:** Add `Phoenix.PubSub.subscribe(AgentCom.PubSub, "goals")` after the existing subscriptions. Add "goals" to the Logger.info topics list.

2. **Add GoalBacklog data to handle_call(:snapshot):** After the existing `hub_fsm` block, add:

```elixir
goal_stats =
  try do
    AgentCom.GoalBacklog.stats()
  catch
    :exit, _ -> %{by_status: %{}, by_priority: %{}, total: 0}
  end

# Only fetch active goals (decomposing/executing/verifying) for progress display
active_goals =
  try do
    [:decomposing, :executing, :verifying]
    |> Enum.flat_map(fn status ->
      AgentCom.GoalBacklog.list(%{status: status})
    end)
    |> Enum.take(10)  # Cap to prevent snapshot bloat
    |> Enum.map(fn goal ->
      progress = AgentCom.TaskQueue.goal_progress(goal.id)
      %{
        id: goal.id,
        description: String.slice(to_string(goal.description), 0, 100),
        status: goal.status,
        priority: goal.priority,
        tasks_total: progress.total,
        tasks_complete: progress.completed,
        tasks_failed: progress.failed,
        created_at: goal.created_at,
        updated_at: goal.updated_at
      }
    end)
  catch
    :exit, _ -> []
  end
```

3. **Add CostLedger data to handle_call(:snapshot):** After goal data:

```elixir
cost_stats =
  try do
    AgentCom.CostLedger.stats()
  catch
    :exit, _ -> %{
      hourly: %{executing: 0, improving: 0, contemplating: 0, total: 0},
      daily: %{executing: 0, improving: 0, contemplating: 0, total: 0},
      session: %{executing: 0, improving: 0, contemplating: 0, total: 0},
      budgets: %{}
    }
  end
```

4. **Add new fields to snapshot map:** Add `goal_stats: goal_stats`, `active_goals: active_goals`, and `cost_stats: cost_stats` to the snapshot map alongside the existing `hub_fsm: hub_fsm`.

5. **Add goal event handler:** Add a handle_info clause for goal PubSub events (pass-through like llm_registry_update -- data is fetched live in snapshot):

```elixir
def handle_info({:goal_event, _payload}, state) do
  {:noreply, state}
end
```

Place this before the catch-all handle_info.

Use `catch :exit, _` (not `try/rescue`) for GoalBacklog calls because they're GenServer.call -- matching the existing hub_fsm pattern in the same function.
  </action>
  <verify>Run `mix compile --warnings-as-errors` and confirm no compilation errors. Run `mix test test/dashboard_state_test.exs` if it exists.</verify>
  <done>DashboardState.snapshot/0 returns a map containing goal_stats, active_goals, and cost_stats keys with data from GoalBacklog and CostLedger GenServers. Falls back gracefully when GenServers are unavailable.</done>
</task>

<task type="auto">
  <name>Task 2: Subscribe DashboardSocket to goals PubSub and forward goal events</name>
  <files>lib/agent_com/dashboard_socket.ex</files>
  <action>
In DashboardSocket:

1. **Add "goals" PubSub subscription in init/1:** Add `Phoenix.PubSub.subscribe(AgentCom.PubSub, "goals")` after the existing "hub_fsm" subscription.

2. **Add goal_event handler:** Add a handle_info clause before the catch-all that handles goal events from PubSub. GoalBacklog broadcasts `{:goal_event, payload}` on the "goals" topic. Format and accumulate into pending_events:

```elixir
def handle_info({:goal_event, payload}, state) do
  formatted = %{
    type: "goal_event",
    data: %{
      event: to_string(payload.event),
      goal_id: payload.goal_id,
      status: if(payload.goal, do: to_string(payload.goal.status), else: nil),
      priority: if(payload.goal, do: payload.goal.priority, else: nil),
      timestamp: payload.timestamp
    }
  }

  {:ok, %{state | pending_events: [formatted | state.pending_events]}}
end
```

Place this after the hub_fsm_state_change handler and before the repo_registry_update handler (or before catch-all). Handle nil payload.goal defensively since some events may not carry the full goal map.
  </action>
  <verify>Run `mix compile --warnings-as-errors` and confirm no compilation errors.</verify>
  <done>DashboardSocket subscribes to "goals" PubSub topic and forwards goal_event messages through the batched event pipeline to connected WebSocket clients.</done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` passes cleanly
2. `mix test` passes (existing tests don't break)
3. Inspect DashboardState.snapshot/0 output in iex to confirm goal_stats, active_goals, and cost_stats are present
</verification>

<success_criteria>
DashboardState.snapshot/0 includes goal_stats (by_status counts), active_goals (up to 10 with progress), and cost_stats (hourly/daily/session/budgets). DashboardSocket forwards goal_event messages. All existing tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/36-dashboard-and-observability/36-01-SUMMARY.md`
</output>
