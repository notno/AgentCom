---
phase: 20-sidecar-execution
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/agent_com/socket.ex
  - lib/agent_com/validation/schemas.ex
  - test/agent_com/socket_test.exs
autonomous: true

must_haves:
  truths:
    - "task_assign WebSocket message includes routing_decision fields from the scheduler"
    - "task_complete WebSocket message accepts execution metadata (model_used, tokens_in, tokens_out, estimated_cost_usd)"
    - "task_progress WebSocket message with execution_event payload is forwarded via PubSub to dashboard"
  artifacts:
    - path: "lib/agent_com/socket.ex"
      provides: "routing_decision in task_assign push, execution_metadata in task_complete handling, execution_event in task_progress PubSub"
      contains: "routing_decision"
    - path: "lib/agent_com/validation/schemas.ex"
      provides: "Updated validation schemas for task_complete with execution fields and task_progress with execution_event"
  key_links:
    - from: "lib/agent_com/socket.ex"
      to: "sidecar/index.js"
      via: "task_assign WebSocket message with routing_decision"
      pattern: "routing_decision"
    - from: "lib/agent_com/socket.ex"
      to: "AgentCom.PubSub tasks topic"
      via: "PubSub.broadcast for execution_event in task_progress"
      pattern: "execution_event"
---

<objective>
Wire the hub to forward routing decisions to sidecars and accept execution metadata back -- the Elixir-side plumbing that enables Phase 20 execution.

Purpose: The Scheduler (Phase 19) already includes `routing_decision` in `task_data` sent to Socket, but Socket.handle_info({:push_task, task}) does not yet include it in the WebSocket `task_assign` message. Similarly, `task_complete` handling needs to accept and store execution metadata (model_used, tokens, cost). The `task_progress` handler needs to forward `execution_event` payloads via PubSub for dashboard streaming.

Output: Hub correctly forwards routing info to sidecars and accepts execution results back.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-model-aware-scheduler/19-01-SUMMARY.md
@lib/agent_com/socket.ex
@lib/agent_com/validation/schemas.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add routing_decision to task_assign and execution metadata to task_complete</name>
  <files>
    lib/agent_com/socket.ex
  </files>
  <action>
    In `handle_info({:push_task, task}, state)`, add `routing_decision` to the push map. The Scheduler already passes it in task_data (see scheduler.ex line 507: `routing_decision: routing_decision`). Format routing_decision for WebSocket serialization:

    ```elixir
    "routing_decision" => format_routing_decision_for_ws(task[:routing_decision] || task["routing_decision"])
    ```

    Add a `format_routing_decision_for_ws/1` helper similar to `format_complexity_for_ws/1`:
    - nil -> nil
    - map -> convert atom keys to string keys, convert atom values (target_type, effective_tier, estimated_cost_tier) to strings
    - Fields to include: effective_tier, target_type, selected_endpoint, selected_model, fallback_used, fallback_reason, classification_reason, estimated_cost_tier

    In `handle_msg(%{"type" => "task_complete"} ...)`, extract execution metadata from the result:
    - `model_used` from `result["model_used"]`
    - `tokens_in` from `result["tokens_in"]`
    - `tokens_out` from `result["tokens_out"]`
    - `estimated_cost_usd` from `result["estimated_cost_usd"]`
    - `equivalent_claude_cost_usd` from `result["equivalent_claude_cost_usd"]`
    - `execution_ms` from `result["execution_ms"]`

    These are passed through to `TaskQueue.complete_task` in the result map (already passes `result: result` so no structural change needed -- the execution metadata is inside the result map).
  </action>
  <verify>Run `mix test test/agent_com/socket_test.exs` -- all existing tests pass. Verify `format_routing_decision_for_ws/1` exists and handles nil correctly.</verify>
  <done>task_assign includes routing_decision fields. task_complete passes through execution metadata in result. No regressions in existing socket tests.</done>
</task>

<task type="auto">
  <name>Task 2: Forward execution_event in task_progress and update validation schemas</name>
  <files>
    lib/agent_com/socket.ex
    lib/agent_com/validation/schemas.ex
  </files>
  <action>
    In `handle_msg(%{"type" => "task_progress"} ...)` in socket.ex, extract `execution_event` from the message and include it in the PubSub broadcast payload so the dashboard can render streaming execution events:

    ```elixir
    defp handle_msg(%{"type" => "task_progress", "task_id" => task_id} = msg, state) do
      log_task_event(state.agent_id, "task_progress", task_id, msg)
      AgentCom.TaskQueue.update_progress(task_id)

      # Forward execution_event for dashboard streaming (Phase 20)
      if execution_event = msg["execution_event"] do
        Phoenix.PubSub.broadcast(AgentCom.PubSub, "tasks", {:task_event, %{
          agent_id: state.agent_id,
          event: :execution_progress,
          task_id: task_id,
          execution_event: execution_event,
          timestamp: System.system_time(:millisecond)
        }})
      end

      {:ok, state}
    end
    ```

    In validation/schemas.ex, update the `task_progress` WS schema to allow the optional `execution_event` field as a `:map` type. Also update `task_complete` schema to allow `execution_ms`, `model_used`, `tokens_in`, `tokens_out`, `estimated_cost_usd`, `equivalent_claude_cost_usd` as optional fields inside the result map (these are nested in `result` so no schema change needed for top-level -- only verify `result` is type `:map` which it already is).

    The task_progress schema update:
    ```elixir
    # Add execution_event as optional :map field to task_progress schema
    {"execution_event", :map, :optional}
    ```

    This is backward-compatible -- existing task_progress messages without execution_event continue working.
  </action>
  <verify>Run `mix test test/agent_com/validation_test.exs test/agent_com/socket_test.exs` -- all tests pass. Verify task_progress schema accepts messages with and without execution_event.</verify>
  <done>task_progress with execution_event broadcasts to PubSub "tasks" topic. Validation schemas updated. Backward compatible -- existing messages unaffected.</done>
</task>

</tasks>

<verification>
- `mix test test/agent_com/socket_test.exs` -- all tests pass (no regressions)
- `mix test test/agent_com/validation_test.exs` -- all tests pass
- `format_routing_decision_for_ws/1` handles nil and full routing decision maps
- task_progress with execution_event field passes validation
- task_progress without execution_event field still passes validation (backward compat)
</verification>

<success_criteria>
1. task_assign WebSocket message includes routing_decision with target_type, selected_endpoint, selected_model
2. task_complete passes execution metadata through to TaskQueue
3. task_progress with execution_event broadcasts via PubSub for dashboard consumption
4. All existing socket and validation tests continue passing
</success_criteria>

<output>
After completion, create `.planning/phases/20-sidecar-execution/20-02-SUMMARY.md`
</output>
