---
phase: 23-multi-repo-registry-and-workspace-switching
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/agent_com/repo_registry.ex
  - lib/agent_com/application.ex
  - lib/agent_com/dets_backup.ex
  - lib/agent_com/endpoint.ex
  - lib/agent_com/validation/schemas.ex
  - test/support/dets_helpers.ex
autonomous: true

must_haves:
  truths:
    - "Admin can add a repo via POST /api/admin/repo-registry and it appears in GET list"
    - "Admin can remove a repo via DELETE and it disappears from list"
    - "Admin can reorder repos via PUT move-up/move-down and priority order changes"
    - "Admin can pause/unpause a repo via PUT and status toggles"
    - "RepoRegistry data survives hub restart (DETS persistence)"
    - "top_active_repo returns the first active repo in priority order"
    - "active_repo_ids returns URLs of all non-paused repos"
  artifacts:
    - path: "lib/agent_com/repo_registry.ex"
      provides: "DETS-backed GenServer with CRUD, reorder, pause/unpause, snapshot"
      contains: "defmodule AgentCom.RepoRegistry"
    - path: "lib/agent_com/endpoint.ex"
      provides: "HTTP admin routes for repo registry"
      contains: "repo-registry"
    - path: "lib/agent_com/validation/schemas.ex"
      provides: "Validation schema for post_repo HTTP body"
      contains: "post_repo"
  key_links:
    - from: "lib/agent_com/endpoint.ex"
      to: "lib/agent_com/repo_registry.ex"
      via: "HTTP routes call RepoRegistry functions"
      pattern: "AgentCom\\.RepoRegistry\\."
    - from: "lib/agent_com/application.ex"
      to: "lib/agent_com/repo_registry.ex"
      via: "Supervisor starts RepoRegistry before DashboardState"
      pattern: "AgentCom\\.RepoRegistry"
    - from: "lib/agent_com/dets_backup.ex"
      to: "lib/agent_com/repo_registry.ex"
      via: "DetsBackup includes :repo_registry in @tables"
      pattern: ":repo_registry"
---

<objective>
Build the RepoRegistry GenServer with DETS persistence, HTTP admin API, validation schemas, supervisor wiring, and DetsBackup integration.

Purpose: Establish the hub-side repo registry that all other Phase 23 work depends on. Follows the LlmRegistry pattern exactly (DETS-backed GenServer, HTTP CRUD, PubSub broadcasts, snapshot API).

Output: Working HTTP API for repo CRUD + reorder + pause/unpause, with DETS persistence and PubSub change broadcasts.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-multi-repo-registry-and-workspace-switching/23-RESEARCH.md

# Key reference files for patterns:
@lib/agent_com/llm_registry.ex
@lib/agent_com/application.ex
@lib/agent_com/dets_backup.ex
@lib/agent_com/endpoint.ex
@lib/agent_com/validation/schemas.ex
@test/support/dets_helpers.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: RepoRegistry GenServer with DETS persistence and PubSub</name>
  <files>lib/agent_com/repo_registry.ex</files>
  <action>
Create `lib/agent_com/repo_registry.ex` as a GenServer following the LlmRegistry pattern. Use a SINGLE DETS key (`:repos`) storing an ordered list of repo maps for atomic reordering.

**Repo entry shape:**
```elixir
%{
  id: "notno-AgentCom",           # Slug from normalized URL
  url: "https://github.com/notno/AgentCom",  # Normalized (no trailing .git or /)
  name: "AgentCom",               # Display name
  status: :active,                # :active | :paused
  added_at: 1707753600000,        # millisecond timestamp
  added_by: "admin"               # who added it
}
```

**Public API functions (8 total):**
- `start_link/1` -- GenServer startup
- `add_repo/1` -- Add repo, returns `{:ok, entry}` or `{:error, :already_exists}`
- `remove_repo/1` -- Remove by id, returns `:ok` or `{:error, :not_found}`
- `list_repos/0` -- Return full ordered list
- `move_up/1`, `move_down/1` -- Swap with neighbor, return `{:ok, new_list}`
- `set_status/2` -- Set `:active` or `:paused`, returns `:ok`
- `active_repo_ids/0` -- Return list of URLs for active repos (for scheduler filtering)
- `top_active_repo/0` -- Return `{:ok, repo}` or `:none` (for nil-repo inheritance)
- `snapshot/0` -- Return `%{repos: [...]}` for dashboard

**URL normalization (in private helpers):**
- Strip trailing whitespace, `/`, and `.git` suffix before storage and comparison.
- `url_to_id/1`: Strip protocol+host prefix, replace `/` with `-` to produce slug.

**DETS setup:** Open `:repo_registry` table in `init/1`. Path: `Path.join(data_dir(), "repo_registry.dets")`. Type: `:set`, auto_save: `5_000`.

**Reordering:** `move_up` swaps element at index `i` with `i-1`. `move_down` swaps `i` with `i+1`. No-op at boundaries. Use `List.replace_at/3` for swap.

**PubSub:** Broadcast `{:repo_registry_update, :changed}` on topic `"repo_registry"` after every mutation (add, remove, move, set_status).

**Terminate:** Close DETS table in `terminate/2`.

Reference the complete GenServer code in 23-RESEARCH.md Example 1 for the exact implementation pattern.
  </action>
  <verify>
`mix compile --no-deps-check` succeeds with no errors or warnings on repo_registry.ex.
  </verify>
  <done>
RepoRegistry GenServer module exists with all 9 public API functions, DETS persistence via single-key ordered list, URL normalization, priority reordering, pause/unpause status, and PubSub broadcasts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Supervisor, DetsBackup, HTTP routes, validation, and test helpers</name>
  <files>
lib/agent_com/application.ex
lib/agent_com/dets_backup.ex
lib/agent_com/endpoint.ex
lib/agent_com/validation/schemas.ex
test/support/dets_helpers.ex
  </files>
  <action>
**1. Supervisor wiring (application.ex):**
Add `{AgentCom.RepoRegistry, []}` to the children list BEFORE `{AgentCom.DashboardState, []}` and AFTER `{AgentCom.LlmRegistry, []}`. This ensures RepoRegistry is available when DashboardState takes its snapshot.

**2. DetsBackup integration (dets_backup.ex):**
Add `:repo_registry` to the `@tables` list (currently 9 tables, will be 10). This ensures the new DETS table gets backed up, compacted, and health-checked.

**3. HTTP admin routes (endpoint.ex):**
Add 7 routes following the LlmRegistry route pattern. Place them AFTER the LLM registry routes block and BEFORE the catch-all. Auth required on all routes.

```
GET    /api/admin/repo-registry          -- list all repos (ordered)
POST   /api/admin/repo-registry          -- add repo (validate body with :post_repo schema)
DELETE /api/admin/repo-registry/:repo_id -- remove repo
PUT    /api/admin/repo-registry/:repo_id/move-up   -- move up in priority
PUT    /api/admin/repo-registry/:repo_id/move-down  -- move down in priority
PUT    /api/admin/repo-registry/:repo_id/pause      -- set status to :paused
PUT    /api/admin/repo-registry/:repo_id/unpause    -- set status to :active
```

For POST, validate with `Validation.validate_http(:post_repo, conn.body_params)`. On success, call `RepoRegistry.add_repo(%{url: ..., name: ...})`. Return 201 on success, 409 on `:already_exists`.

For DELETE, return 200 on success, 404 on `:not_found`.

For move-up/move-down, return 200 with `%{"repos" => repos}`.

For pause/unpause, return 200 with `%{"status" => "paused"|"active"}`.

Update the `@moduledoc` route table to include the new routes.

**4. Validation schema (schemas.ex):**
Add `post_repo` to `@http_schemas`:
```elixir
post_repo: %{
  required: %{
    "url" => :string
  },
  optional: %{
    "name" => :string
  },
  description: "Register a new repository in the repo registry."
}
```

**5. Test helpers (dets_helpers.ex):**
Add `AgentCom.RepoRegistry` to the restart cycle in `DetsHelpers`, following the same pattern used for LlmRegistry (Supervisor.terminate_child/restart_child with try/catch).
  </action>
  <verify>
`mix compile --no-deps-check` succeeds. Verify the @tables list in dets_backup.ex has 10 entries. Verify endpoint.ex has repo-registry routes.
  </verify>
  <done>
RepoRegistry starts in supervisor tree, DETS table included in backup/compaction, 7 HTTP admin routes respond correctly, validation schema validates POST body, test helpers handle RepoRegistry restart.
  </done>
</task>

</tasks>

<verification>
1. `mix compile --no-deps-check` -- clean compilation, no warnings
2. Hub starts successfully with RepoRegistry in supervisor tree
3. POST /api/admin/repo-registry with `{"url": "https://github.com/test/repo"}` returns 201
4. GET /api/admin/repo-registry returns the repo in the list
5. PUT move-up/move-down changes position in list
6. PUT pause sets status to "paused", unpause sets to "active"
7. DELETE removes repo from list
8. DetsBackup.health_metrics() shows :repo_registry table
</verification>

<success_criteria>
- RepoRegistry GenServer compiles and starts in supervisor
- All 7 HTTP routes return expected status codes
- DETS persistence survives restart
- PubSub broadcasts on mutations
- DetsBackup includes new table
</success_criteria>

<output>
After completion, create `.planning/phases/23-multi-repo-registry-and-workspace-switching/23-01-SUMMARY.md`
</output>
