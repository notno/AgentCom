---
phase: 23-multi-repo-registry-and-workspace-switching
plan: 03
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - lib/agent_com/scheduler.ex
  - lib/agent_com/task_queue.ex
  - lib/agent_com/dashboard_state.ex
  - lib/agent_com/dashboard_socket.ex
  - lib/agent_com/dashboard.ex
autonomous: true

must_haves:
  truths:
    - "Scheduler skips tasks tagged with a paused repo's URL"
    - "Tasks with nil repo or a repo not in the registry are still schedulable (backward compat)"
    - "A task submitted without a repo field inherits the top-priority active repo URL"
    - "Dashboard shows the repo registry section with table of repos, priority order, status badges"
    - "Dashboard has add repo form, remove button, move-up/down buttons, and pause/unpause toggle"
    - "Dashboard repo registry updates in real-time via PubSub"
  artifacts:
    - path: "lib/agent_com/scheduler.ex"
      provides: "Repo-aware task filtering before match loop"
      contains: "active_repo"
    - path: "lib/agent_com/task_queue.ex"
      provides: "Nil-repo inheritance from top-priority active repo"
      contains: "top_active_repo"
    - path: "lib/agent_com/dashboard.ex"
      provides: "Repo Registry dashboard section"
      contains: "Repo Registry"
  key_links:
    - from: "lib/agent_com/scheduler.ex"
      to: "lib/agent_com/repo_registry.ex"
      via: "Scheduler calls active_repo_ids and list_repos for filtering"
      pattern: "RepoRegistry\\.active_repo"
    - from: "lib/agent_com/task_queue.ex"
      to: "lib/agent_com/repo_registry.ex"
      via: "Submit handler calls top_active_repo for nil-repo inheritance"
      pattern: "RepoRegistry\\.top_active_repo"
    - from: "lib/agent_com/dashboard_socket.ex"
      to: "lib/agent_com/repo_registry.ex"
      via: "PubSub subscription forwards repo_registry_update events"
      pattern: "repo_registry"
    - from: "lib/agent_com/dashboard_state.ex"
      to: "lib/agent_com/repo_registry.ex"
      via: "Snapshot includes RepoRegistry.snapshot()"
      pattern: "RepoRegistry\\.snapshot"
---

<objective>
Wire the RepoRegistry into the scheduler (paused-repo filtering), task queue (nil-repo inheritance), and dashboard (repo registry section with full CRUD controls).

Purpose: Complete the Phase 23 integration so the repo registry actively affects task scheduling, default repo assignment, and is visible/controllable from the dashboard.

Output: Scheduler respects repo pause status, tasks inherit top-priority repo, dashboard shows and controls the repo registry.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-multi-repo-registry-and-workspace-switching/23-RESEARCH.md
@.planning/phases/23-multi-repo-registry-and-workspace-switching/23-01-SUMMARY.md

# Key reference files:
@lib/agent_com/scheduler.ex
@lib/agent_com/task_queue.ex
@lib/agent_com/dashboard_state.ex
@lib/agent_com/dashboard_socket.ex
@lib/agent_com/dashboard.ex
@lib/agent_com/repo_registry.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scheduler repo filtering and TaskQueue nil-repo inheritance</name>
  <files>
lib/agent_com/scheduler.ex
lib/agent_com/task_queue.ex
  </files>
  <action>
**1. Scheduler paused-repo filtering (scheduler.ex):**

In `try_schedule_all/2`, after fetching `queued_tasks` from `TaskQueue.list(status: :queued)` (the non-empty agents branch, around line 277), add repo filtering before passing tasks to `do_match_loop`:

```elixir
# Phase 23: Filter out tasks for paused repos
active_repo_urls = AgentCom.RepoRegistry.active_repo_ids()
all_repo_urls =
  try do
    AgentCom.RepoRegistry.list_repos() |> Enum.map(& &1.url)
  rescue
    _ -> []
  end

schedulable_tasks =
  Enum.filter(queued_tasks, fn task ->
    repo = Map.get(task, :repo)
    cond do
      # nil repo = always schedulable (backward compat)
      is_nil(repo) -> true
      # Repo is active in registry = schedulable
      repo in active_repo_urls -> true
      # Repo is in registry but NOT active (paused) = skip
      repo in all_repo_urls -> false
      # Repo not in registry at all = schedulable (ad-hoc task)
      true -> true
    end
  end)
```

Replace `queued_tasks` with `schedulable_tasks` in the `do_match_loop` call on the line that currently reads `do_match_loop(queued_tasks, agents, endpoints, endpoint_resources, state)`.

Also update the telemetry measurement to use `length(schedulable_tasks)` instead of `length(queued_tasks)` for the `queued_tasks` metric, so dashboard stats reflect schedulable count.

Wrap RepoRegistry calls in try/rescue to handle the case where RepoRegistry is not yet started (backward compat during rolling deploys).

**2. TaskQueue nil-repo inheritance (task_queue.ex):**

In `handle_call({:submit, params}, _from, state)`, around line 244 where `repo` is extracted, add nil-repo resolution:

Find the line:
```elixir
repo: Map.get(params, :repo, Map.get(params, "repo", nil)),
```

Replace the repo assignment in the task map construction. Before building the task map, resolve the repo:

```elixir
raw_repo = Map.get(params, :repo, Map.get(params, "repo", nil))

# Phase 23: Inherit top-priority active repo when no explicit repo given
repo =
  if is_nil(raw_repo) or raw_repo == "" do
    case AgentCom.RepoRegistry.top_active_repo() do
      {:ok, top_repo} -> top_repo.url
      :none -> nil
    end
  else
    normalize_repo_url(raw_repo)
  end
```

Add a private helper at the bottom of the module:
```elixir
defp normalize_repo_url(url) when is_binary(url) do
  url
  |> String.trim()
  |> String.trim_trailing("/")
  |> String.trim_trailing(".git")
end
defp normalize_repo_url(url), do: url
```

Then use the resolved `repo` variable in the task map where `repo:` was previously assigned inline.

Wrap the `RepoRegistry.top_active_repo()` call in try/rescue returning `nil` on failure, so TaskQueue works even if RepoRegistry hasn't started.
  </action>
  <verify>
`mix compile --no-deps-check` succeeds. Scheduler's try_schedule_all filters by repo status. TaskQueue submit resolves nil repo to top active.
  </verify>
  <done>
Scheduler skips tasks for paused repos (tasks remain queued). Tasks with nil/empty repo inherit top-priority active repo at submit time. Backward compatible: nil-repo and unknown-repo tasks always schedulable.
  </done>
</task>

<task type="auto">
  <name>Task 2: DashboardState and DashboardSocket wiring for repo registry</name>
  <files>
lib/agent_com/dashboard_state.ex
lib/agent_com/dashboard_socket.ex
  </files>
  <action>
**1. DashboardState (dashboard_state.ex):**

Subscribe to PubSub topic `"repo_registry"` in `init/1`, alongside the existing `"llm_registry"` subscription.

Add a handler for repo_registry events (just like the llm_registry handler):
```elixir
def handle_info({:repo_registry_update, _detail}, state) do
  {:noreply, state}
end
```

In `handle_call(:snapshot, ...)`, add `repo_registry` to the snapshot. Following the llm_registry pattern:
```elixir
repo_registry =
  try do
    AgentCom.RepoRegistry.snapshot()
  rescue
    _ -> %{repos: []}
  end
```

Add `repo_registry: repo_registry` to the snapshot map (alongside `llm_registry: llm_registry`).

Update the Logger.info in init to include "repo_registry" in the topics list.

**2. DashboardSocket (dashboard_socket.ex):**

Subscribe to PubSub topic `"repo_registry"` in `init/1`.

Add a handler for forwarding repo_registry events to the browser:
```elixir
def handle_info({:repo_registry_update, detail}, state) do
  formatted = %{
    type: "repo_registry_update",
    detail: to_string(detail)
  }
  {:ok, %{state | pending_events: [formatted | state.pending_events]}}
end
```

Add handlers for dashboard commands (add_repo, remove_repo, move_up, move_down, pause_repo, unpause_repo):

```elixir
{:ok, %{"type" => "add_repo", "url" => url} = msg} ->
  name = Map.get(msg, "name", nil)
  case AgentCom.RepoRegistry.add_repo(%{url: url, name: name}) do
    {:ok, _repo} -> send_snapshot_refresh(state)
    {:error, :already_exists} -> send_error(state, "repo_already_exists")
  end

{:ok, %{"type" => "remove_repo", "repo_id" => repo_id}} ->
  AgentCom.RepoRegistry.remove_repo(repo_id)
  send_snapshot_refresh(state)

{:ok, %{"type" => "move_repo_up", "repo_id" => repo_id}} ->
  AgentCom.RepoRegistry.move_up(repo_id)
  send_snapshot_refresh(state)

{:ok, %{"type" => "move_repo_down", "repo_id" => repo_id}} ->
  AgentCom.RepoRegistry.move_down(repo_id)
  send_snapshot_refresh(state)

{:ok, %{"type" => "pause_repo", "repo_id" => repo_id}} ->
  AgentCom.RepoRegistry.set_status(repo_id, :paused)
  send_snapshot_refresh(state)

{:ok, %{"type" => "unpause_repo", "repo_id" => repo_id}} ->
  AgentCom.RepoRegistry.set_status(repo_id, :active)
  send_snapshot_refresh(state)
```

For the snapshot refresh pattern: after a command, push a fresh snapshot to the client. Use the same pattern as existing `request_snapshot`:
```elixir
snapshot = AgentCom.DashboardState.snapshot()
{:push, {:text, Jason.encode!(%{type: "snapshot", data: snapshot})}, state}
```

Each command clause should return `{:push, {:text, ...}, state}` with a fresh snapshot.
  </action>
  <verify>
`mix compile --no-deps-check` succeeds. DashboardState includes repo_registry in snapshot. DashboardSocket forwards events and handles commands.
  </verify>
  <done>
DashboardState snapshot includes repo_registry data. DashboardSocket subscribes to repo_registry PubSub, forwards update events, and handles add/remove/reorder/pause commands from the browser.
  </done>
</task>

<task type="auto">
  <name>Task 3: Dashboard repo registry UI section</name>
  <files>lib/agent_com/dashboard.ex</files>
  <action>
Add a "Repo Registry" section to the dashboard HTML, placed AFTER the LLM Registry section and BEFORE the Validation section. Follow the LLM Registry section pattern exactly (table layout, add form, action buttons).

**Section structure:**
```html
<div class="section">
  <h2>Repo Registry</h2>
  <div id="repo-registry">
    <!-- Table of repos with columns: Priority, Name, URL, Status, Actions -->
    <table>
      <thead>
        <tr>
          <th>#</th>
          <th>Name</th>
          <th>URL</th>
          <th>Status</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody id="repo-registry-body">
        <!-- Filled by JavaScript -->
      </tbody>
    </table>
    <!-- Add repo form -->
    <div class="add-form">
      <input id="repo-url-input" placeholder="https://github.com/owner/repo" />
      <input id="repo-name-input" placeholder="Display name (optional)" />
      <button onclick="addRepo()">Add Repo</button>
    </div>
  </div>
</div>
```

**JavaScript functions (inside the existing `<script>` block):**

`renderRepoRegistry(repos)`:
- Clear the tbody
- For each repo (with index for priority #):
  - Row with: priority number (1-based), name, URL (truncated if long), status badge (green "active" / amber "paused"), action buttons
  - Actions column: move-up arrow (disabled if first), move-down arrow (disabled if last), pause/unpause toggle button, remove button (red)
  - Status badge: `<span class="badge badge-ok">active</span>` or `<span class="badge badge-warning">paused</span>`

`addRepo()`:
- Read URL from `#repo-url-input`, name from `#repo-name-input`
- Send via dashboard WebSocket: `{ type: "add_repo", url: url, name: name || undefined }`
- Clear inputs after send

`removeRepo(repoId)`:
- Send: `{ type: "remove_repo", repo_id: repoId }`

`moveRepoUp(repoId)` / `moveRepoDown(repoId)`:
- Send: `{ type: "move_repo_up", repo_id: repoId }` / `{ type: "move_repo_down", repo_id: repoId }`

`pauseRepo(repoId)` / `unpauseRepo(repoId)`:
- Send: `{ type: "pause_repo", repo_id: repoId }` / `{ type: "unpause_repo", repo_id: repoId }`

**In the existing snapshot handler** (where `renderLlmRegistry` is called), add:
```javascript
if (data.repo_registry && data.repo_registry.repos) {
  renderRepoRegistry(data.repo_registry.repos);
}
```

**In the repo_registry_update event handler**, trigger a snapshot refresh (same as llm_registry_update pattern).

**CSS:** Use existing badge classes. No new CSS needed. Action buttons use existing button styling. Keep it simple and functional -- matches the LLM Registry section's visual pattern.
  </action>
  <verify>
`mix compile --no-deps-check` succeeds. Dashboard HTML includes Repo Registry section with table, add form, and action buttons.
  </verify>
  <done>
Dashboard shows Repo Registry section with priority-ordered table, status badges (active/paused), add repo form, and action buttons (move-up, move-down, pause/unpause, remove). Updates in real-time via PubSub-driven snapshot refresh.
  </done>
</task>

</tasks>

<verification>
1. `mix compile --no-deps-check` -- clean compilation
2. Scheduler skips paused-repo tasks (submit task with repo X, pause X, verify task stays queued)
3. Task submitted without repo inherits top-priority active repo URL
4. Dashboard shows Repo Registry section with add/remove/reorder/pause controls
5. PubSub events trigger dashboard refresh when repos are modified
6. Backward compatible: existing tasks with nil repo or unknown repo remain schedulable
</verification>

<success_criteria>
- Scheduler filters out paused-repo tasks
- TaskQueue resolves nil repo at submit time
- Dashboard renders repo registry with full CRUD controls
- Real-time PubSub updates work end-to-end
- All existing functionality unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/23-multi-repo-registry-and-workspace-switching/23-03-SUMMARY.md`
</output>
