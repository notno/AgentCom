---
phase: 26-claude-api-client
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/agent_com/claude_client.ex
  - lib/agent_com/claude_client/cli.ex
  - lib/agent_com/application.ex
autonomous: true

must_haves:
  truths:
    - "ClaudeClient GenServer starts in the supervision tree and accepts invocation calls"
    - "CLI invocations spawn claude -p via System.cmd with CLAUDECODE env unset and Task.async timeout"
    - "CostLedger budget is checked before every CLI invocation and invocation is recorded after"
    - "Large prompts are written to temp files to avoid the stdin >7000 char bug"
    - "set_hub_state/1 API allows HubFSM to update the budget-check state"
  artifacts:
    - path: "lib/agent_com/claude_client.ex"
      provides: "GenServer with public API (decompose_goal, verify_completion, identify_improvements, set_hub_state)"
      exports: ["start_link/1", "decompose_goal/2", "verify_completion/2", "identify_improvements/2", "set_hub_state/1"]
    - path: "lib/agent_com/claude_client/cli.ex"
      provides: "Low-level System.cmd wrapper with temp file prompt strategy and CLAUDECODE env unset"
      exports: ["invoke/3"]
    - path: "lib/agent_com/application.ex"
      provides: "ClaudeClient added to supervision tree after CostLedger"
  key_links:
    - from: "lib/agent_com/claude_client.ex"
      to: "lib/agent_com/cost_ledger.ex"
      via: "check_budget/1 before invoke, record_invocation/2 after"
      pattern: "CostLedger\\.check_budget|CostLedger\\.record_invocation"
    - from: "lib/agent_com/claude_client.ex"
      to: "lib/agent_com/claude_client/cli.ex"
      via: "Task.async wrapping Cli.invoke/3"
      pattern: "Cli\\.invoke"
    - from: "lib/agent_com/claude_client/cli.ex"
      to: "System.cmd"
      via: "System.cmd with env: [{\"CLAUDECODE\", nil}]"
      pattern: "System\\.cmd"
---

<objective>
Implement the ClaudeClient GenServer and CLI invocation module that form the hub's interface to the Claude Code CLI.

Purpose: The hub needs a single-process gateway for all LLM calls that enforces budget limits (via CostLedger), serializes CLI invocations, manages timeouts, and provides a clean API for downstream consumers (GoalDecomposer, VerificationLoop, ImprovementScanner).

Output: ClaudeClient GenServer with 3 public invoke methods + set_hub_state, and a Cli module that handles System.cmd execution with temp file prompts and timeout control.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-cost-control-infrastructure/25-01-SUMMARY.md
@.planning/phases/26-claude-api-client/26-RESEARCH.md

# Key reference files
@lib/agent_com/cost_ledger.ex
@lib/agent_com/application.ex
@lib/agent_com/config.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ClaudeClient GenServer with CostLedger integration</name>
  <files>lib/agent_com/claude_client.ex</files>
  <action>
Create `AgentCom.ClaudeClient` GenServer module with:

**State:** `%{cli_path: string, model: string, timeout_ms: integer, hub_state: atom}`
- `cli_path` from `Application.get_env(:agent_com, :claude_cli_path, "claude")`
- `model` from `Application.get_env(:agent_com, :claude_model, "sonnet")`
- `timeout_ms` from `Application.get_env(:agent_com, :claude_timeout_ms, 120_000)`
- `hub_state` defaults to `:executing`, updatable via `set_hub_state/1`

**Public API (5 functions):**

1. `start_link/1` - GenServer start with `name: __MODULE__`
2. `decompose_goal(goal, context)` - GenServer.call with `{:invoke, :decompose, %{goal: goal, context: context}}`. Returns `{:ok, [map()]} | {:error, term()}`. GenServer.call timeout = task timeout + 5000ms.
3. `verify_completion(goal, results)` - GenServer.call with `{:invoke, :verify, %{goal: goal, results: results}}`. Returns `{:ok, map()} | {:error, term()}`.
4. `identify_improvements(repo, diff)` - GenServer.call with `{:invoke, :identify_improvements, %{repo: repo, diff: diff}}`. Returns `{:ok, [map()]} | {:error, term()}`.
5. `set_hub_state(new_state)` - GenServer.call to update hub_state. Guard: `when new_state in [:executing, :improving, :contemplating]`.

**handle_call for {:invoke, prompt_type, params}:**

1. Call `AgentCom.CostLedger.check_budget(state.hub_state)` -- if `:budget_exhausted`, reply `{:error, :budget_exhausted}` immediately.
2. Record start time via `System.monotonic_time(:millisecond)`.
3. Spawn `Task.async(fn -> AgentCom.ClaudeClient.Cli.invoke(prompt_type, params, state) end)`.
4. `Task.yield(task, state.timeout_ms) || Task.shutdown(task)` -- if `nil`, result is `{:error, :timeout}`.
5. Calculate duration_ms from start time.
6. ALWAYS call `AgentCom.CostLedger.record_invocation(state.hub_state, %{duration_ms: duration, prompt_type: prompt_type})` -- even on errors and timeouts.
7. Emit telemetry: `:telemetry.execute([:agent_com, :hub, :claude_call], %{duration_ms: duration, count: 1}, %{hub_state: state.hub_state, prompt_type: prompt_type})`.
8. Reply with result.

**handle_call for {:set_hub_state, new_state}:**
Update state map and reply `:ok`.

Follow existing GenServer patterns: `use GenServer`, `require Logger`, `Logger.metadata(module: __MODULE__)` in init, `Logger.info("claude_client_started")`.

Add @moduledoc with usage examples and default configuration table.
  </action>
  <verify>
`mix compile --warnings-as-errors` succeeds. Module defines all 5 public functions. handle_call matches on {:invoke, _, _} and {:set_hub_state, _}.
  </verify>
  <done>ClaudeClient GenServer compiles with full public API, CostLedger budget check before every invoke, CostLedger record after every invoke (including errors), Task.async timeout control, and telemetry emission.</done>
</task>

<task type="auto">
  <name>Task 2: Implement Cli module and add ClaudeClient to supervision tree</name>
  <files>lib/agent_com/claude_client/cli.ex, lib/agent_com/application.ex</files>
  <action>
**Part A: Create `AgentCom.ClaudeClient.Cli` module**

Create `lib/agent_com/claude_client/cli.ex` with:

1. `invoke(prompt_type, params, state)` -- the main entry point called by the GenServer's Task.async.

2. Build prompt by calling `AgentCom.ClaudeClient.Prompt.build(prompt_type, params)`. (Prompt module will exist in Plan 02. For now, create a temporary `build/2` that returns a placeholder string so the module compiles. Mark with `# TODO: Plan 26-02 provides real implementation`.)

3. Write prompt to temp file:
   ```elixir
   defp write_temp_prompt(prompt) do
     tmp_dir = System.tmp_dir!()
     path = Path.join(tmp_dir, "claude_prompt_#{System.unique_integer([:positive])}.md")
     File.write!(path, prompt)
     path
   end
   ```

4. Execute System.cmd:
   ```elixir
   args = [
     "-p", "Read and follow the instructions in #{tmp_path}",
     "--output-format", "json",
     "--model", state.model,
     "--no-session-persistence"
   ]

   {output, exit_code} = System.cmd(state.cli_path, args,
     env: [{"CLAUDECODE", nil}],
     stderr_to_stdout: true
   )
   ```

5. Parse response by calling `AgentCom.ClaudeClient.Response.parse(output, exit_code, prompt_type)`. (Response module will exist in Plan 02. For now, create a temporary `parse/3` that returns `{:ok, %{raw: output}}` so the module compiles. Mark with `# TODO: Plan 26-02 provides real implementation`.)

6. Cleanup: Use `try/after` to ensure `File.rm(tmp_path)` always runs.

7. Add `@moduledoc` explaining the temp file strategy and why CLAUDECODE must be unset.

**Part B: Create temporary stub modules (Prompt and Response)**

Create `lib/agent_com/claude_client/prompt.ex` with a stub `build/2` function:
```elixir
defmodule AgentCom.ClaudeClient.Prompt do
  @moduledoc "Prompt template builder. Implemented in Plan 26-02."
  def build(_prompt_type, _params), do: "placeholder prompt"
end
```

Create `lib/agent_com/claude_client/response.ex` with a stub `parse/3` function:
```elixir
defmodule AgentCom.ClaudeClient.Response do
  @moduledoc "Response parser. Implemented in Plan 26-02."
  def parse(raw_output, _exit_code, _prompt_type), do: {:ok, %{raw: raw_output}}
end
```

**Part C: Add ClaudeClient to supervision tree**

In `lib/agent_com/application.ex`, add `{AgentCom.ClaudeClient, []}` to the children list AFTER `{AgentCom.CostLedger, []}` and BEFORE `{AgentCom.Auth, []}`. This ensures CostLedger is started before ClaudeClient tries to check budgets.
  </action>
  <verify>
`mix compile --warnings-as-errors` succeeds. `grep "ClaudeClient" lib/agent_com/application.ex` shows it in the children list. `ls lib/agent_com/claude_client/` shows cli.ex, prompt.ex, response.ex. Temp file creation and cleanup can be verified by reading the try/after pattern in cli.ex.
  </verify>
  <done>Cli module spawns claude -p via System.cmd with CLAUDECODE unset, temp file prompt strategy, and try/after cleanup. Stub Prompt and Response modules compile. ClaudeClient is in the supervision tree after CostLedger.</done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` -- all 4 modules compile cleanly
2. `grep -r "check_budget" lib/agent_com/claude_client.ex` -- budget check present
3. `grep -r "record_invocation" lib/agent_com/claude_client.ex` -- invocation recording present
4. `grep -r "CLAUDECODE" lib/agent_com/claude_client/cli.ex` -- env unset present
5. `grep -r "ClaudeClient" lib/agent_com/application.ex` -- in supervision tree
6. `grep -r "Task.async" lib/agent_com/claude_client.ex` -- timeout control present
</verification>

<success_criteria>
- ClaudeClient GenServer compiles and is in supervision tree
- Every invoke path checks CostLedger budget first and records invocation after
- CLI invocation uses System.cmd with CLAUDECODE=nil, temp file prompts, Task.async timeout
- set_hub_state/1 API exists for future HubFSM integration
- Stub Prompt and Response modules allow compilation without Plan 02
</success_criteria>

<output>
After completion, create `.planning/phases/26-claude-api-client/26-01-SUMMARY.md`
</output>
