---
phase: 26-claude-api-client
plan: 02
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - lib/agent_com/claude_client/prompt.ex
  - lib/agent_com/claude_client/response.ex
autonomous: true

must_haves:
  truths:
    - "Prompt.build/2 produces structured prompts for :decompose, :verify, and :identify_improvements use cases"
    - "Prompts instruct Claude to respond with XML wrapped in specific root tags (<tasks>, <verification>, <improvements>)"
    - "Response.parse/3 extracts XML from JSON wrapper output and parses into typed Elixir maps"
    - "Response parsing handles edge cases: empty output, non-zero exit code, malformed JSON, missing XML tags, markdown fences"
  artifacts:
    - path: "lib/agent_com/claude_client/prompt.ex"
      provides: "Prompt template builder for 3 use cases (decompose, verify, identify_improvements)"
      exports: ["build/2"]
    - path: "lib/agent_com/claude_client/response.ex"
      provides: "Response parser handling JSON wrapper and XML inner content extraction"
      exports: ["parse/3"]
  key_links:
    - from: "lib/agent_com/claude_client/cli.ex"
      to: "lib/agent_com/claude_client/prompt.ex"
      via: "Prompt.build(prompt_type, params) called in invoke/3"
      pattern: "Prompt\\.build"
    - from: "lib/agent_com/claude_client/cli.ex"
      to: "lib/agent_com/claude_client/response.ex"
      via: "Response.parse(output, exit_code, prompt_type) called in invoke/3"
      pattern: "Response\\.parse"
    - from: "lib/agent_com/claude_client/response.ex"
      to: "Jason"
      via: "Jason.decode for JSON wrapper parsing"
      pattern: "Jason\\.decode"
---

<objective>
Implement the Prompt template builder and Response parser modules that give ClaudeClient its structured I/O capabilities.

Purpose: The hub's three core LLM operations (decompose goals, verify completion, identify improvements) each need a carefully constructed prompt that produces parseable output, and a parser that handles the JSON wrapper from `--output-format json` plus the XML inner content. These modules replace the stubs created in Plan 26-01.

Output: Full Prompt module with 3 template functions, full Response module with JSON+XML parsing pipeline.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-claude-api-client/26-01-SUMMARY.md
@.planning/phases/26-claude-api-client/26-RESEARCH.md

# Key reference files
@lib/agent_com/claude_client.ex
@lib/agent_com/claude_client/cli.ex
@lib/agent_com/xml/parser.ex
@lib/agent_com/xml/xml.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Prompt template builder</name>
  <files>lib/agent_com/claude_client/prompt.ex</files>
  <action>
Replace the stub `AgentCom.ClaudeClient.Prompt` module with the full implementation.

**Module functions (all prompt templates as module functions, not external files):**

1. `build(:decompose, %{goal: goal, context: context})` -- Produces a prompt that:
   - Describes the agent's role as a goal decomposer
   - Embeds the goal (title, description, success criteria) in `<goal>` XML tags
   - Embeds context (repo name, relevant files, constraints) in `<context>` XML tags
   - Instructs Claude to respond with a `<tasks>` root element containing 3-8 `<task>` children
   - Each `<task>` must have: `<title>`, `<description>`, `<success-criteria>`, `<depends-on>` (comma-separated task indices, or empty)
   - Instructs to use elephant carpaccio slicing (small vertical slices)
   - Instructs to validate referenced files exist before including them

2. `build(:verify, %{goal: goal, results: results})` -- Produces a prompt that:
   - Describes the agent's role as a completion verifier
   - Embeds the original goal (title, description, success criteria) in `<goal>` tags
   - Embeds task results (what was done, files modified, test outcomes) in `<results>` tags
   - Instructs Claude to respond with a `<verification>` root element containing:
     - `<verdict>` -- "pass" or "fail"
     - `<reasoning>` -- explanation of the verdict
     - `<gaps>` -- list of `<gap>` elements (empty if pass), each with `<description>` and `<severity>`

3. `build(:identify_improvements, %{repo: repo, diff: diff})` -- Produces a prompt that:
   - Describes the agent's role as a codebase improvement identifier
   - Embeds repo context (name, description, tech stack) in `<repo>` tags
   - Embeds the git diff in `<diff>` tags (or summary of recent changes)
   - Instructs Claude to respond with an `<improvements>` root element containing `<improvement>` children
   - Each `<improvement>` must have: `<title>`, `<description>`, `<category>` (refactor|test|docs|dependency|performance), `<effort>` (small|medium|large), `<files>` (affected file paths)

**Helper functions:**
- `defp goal_to_xml(goal)` -- Format goal map/struct as XML text for embedding in prompt. Handle both map keys (string or atom) gracefully.
- `defp results_to_xml(results)` -- Format results list/map as XML text.
- `defp repo_to_xml(repo)` -- Format repo info as XML text.

**Conventions:**
- All prompts end with a clear instruction: "Respond ONLY with the XML. Do not include any text before or after the XML."
- Prompts use heredoc strings for readability
- Add @moduledoc explaining the 3 use cases and expected response formats
- Add @spec for build/2: `@spec build(atom(), map()) :: String.t()`
  </action>
  <verify>
`mix compile --warnings-as-errors` succeeds. `Prompt.build(:decompose, %{goal: %{title: "test"}, context: %{}})` returns a string containing "&lt;goal&gt;" and "Respond ONLY with the XML". Same check for :verify and :identify_improvements.
  </verify>
  <done>Prompt module produces structured prompts for all 3 use cases. Each prompt instructs Claude to respond with a specific XML root element. Helper functions format input data as embedded XML.</done>
</task>

<task type="auto">
  <name>Task 2: Implement Response parser with JSON wrapper and XML extraction</name>
  <files>lib/agent_com/claude_client/response.ex</files>
  <action>
Replace the stub `AgentCom.ClaudeClient.Response` module with the full implementation.

**Main parse function:**

`parse(raw_output, exit_code, prompt_type)`:

1. Non-zero exit code: return `{:error, {:exit_code, exit_code}}`
2. Empty output (empty string or whitespace-only): return `{:error, :empty_response}`
3. Try JSON decode via `Jason.decode(raw_output)`:
   - If `{:ok, %{"result" => result}}` where result is a string: call `parse_inner(result, prompt_type)`
   - If `{:ok, %{"result" => %{"content" => [%{"text" => text} | _]}}}`: call `parse_inner(text, prompt_type)` (alternate nesting)
   - If `{:ok, other}`: return `{:error, {:unexpected_format, other}}`
   - If `{:error, _}`: try `parse_inner(raw_output, prompt_type)` as fallback (maybe it's plain text from `--output-format text`)

**Inner parse functions (per prompt type):**

`parse_inner(text, :decompose)`:
- Extract XML block between `<tasks>` and `</tasks>` using `extract_xml_block/2`
- Parse each `<task>` child element using regex or simple XML walking
- Return `{:ok, tasks}` where each task is a map with keys: `:title`, `:description`, `:success_criteria`, `:depends_on` (list of integers)

`parse_inner(text, :verify)`:
- Extract XML block between `<verification>` and `</verification>`
- Parse `<verdict>`, `<reasoning>`, and `<gaps>` (list of gap maps)
- Return `{:ok, %{verdict: :pass | :fail, reasoning: string, gaps: [map()]}}`

`parse_inner(text, :identify_improvements)`:
- Extract XML block between `<improvements>` and `</improvements>`
- Parse each `<improvement>` child element
- Return `{:ok, improvements}` where each improvement is a map with keys: `:title`, `:description`, `:category`, `:effort`, `:files`

**XML extraction helper:**

`extract_xml_block(text, root_tag)`:
- Strip markdown code fences if present: `Regex.replace(~r/` `` "`(?:xml)?\n?/, text, "")`
- Find content matching `<{root_tag}...>...</{root_tag}>` using regex with `/s` (dotall) flag
- Return `{:ok, xml_block}` or `{:error, :not_found}`

**XML element parsing helper:**

`extract_child_text(xml, tag)`:
- Find text content between `<{tag}>` and `</{tag}>` tags
- Return the trimmed text or nil if not found

`extract_all_elements(xml, tag)`:
- Find all occurrences of `<{tag}>...</{tag}>` blocks
- Return list of XML strings

**Error type consistency:**
All error returns use tagged tuples:
- `{:error, :empty_response}` -- empty CLI output
- `{:error, {:exit_code, integer}}` -- non-zero exit
- `{:error, {:unexpected_format, term}}` -- JSON structure mismatch
- `{:error, {:parse_error, string}}` -- XML extraction or parsing failure

Add @moduledoc documenting the JSON wrapper structure, error types, and the parsing pipeline (JSON wrapper -> XML extraction -> typed maps).
  </action>
  <verify>
`mix compile --warnings-as-errors` succeeds. Response module handles all error paths (empty, non-zero exit, bad JSON, missing XML tags). Type specs present for parse/3.
  </verify>
  <done>Response module parses JSON wrapper from --output-format json, extracts XML inner content, and produces typed Elixir maps for all 3 prompt types. All error paths return consistent tagged tuples.</done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` -- all modules compile cleanly
2. Prompt.build/2 returns strings containing expected XML instruction tags for each prompt type
3. Response.parse/3 handles: empty string, non-zero exit code, valid JSON with result, invalid JSON fallback
4. Response error types are consistent tagged tuples
5. No new dependencies added (Jason and Saxy already in deps)
</verification>

<success_criteria>
- Prompt module has build/2 clauses for :decompose, :verify, :identify_improvements
- Each prompt instructs Claude to produce XML with a specific root tag
- Response module parses JSON wrapper and extracts XML inner content
- Response handles all error cases (empty, exit code, bad JSON, missing XML, malformed XML)
- Full integration: Cli.invoke calls Prompt.build, then Response.parse (no more stubs)
</success_criteria>

<output>
After completion, create `.planning/phases/26-claude-api-client/26-02-SUMMARY.md`
</output>
