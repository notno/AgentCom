---
phase: 26-claude-api-client
plan: 03
type: tdd
wave: 3
depends_on: ["26-01", "26-02"]
files_modified:
  - test/agent_com/claude_client_test.exs
  - test/agent_com/claude_client/prompt_test.exs
  - test/agent_com/claude_client/response_test.exs
autonomous: true

must_haves:
  truths:
    - "Prompt tests verify build/2 produces correct XML instruction tags for all 3 use cases"
    - "Response tests verify JSON wrapper parsing, XML extraction, and error handling for all edge cases"
    - "Integration tests verify CostLedger budget check blocks invocations when budget exhausted"
    - "All tests pass with mix test"
  artifacts:
    - path: "test/agent_com/claude_client_test.exs"
      provides: "GenServer integration tests (budget gating, set_hub_state, telemetry)"
    - path: "test/agent_com/claude_client/prompt_test.exs"
      provides: "Unit tests for Prompt.build/2 template output"
    - path: "test/agent_com/claude_client/response_test.exs"
      provides: "Unit tests for Response.parse/3 with all error paths"
  key_links:
    - from: "test/agent_com/claude_client_test.exs"
      to: "lib/agent_com/claude_client.ex"
      via: "Tests GenServer public API with mocked CLI"
      pattern: "ClaudeClient\\."
---

<objective>
Write comprehensive tests for the ClaudeClient modules using TDD methodology.

Purpose: Verify that prompt templates produce correct output, response parsing handles all edge cases, and the GenServer correctly integrates CostLedger budget gating. Since the actual Claude CLI cannot be called in tests, focus on unit testing Prompt and Response modules directly, and testing the GenServer's CostLedger integration by overriding cli_path to a non-existent binary (which will produce a known error).

Output: Test suite covering Prompt templates, Response parsing, and GenServer budget integration.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/26-claude-api-client/26-01-SUMMARY.md
@.planning/phases/26-claude-api-client/26-02-SUMMARY.md

# Source files under test
@lib/agent_com/claude_client.ex
@lib/agent_com/claude_client/cli.ex
@lib/agent_com/claude_client/prompt.ex
@lib/agent_com/claude_client/response.ex

# Test support
@test/support/dets_helpers.ex
</context>

<feature>
  <name>ClaudeClient Test Suite</name>
  <files>test/agent_com/claude_client_test.exs, test/agent_com/claude_client/prompt_test.exs, test/agent_com/claude_client/response_test.exs</files>
  <behavior>
  **Prompt.build/2 tests:**
  - build(:decompose, %{goal: goal, context: context}) -> string containing "&lt;goal&gt;", "&lt;tasks&gt;" instruction, and "Respond ONLY with the XML"
  - build(:verify, %{goal: goal, results: results}) -> string containing "&lt;goal&gt;", "&lt;verification&gt;" instruction
  - build(:identify_improvements, %{repo: repo, diff: diff}) -> string containing "&lt;repo&gt;", "&lt;improvements&gt;" instruction
  - build/2 with missing map keys -> produces prompt without crashing (graceful handling)

  **Response.parse/3 tests:**
  - parse("", 0, :decompose) -> {:error, :empty_response}
  - parse(anything, 1, any_type) -> {:error, {:exit_code, 1}}
  - parse(valid_json_with_tasks_xml, 0, :decompose) -> {:ok, [task_maps]}
  - parse(valid_json_with_verification_xml, 0, :verify) -> {:ok, %{verdict: :pass, ...}}
  - parse(valid_json_with_improvements_xml, 0, :identify_improvements) -> {:ok, [improvement_maps]}
  - parse(valid_json_no_xml_tags, 0, :decompose) -> {:error, {:parse_error, _}}
  - parse(invalid_json_plain_xml, 0, :decompose) -> {:ok, _} (fallback to plain text parsing)
  - parse(json_with_markdown_fenced_xml, 0, :decompose) -> {:ok, _} (strips fences)
  - parse(json_with_result_content_nesting, 0, :decompose) -> {:ok, _} (alternate JSON structure)

  **GenServer integration tests (ClaudeClient):**
  - budget_exhausted returns {:error, :budget_exhausted} without invoking CLI
  - set_hub_state/1 changes the state used for budget checks
  - GenServer starts via start_link and accepts calls
  </behavior>
  <implementation>
  Create 3 test files. The Prompt and Response tests are pure unit tests (no GenServer needed). The GenServer integration tests need CostLedger running (use DetsHelpers for DETS isolation) and set cli_path to a non-existent binary so System.cmd fails predictably.

  For Response tests, construct canned JSON strings that mimic --output-format json output. Each canned string wraps XML content inside a JSON "result" field. Example: a JSON object with result containing XML with root element matching the prompt type (tasks, verification, improvements).

  Use `async: false` for GenServer tests since they share global state.
  Use `async: true` for Prompt and Response unit tests since they are stateless.
  </implementation>
</feature>

<verification>
1. `mix test test/agent_com/claude_client_test.exs test/agent_com/claude_client/prompt_test.exs test/agent_com/claude_client/response_test.exs` -- all tests pass
2. Test count >= 15 (covering all prompt types, response edge cases, and GenServer integration)
3. No warnings from compilation
</verification>

<success_criteria>
- All Prompt.build/2 variants tested for correct XML instruction tags
- All Response.parse/3 error paths tested (empty, exit code, bad JSON, missing XML, markdown fences)
- All Response.parse/3 success paths tested for each prompt type
- GenServer budget gating tested via CostLedger integration
- All tests pass with `mix test`
</success_criteria>

<output>
After completion, create `.planning/phases/26-claude-api-client/26-03-SUMMARY.md`
</output>
