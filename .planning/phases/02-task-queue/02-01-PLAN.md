---
phase: 02-task-queue
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/agent_com/task_queue.ex
  - lib/agent_com/application.ex

autonomous: true

must_haves:
  truths:
    - "Tasks submitted to TaskQueue persist across hub restarts (DETS-backed)"
    - "Higher-priority tasks dequeue before lower-priority tasks regardless of creation order"
    - "Failed tasks retry up to max_retries then move to dead-letter DETS table"
    - "Overdue assigned tasks are reclaimed by periodic sweep and returned to queue"
    - "Task assignment uses generation-based fencing -- stale completions are rejected"
    - "DETS is explicitly synced after every task status mutation"
  artifacts:
    - path: "lib/agent_com/task_queue.ex"
      provides: "GenServer with DETS-backed task queue, priority lanes, retry, dead-letter, sweep, generation fencing"
      contains: "defmodule AgentCom.TaskQueue"
    - path: "lib/agent_com/application.ex"
      provides: "Supervisor registration for TaskQueue GenServer"
      contains: "AgentCom.TaskQueue"
  key_links:
    - from: "lib/agent_com/task_queue.ex"
      to: "priv/task_queue.dets"
      via: "DETS open_file in init/1, sync after every mutation"
      pattern: "dets.sync"
    - from: "lib/agent_com/task_queue.ex"
      to: "priv/task_dead_letter.dets"
      via: "DETS open_file in init/1 for dead-letter storage"
      pattern: "task_dead_letter"
    - from: "lib/agent_com/task_queue.ex"
      to: "Phoenix.PubSub"
      via: "Broadcast task events on tasks topic"
      pattern: "PubSub.broadcast.*tasks"
    - from: "lib/agent_com/application.ex"
      to: "lib/agent_com/task_queue.ex"
      via: "Supervisor child specification"
      pattern: "AgentCom.TaskQueue"
---

<objective>
Build the core TaskQueue GenServer module -- the persistent, priority-ordered, crash-safe task queue that is the foundation of Phase 2.

Purpose: All seven Phase 2 requirements (TASK-01 through TASK-06 + API-02) depend on this module existing. It provides the complete task lifecycle: submit, assign, complete, fail, retry, dead-letter, and overdue reclamation. Socket and HTTP integration (Plan 02) wire into this module's public API.

Output: New `lib/agent_com/task_queue.ex` GenServer module registered in the supervision tree via `application.ex`.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-task-queue/02-RESEARCH.md
@lib/agent_com/application.ex
@lib/agent_com/config.ex
@lib/agent_com/mailbox.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TaskQueue GenServer with full task lifecycle</name>
  <files>lib/agent_com/task_queue.ex</files>
  <action>
Create new file `lib/agent_com/task_queue.ex` implementing `AgentCom.TaskQueue` as a GenServer. Follow the established DETS-backed GenServer pattern used by Mailbox, Config, and other modules in the codebase.

**Module structure:**

1. **Module attributes and DETS setup:**
   - `@tasks_table :task_queue` and `@dead_letter_table :task_dead_letter`
   - `@sweep_interval_ms 30_000` (30-second overdue sweep, matches Reaper pattern)
   - `@default_max_retries 3`
   - `@priority_map %{"urgent" => 0, "high" => 1, "normal" => 2, "low" => 3}`
   - `@history_cap 50` (max history entries per task, per research Pitfall 7)

2. **`init/1`:**
   - Open two DETS tables: `:task_queue` at `priv/task_queue.dets` and `:task_dead_letter` at `priv/task_dead_letter.dets`. Use `type: :set, auto_save: 5_000` (matching existing DETS modules).
   - Call `File.mkdir_p!/1` on the priv directory path before opening (matching mailbox.ex pattern).
   - Rebuild in-memory priority index from DETS: scan all tasks with `status: :queued`, create sorted list of `{priority, created_at, task_id}` tuples.
   - Schedule first overdue sweep with `Process.send_after(self(), :sweep_overdue, @sweep_interval_ms)`.
   - State map: `%{priority_index: [...], sweep_interval_ms: @sweep_interval_ms}`.

3. **`terminate/2`:** Close both DETS tables with `:dets.close/1`.

4. **Public API functions** (each delegates to GenServer.call):
   - `submit(params)` -- Submit a new task to the queue. `params` is a map with keys: `description` (required), `priority` (optional, default "normal"), `metadata` (optional, default %{}), `max_retries` (optional, default 3), `complete_by` (optional, default nil), `submitted_by` (optional, default "unknown"). Returns `{:ok, task}`.
   - `get(task_id)` -- Get a task by ID. Returns `{:ok, task}` or `{:error, :not_found}`. Checks both main and dead-letter tables.
   - `list(opts \\ [])` -- List tasks with optional filters. `opts` can include `status:`, `priority:`, `assigned_to:`. Returns list of tasks.
   - `list_dead_letter()` -- List all dead-letter tasks. Returns list of tasks.
   - `dequeue_next(opts \\ [])` -- Get highest-priority queued task. Returns `{:ok, task}` or `{:error, :empty}`. Does NOT assign the task (that's `assign_task/3`).
   - `assign_task(task_id, agent_id, opts \\ [])` -- Assign a queued task to an agent. Bumps generation, sets `complete_by` from opts if provided. Returns `{:ok, task}` or `{:error, reason}`.
   - `complete_task(task_id, generation, result_params)` -- Mark task as completed. `result_params` includes `result` map and `tokens_used`. Validates generation match (TASK-05 fencing). Returns `{:ok, task}` or `{:error, :stale_generation | :invalid_state | :not_found}`.
   - `fail_task(task_id, generation, error)` -- Mark task as failed. Validates generation. Handles retry (re-queue with bumped generation and retry_count) or dead-letter (if retries exhausted). Returns `{:ok, :retried, task}` or `{:ok, :dead_letter, task}` or `{:error, reason}`.
   - `update_progress(task_id)` -- Update `updated_at` timestamp on an assigned task to prevent overdue sweep. Fire-and-forget via GenServer.cast. No generation check needed (progress is informational).
   - `recover_task(task_id)` -- Handle sidecar recovery. Check task state: if task is `:assigned` to the requesting agent, respond with `:continue` (task is still valid). Otherwise respond with `:reassign`. Returns `{:ok, :continue, task}` or `{:ok, :reassign}` or `{:error, :not_found}`.
   - `retry_dead_letter(task_id)` -- Move a dead-letter task back to the queue with reset retry count. Returns `{:ok, task}` or `{:error, :not_found}`.
   - `tasks_assigned_to(agent_id)` -- Return all tasks currently assigned to an agent. For Phase 3 FSM integration.
   - `stats()` -- Return queue statistics: counts by status, counts by priority. For dashboard.

5. **GenServer handlers** (`handle_call`, `handle_cast`, `handle_info`):

   **`handle_call({:submit, params}, ...)`:**
   - Generate task ID: `"task-" <> Base.encode16(:crypto.strong_rand_bytes(8), case: :lower)`
   - Build task map with all fields from research Pattern 1 (id, description, metadata, priority, status: :queued, assigned_to: nil, generation: 0, retry_count: 0, max_retries, complete_by, result: nil, tokens_used: nil, submitted_by, created_at, updated_at, history: [{:queued, now, "submitted"}])
   - Convert priority string to integer using `@priority_map` (default to 2 if unknown)
   - Persist to DETS: `:dets.insert(@tasks_table, {task.id, task})` then `:dets.sync(@tasks_table)` (TASK-06)
   - Add to priority index: insert `{priority, created_at, task_id}` into sorted list
   - Broadcast event: `broadcast_task_event(:task_submitted, task)`
   - Return `{:reply, {:ok, task}, new_state}`

   **`handle_call({:get, task_id}, ...)`:**
   - Look up in main table first: `:dets.lookup(@tasks_table, task_id)`
   - If not found, look up in dead-letter table: `:dets.lookup(@dead_letter_table, task_id)`
   - Return `{:ok, task}` or `{:error, :not_found}`

   **`handle_call({:list, opts}, ...)`:**
   - Use `:dets.foldl/3` on `@tasks_table` to collect tasks matching filters
   - Filter by status, priority, assigned_to from opts
   - Return list sorted by priority then created_at

   **`handle_call(:list_dead_letter, ...)`:**
   - Use `:dets.foldl/3` on `@dead_letter_table` to collect all tasks

   **`handle_call(:dequeue_next, ...)`:**
   - Take head of priority_index (first element = highest priority, earliest created)
   - Look up full task from DETS
   - Return `{:ok, task}` or `{:error, :empty}`
   - Do NOT remove from index yet (assign_task does that)

   **`handle_call({:assign_task, task_id, agent_id, opts}, ...)`:**
   - Look up task, verify status is `:queued`
   - Update task: status -> :assigned, assigned_to -> agent_id, assigned_at -> now, generation + 1, complete_by from opts, updated_at -> now
   - Add history entry: `{:assigned, now, %{agent_id: agent_id, generation: task.generation + 1}}`
   - Persist and sync DETS (TASK-06)
   - Remove `{priority, created_at, task_id}` from priority_index
   - Broadcast event
   - Return `{:ok, updated_task}`

   **`handle_call({:complete_task, task_id, generation, result_params}, ...)`:**
   - Look up task, verify status is `:assigned`
   - Verify generation matches (TASK-05 fencing): if `task.generation != generation`, return `{:error, :stale_generation}`
   - Update task: status -> :completed, result -> result_params.result, tokens_used -> result_params.tokens_used (API-02), updated_at -> now
   - Add history entry: `{:completed, now, %{tokens_used: tokens_used}}`
   - Persist and sync DETS
   - Broadcast event
   - Return `{:ok, updated_task}`

   **`handle_call({:fail_task, task_id, generation, error}, ...)`:**
   - Look up task, verify status is `:assigned`
   - Verify generation matches (TASK-05)
   - If `retry_count + 1 >= max_retries`: move to dead-letter
     - Update task: status -> :dead_letter, last_error -> error, retry_count + 1, updated_at -> now
     - Delete from `@tasks_table`, insert into `@dead_letter_table`, sync both
     - Broadcast `:task_dead_letter` event
     - Return `{:ok, :dead_letter, updated_task}`
   - Else: retry
     - Update task: status -> :queued, assigned_to -> nil, assigned_at -> nil, retry_count + 1, generation + 1, last_error -> error, updated_at -> now
     - Persist and sync DETS
     - Re-add to priority_index
     - Broadcast `:task_retried` event
     - Return `{:ok, :retried, updated_task}`

   **`handle_cast({:update_progress, task_id}, ...)`:**
   - Look up task, if status is `:assigned`, update `updated_at` to now
   - Persist and sync (lightweight -- just timestamp update)
   - No broadcast (fire-and-forget, per 01-02 decision)

   **`handle_call({:recover_task, task_id}, ...)`:**
   - Look up task
   - If `:assigned` -> return `{:ok, :continue, task}` (Phase 2: agent can continue working)
   - Otherwise -> return `{:ok, :reassign}`

   **`handle_call({:retry_dead_letter, task_id}, ...)`:**
   - Look up in dead-letter table
   - Reset: status -> :queued, retry_count -> 0, assigned_to -> nil, generation + 1, updated_at -> now
   - Delete from dead-letter table, insert into main table, sync both
   - Add to priority_index
   - Broadcast event
   - Return `{:ok, updated_task}`

   **`handle_info(:sweep_overdue, state)`:**
   - Get current time
   - Use `:dets.foldl/3` on `@tasks_table` to find tasks where: status == :assigned AND complete_by != nil AND complete_by < now
   - Note: Also check `updated_at` -- if task has received recent progress (updated_at within a grace window), consider it still active. Use `complete_by` as the hard deadline (per research recommendation: progress updates reset `updated_at`, sweep checks `complete_by` as absolute deadline).
   - For each overdue task: bump generation, reset to :queued, clear assigned_to/assigned_at, add history entry `{:reclaimed, now, "overdue"}`, persist and sync, re-add to priority_index, broadcast `:task_reclaimed` event
   - Log each reclamation with `Logger.warning`
   - Reschedule sweep: `Process.send_after(self(), :sweep_overdue, state.sweep_interval_ms)`

6. **Private helpers:**
   - `generate_task_id/0` -- `"task-" <> Base.encode16(:crypto.strong_rand_bytes(8), case: :lower)`
   - `persist_task/2` -- `:dets.insert(table, {task.id, task})` then `:dets.sync(table)` (TASK-06 pattern from config.ex)
   - `rebuild_priority_index/0` -- Scan DETS for queued tasks, build sorted list of `{priority, created_at, task_id}`
   - `add_to_priority_index/2` -- Insert a `{priority, created_at, task_id}` tuple into the sorted list maintaining sort order. Use `Enum.sort/1` after insertion (list is small, <100 items typically).
   - `remove_from_priority_index/2` -- Remove tuple by task_id from the list.
   - `broadcast_task_event/2` -- `Phoenix.PubSub.broadcast(AgentCom.PubSub, "tasks", {:task_event, %{event: event, task_id: task.id, task: task, timestamp: now}})`
   - `cap_history/1` -- If task.history length exceeds @history_cap (50), truncate to @history_cap entries. Apply after adding history entries.
   - `lookup_task/1` -- `:dets.lookup(@tasks_table, task_id)` returning `{:ok, task}` or `{:error, :not_found}`
   - `dets_path/1` -- Build path under Application `priv` dir. Use `Application.app_dir(:agent_com, "priv")` or fall back to `"priv"` (matching mailbox.ex pattern). Check what pattern mailbox.ex uses and follow it exactly.

7. **@moduledoc:** Document the module purpose, the two DETS tables, priority lane semantics, generation fencing concept, and public API overview. Follow the style of existing moduledocs (see mailbox.ex, config.ex).

**Critical constraints:**
- Every `:dets.insert` MUST be followed by `:dets.sync` on the same table (TASK-06). Use the `persist_task/2` helper consistently.
- Priority integers: 0=urgent, 1=high, 2=normal, 3=low. Lower number = higher priority. Sorted list naturally puts lowest first.
- Generation fencing: `complete_task` and `fail_task` MUST verify `task.generation == provided_generation` before accepting the update (TASK-05).
- History cap: Apply `cap_history/1` after every history list modification.
  </action>
  <verify>
1. Run `mix compile` from repo root -- should compile with no errors (warnings about unused functions are acceptable at this stage since Socket/Endpoint integration is Plan 02)
2. Verify module exists and has expected public functions: `grep -c "def submit\|def get\|def list\|def assign_task\|def complete_task\|def fail_task\|def dequeue_next\|def recover_task\|def retry_dead_letter\|def stats" lib/agent_com/task_queue.ex` -- should show 10+ matches
3. Verify DETS sync pattern: `grep -c "dets.sync" lib/agent_com/task_queue.ex` -- should show multiple matches (at least 5+)
4. Verify generation fencing: `grep "stale_generation" lib/agent_com/task_queue.ex` -- should match
5. Verify priority index rebuild: `grep "rebuild_priority_index" lib/agent_com/task_queue.ex` -- should match in init
  </verify>
  <done>AgentCom.TaskQueue GenServer exists with full task lifecycle: submit creates tasks with auto-generated IDs and priority lanes, assign_task increments generation for fencing, complete_task/fail_task validate generation before accepting updates, failed tasks retry up to max_retries then move to dead-letter DETS table, periodic 30s sweep reclaims overdue assigned tasks, and every DETS mutation is followed by explicit sync. Priority index enables O(1) dequeue of highest-priority task.</done>
</task>

<task type="auto">
  <name>Task 2: Register TaskQueue in supervision tree</name>
  <files>lib/agent_com/application.ex</files>
  <action>
Add `{AgentCom.TaskQueue, []}` to the children list in `AgentCom.Application.start/2`.

**Placement:** Add it after the existing GenServer children but before Bandit (the HTTP server), since Bandit should start last. Specifically, add it after `{AgentCom.Reaper, []}` and before `{Bandit, plug: AgentCom.Endpoint, ...}`.

The line to add:
```elixir
{AgentCom.TaskQueue, []},
```

This follows the exact same pattern as all other GenServer registrations in application.ex. No configuration options needed -- TaskQueue reads defaults from module attributes.

**Verify the full children list has TaskQueue in the right position:**
```elixir
children = [
  {Phoenix.PubSub, name: AgentCom.PubSub},
  {Registry, keys: :unique, name: AgentCom.AgentRegistry},
  {AgentCom.Config, []},
  {AgentCom.Auth, []},
  {AgentCom.Mailbox, []},
  {AgentCom.Channels, []},
  {AgentCom.Presence, []},
  {AgentCom.Analytics, []},
  {AgentCom.Threads, []},
  {AgentCom.MessageHistory, []},
  {AgentCom.Reaper, []},
  {AgentCom.TaskQueue, []},           # <-- NEW
  {Bandit, plug: AgentCom.Endpoint, scheme: :http, port: port()}
]
```
  </action>
  <verify>
1. Run `mix compile` -- should compile clean
2. Verify TaskQueue is in supervision tree: `grep "TaskQueue" lib/agent_com/application.ex` -- should match
3. Start the hub with `mix run --no-halt` -- should start without errors, TaskQueue GenServer should initialize and open both DETS tables. Check for any startup errors in console output.
4. Stop the hub (Ctrl+C twice) and verify DETS files were created: check for `priv/task_queue.dets` and `priv/task_dead_letter.dets` (or equivalent path depending on where mailbox.ex stores its DETS file).
  </verify>
  <done>TaskQueue GenServer is registered in the supervision tree and starts automatically with the hub. Both DETS tables (task_queue and task_dead_letter) are created on first startup. The overdue sweep timer is running on 30-second intervals.</done>
</task>

</tasks>

<verification>
- `mix compile` succeeds with no errors
- AgentCom.TaskQueue module exists with all public API functions
- TaskQueue is registered in supervision tree (application.ex)
- DETS sync is called after every task mutation (TASK-06)
- Generation fencing validates generation on complete/fail (TASK-05)
- Priority index sorts by {priority, created_at} for FIFO within lanes (TASK-02)
- Dead-letter logic moves exhausted tasks to separate DETS table (TASK-03)
- Periodic sweep reclaims overdue assigned tasks (TASK-04)
- Task records include tokens_used field (API-02)
- Hub starts cleanly with TaskQueue in supervision tree
</verification>

<success_criteria>
The TaskQueue GenServer provides a complete, persistent, priority-ordered task queue. Tasks survive hub restarts (DETS-backed). The module compiles, starts in the supervision tree, and exposes a public API ready for Socket and HTTP wiring in Plan 02.
</success_criteria>

<output>
After completion, create `.planning/phases/02-task-queue/02-01-SUMMARY.md`
</output>
