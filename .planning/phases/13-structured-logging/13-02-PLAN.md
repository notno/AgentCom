---
phase: 13-structured-logging
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - lib/agent_com/agent_fsm.ex
  - lib/agent_com/task_queue.ex
  - lib/agent_com/scheduler.ex
  - lib/agent_com/dets_backup.ex
  - lib/agent_com/presence.ex
  - lib/agent_com/reaper.ex
autonomous: true

must_haves:
  truths:
    - "Every FSM state transition emits a [:agent_com, :fsm, :transition] telemetry event with duration_ms, from_state, to_state, agent_id"
    - "Task submit/assign/complete/fail/dead_letter/reclaim/retry each emit their corresponding telemetry event"
    - "Scheduler attempts and matches emit telemetry events with idle_agents and queued_tasks counts"
    - "DETS backup/compaction/restore operations are wrapped in telemetry spans emitting start/stop/exception"
    - "Agent connect/disconnect/evict emit telemetry events"
    - "All Logger calls in these 6 modules use structured metadata instead of string interpolation"
  artifacts:
    - path: "lib/agent_com/agent_fsm.ex"
      provides: "FSM transition telemetry + structured logging"
      contains: "telemetry.execute"
    - path: "lib/agent_com/task_queue.ex"
      provides: "Task lifecycle telemetry events"
      contains: "telemetry.execute"
    - path: "lib/agent_com/scheduler.ex"
      provides: "Scheduler telemetry events"
      contains: "telemetry.execute"
    - path: "lib/agent_com/dets_backup.ex"
      provides: "DETS operation telemetry spans"
      contains: "telemetry.span"
    - path: "lib/agent_com/presence.ex"
      provides: "Structured logging with metadata"
      contains: "Logger.metadata"
    - path: "lib/agent_com/reaper.ex"
      provides: "Agent eviction telemetry"
      contains: "telemetry.execute"
  key_links:
    - from: "lib/agent_com/agent_fsm.ex"
      to: ":telemetry"
      via: "execute call in transition/2 helper"
      pattern: ":telemetry\\.execute.*:fsm.*:transition"
    - from: "lib/agent_com/task_queue.ex"
      to: ":telemetry"
      via: "execute calls in submit/assign/complete/fail handlers"
      pattern: ":telemetry\\.execute.*:task"
    - from: "lib/agent_com/dets_backup.ex"
      to: ":telemetry"
      via: "span calls wrapping backup/compaction/restore operations"
      pattern: ":telemetry\\.span.*:dets"
---

<objective>
Convert all Logger calls to structured format and add telemetry event emissions in the 6 core modules that emit telemetry events: AgentFSM, TaskQueue, Scheduler, DetsBackup, Presence, and Reaper.

Purpose: These modules contain 47 of the 69 Logger calls and ALL telemetry emission points. After this plan, every significant lifecycle event (task lifecycle, FSM transitions, DETS operations, agent connect/disconnect/eviction, scheduling) emits a telemetry event with measurements and metadata that Phase 14 can aggregate.

Output: 6 modified modules with structured logging and telemetry event emissions
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-structured-logging/13-RESEARCH.md
@.planning/phases/13-structured-logging/13-01-SUMMARY.md
@lib/agent_com/agent_fsm.ex
@lib/agent_com/task_queue.ex
@lib/agent_com/scheduler.ex
@lib/agent_com/dets_backup.ex
@lib/agent_com/presence.ex
@lib/agent_com/reaper.ex
@lib/agent_com/telemetry.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert AgentFSM and TaskQueue -- highest call count + core telemetry</name>
  <files>
    lib/agent_com/agent_fsm.ex
    lib/agent_com/task_queue.ex
  </files>
  <action>
    **AgentFSM (23 Logger calls, 3 telemetry event types):**

    1. Add `Logger.metadata(module: __MODULE__, agent_id: agent_id)` in init/1 after extracting agent_id. This automatically tags ALL subsequent Logger calls from this process.

    2. Convert ALL Logger calls from string interpolation to structured metadata format. Pattern:
       - BEFORE: `Logger.info("Agent #{agent_id} transitioned from #{from} to #{to}")`
       - AFTER: `Logger.info("fsm_transition", from_state: from, to_state: to)`
       The agent_id is already in process metadata -- do NOT repeat it in the log call.

    3. Add telemetry event emissions:
       - In the transition/2 helper function (or wherever state transitions happen), add:
         ```elixir
         :telemetry.execute(
           [:agent_com, :fsm, :transition],
           %{duration_ms: duration_ms},
           %{agent_id: state.agent_id, from_state: from, to_state: to, task_id: state.current_task_id}
         )
         ```
         Calculate duration_ms as time since last_state_change.

       - On agent connect (in init or wherever agent starts):
         ```elixir
         :telemetry.execute(
           [:agent_com, :agent, :connect],
           %{system_time: System.system_time(:millisecond)},
           %{agent_id: agent_id, capabilities: capabilities}
         )
         ```

       - On agent disconnect (in terminate/2 or handle_cast for disconnect):
         ```elixir
         :telemetry.execute(
           [:agent_com, :agent, :disconnect],
           %{connected_duration_ms: System.system_time(:millisecond) - state.connected_at},
           %{agent_id: state.agent_id, reason: reason}
         )
         ```

    4. Use appropriate log levels per decision:
       - debug: internal state details, verbose transition info
       - info: lifecycle events (started, transition, task assignment)
       - warning: invalid transitions, unexpected messages
       - error: crashes, failures

    **TaskQueue (4 Logger calls, 7 telemetry event types):**

    1. Add `Logger.metadata(module: __MODULE__)` in init/1.

    2. Convert existing Logger calls to structured format.

    3. Add telemetry event emissions at these points:
       - submit handler: `[:agent_com, :task, :submit]` with `%{queue_depth: length(new_index)}` and `%{task_id, priority, submitted_by}`
       - assign handler: `[:agent_com, :task, :assign]` with `%{wait_ms: now - task.created_at}` and `%{task_id, agent_id, generation}`
       - complete handler: `[:agent_com, :task, :complete]` with `%{duration_ms: now - task.assigned_at}` and `%{task_id, agent_id, tokens_used}`
       - fail handler: `[:agent_com, :task, :fail]` with `%{retry_count: task.retry_count}` and `%{task_id, agent_id, error}`
       - dead_letter: `[:agent_com, :task, :dead_letter]` with `%{retry_count: task.retry_count}` and `%{task_id, error}`
       - reclaim: `[:agent_com, :task, :reclaim]` with `%{}` and `%{task_id, agent_id, reason}`
       - retry_dead_letter: `[:agent_com, :task, :retry]` with `%{}` and `%{task_id, previous_error}`

    IMPORTANT anti-patterns to avoid:
    - Do NOT use string interpolation in Logger calls: `Logger.info("Task #{id}")` -- use `Logger.info("task_submitted", task_id: id)`
    - Do NOT set metadata on every log call -- set once in init/1
    - Do NOT repeat agent_id/module in individual log calls if already set in process metadata
    - When logging potentially large data (task descriptions, error stacktraces) at debug level, use lazy evaluation: `Logger.debug(fn -> "details: #{inspect(large_data)}" end)`
  </action>
  <verify>
    Run `mix compile` -- zero errors or warnings about undefined functions.
    Run `mix test` -- all existing tests pass.
    Grep for string interpolation in Logger calls in these files: `grep -n 'Logger\.\(info\|warning\|error\|debug\|notice\).*#\{' lib/agent_com/agent_fsm.ex lib/agent_com/task_queue.ex` -- should return zero matches.
    Grep for telemetry calls: `grep -c 'telemetry.execute\|telemetry.span' lib/agent_com/agent_fsm.ex lib/agent_com/task_queue.ex` -- agent_fsm should have 3+, task_queue should have 7.
  </verify>
  <done>
    AgentFSM: All 23 Logger calls converted to structured format. Logger.metadata set in init/1. Telemetry events emitted for fsm:transition, agent:connect, agent:disconnect.
    TaskQueue: All 4 Logger calls converted. Logger.metadata set in init/1. Telemetry events emitted for all 7 task lifecycle events (submit, assign, complete, fail, dead_letter, reclaim, retry).
  </done>
</task>

<task type="auto">
  <name>Task 2: Convert Scheduler, DetsBackup, Presence, Reaper -- remaining telemetry emitters</name>
  <files>
    lib/agent_com/scheduler.ex
    lib/agent_com/dets_backup.ex
    lib/agent_com/presence.ex
    lib/agent_com/reaper.ex
  </files>
  <action>
    **Scheduler (5 Logger calls, 2 telemetry event types):**

    1. Add `Logger.metadata(module: __MODULE__)` in init/1.
    2. Convert all 5 Logger calls to structured format.
    3. Add telemetry events:
       - On scheduling attempt (when the scheduling loop fires):
         ```elixir
         :telemetry.execute(
           [:agent_com, :scheduler, :attempt],
           %{idle_agents: length(idle_agents), queued_tasks: length(queued_tasks)},
           %{trigger: trigger_reason}
         )
         ```
         trigger_reason can be :pubsub_event, :timer, etc.
       - On successful match:
         ```elixir
         :telemetry.execute(
           [:agent_com, :scheduler, :match],
           %{},
           %{task_id: task_id, agent_id: agent_id}
         )
         ```

    **DetsBackup (14 Logger calls, 3 telemetry span types):**

    1. Add `Logger.metadata(module: __MODULE__)` in init/1.
    2. Convert all 14 Logger calls to structured format.
    3. Wrap DETS operations in telemetry spans:
       - Backup operations: Wrap the per-table backup logic in:
         ```elixir
         :telemetry.span(
           [:agent_com, :dets, :backup],
           %{table: table_atom},
           fn ->
             result = perform_backup(table_atom, backup_dir)
             {result, %{table: table_atom, status: :ok}}
           end
         )
         ```
       - Compaction operations: Wrap compaction logic in:
         ```elixir
         :telemetry.span(
           [:agent_com, :dets, :compaction],
           %{table: table_atom, fragmentation_ratio: frag_ratio},
           fn ->
             result = perform_compaction(table_atom)
             {result, %{table: table_atom, status: result_status}}
           end
         )
         ```
       - Restore operations: Wrap restore logic in:
         ```elixir
         :telemetry.span(
           [:agent_com, :dets, :restore],
           %{table: table_atom, trigger: trigger},
           fn ->
             result = perform_restore(table_atom)
             {result, %{table: table_atom, backup_used: backup_path, record_count: count}}
           end
         )
         ```

       Note: :telemetry.span automatically emits :start, :stop, and :exception events. The start event gets the second argument as initial metadata. The stop event gets the metadata map returned from the function. Exception events are emitted automatically if the function raises.

    4. Use :notice level for successful operational completions (backup complete, compaction complete) per user decision on 5-level system.

    **Presence (varies -- check actual Logger calls):**

    1. Add `Logger.metadata(module: __MODULE__)` in init/1.
    2. Convert Logger calls to structured format.
    3. No new telemetry events -- agent connect/disconnect are emitted by AgentFSM.

    **Reaper (1 Logger call, 1 telemetry event type):**

    1. Add `Logger.metadata(module: __MODULE__)` in init/1.
    2. Convert Logger call to structured format.
    3. Add telemetry event on agent eviction:
       ```elixir
       :telemetry.execute(
         [:agent_com, :agent, :evict],
         %{stale_ms: System.system_time(:millisecond) - last_seen},
         %{agent_id: agent_id}
       )
       ```

    IMPORTANT: For DetsBackup telemetry spans, be careful about the return value. :telemetry.span expects the function to return {result, stop_metadata}. Make sure the existing backup/compaction/restore functions are wrapped correctly without changing their external API.
  </action>
  <verify>
    Run `mix compile` -- zero errors.
    Run `mix test` -- all existing tests pass.
    Grep for string interpolation: `grep -n 'Logger\.\(info\|warning\|error\|debug\|notice\).*#\{' lib/agent_com/scheduler.ex lib/agent_com/dets_backup.ex lib/agent_com/presence.ex lib/agent_com/reaper.ex` -- should return zero matches.
    Grep for telemetry: `grep -c 'telemetry.execute\|telemetry.span' lib/agent_com/dets_backup.ex` -- should show 3+ span calls.
  </verify>
  <done>
    Scheduler: 5 Logger calls converted, telemetry events for attempt and match.
    DetsBackup: 14 Logger calls converted, telemetry spans for backup/compaction/restore.
    Presence: Logger calls converted with metadata.
    Reaper: Logger call converted, telemetry event for agent eviction.
    All existing tests pass.
  </done>
</task>

</tasks>

<verification>
- `mix compile` succeeds with zero warnings about undefined telemetry functions
- `mix test` passes -- no regressions from Logger conversion
- Zero string interpolation Logger calls remain in the 6 modified files
- Telemetry events are emitted: at minimum 10+ :telemetry.execute calls and 3 :telemetry.span calls across these files
- All Logger calls use structured metadata (keyword lists or maps, not interpolated strings)
</verification>

<success_criteria>
1. All 47 Logger calls across 6 modules converted from string interpolation to structured metadata
2. Logger.metadata set in init/1 of all 6 modules
3. All 15 telemetry event emission points implemented (7 task, 3 agent, 1 FSM, 2 scheduler, 3 DETS spans)
4. Appropriate log levels used per 5-level decision (debug/info/notice/warning/error)
5. All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/13-structured-logging/13-02-SUMMARY.md`
</output>
