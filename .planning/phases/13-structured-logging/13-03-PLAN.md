---
phase: 13-structured-logging
plan: 03
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - lib/agent_com/socket.ex
  - lib/agent_com/endpoint.ex
  - lib/agent_com/dashboard_notifier.ex
  - lib/agent_com/dashboard_state.ex
  - lib/agent_com/channels.ex
  - lib/agent_com/mailbox.ex
  - lib/agent_com/config.ex
  - lib/agent_com/threads.ex
  - lib/agent_com/message_history.ex
  - sidecar/lib/log.js
  - sidecar/index.js
autonomous: true

must_haves:
  truths:
    - "All remaining Elixir modules set Logger.metadata in init/1 and use structured log format"
    - "Socket generates a request_id per WebSocket message and sets it in Logger.metadata"
    - "PUT /api/admin/log-level changes the runtime log level and returns success"
    - "Sidecar log output is NDJSON on stdout with consistent field conventions matching the Elixir hub"
    - "Sidecar redacts auth tokens in log output"
  artifacts:
    - path: "lib/agent_com/socket.ex"
      provides: "Request ID generation per WS message + structured logging"
      contains: "request_id"
    - path: "lib/agent_com/endpoint.ex"
      provides: "PUT /api/admin/log-level runtime config endpoint"
      contains: "log-level"
    - path: "sidecar/lib/log.js"
      provides: "Structured JSON logger for Node.js sidecar"
      exports: ["initLogger", "log", "LEVELS"]
    - path: "sidecar/index.js"
      provides: "All console.log calls replaced with structured logger"
      contains: "require('./lib/log')"
  key_links:
    - from: "lib/agent_com/socket.ex"
      to: "Logger.metadata"
      via: "request_id set per incoming WS message"
      pattern: "Logger\\.metadata.*request_id"
    - from: "lib/agent_com/endpoint.ex"
      to: "Logger.configure"
      via: "PUT /api/admin/log-level calls Logger.configure(level: level)"
      pattern: "Logger\\.configure.*level"
    - from: "sidecar/index.js"
      to: "sidecar/lib/log.js"
      via: "require('./lib/log') and log() calls replacing console.log"
      pattern: "require.*lib/log"
---

<objective>
Convert remaining Elixir modules to structured logging, add request_id generation in Socket, add runtime log-level API endpoint, and convert the Node.js sidecar to structured JSON output.

Purpose: Complete the big-bang migration across ALL system components. After this plan, every log line from both Elixir hub and Node.js sidecar is valid JSON with consistent field conventions. The runtime log-level API enables operational debugging without restarts.

Output: 9 modified Elixir modules, new PUT /api/admin/log-level endpoint, new sidecar/lib/log.js, modified sidecar/index.js
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-structured-logging/13-RESEARCH.md
@.planning/phases/13-structured-logging/13-01-SUMMARY.md
@lib/agent_com/socket.ex
@lib/agent_com/endpoint.ex
@lib/agent_com/dashboard_notifier.ex
@lib/agent_com/dashboard_state.ex
@lib/agent_com/channels.ex
@lib/agent_com/mailbox.ex
@lib/agent_com/config.ex
@lib/agent_com/threads.ex
@lib/agent_com/message_history.ex
@sidecar/index.js
@sidecar/lib/
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert remaining Elixir modules + Socket request_id + log-level API</name>
  <files>
    lib/agent_com/socket.ex
    lib/agent_com/endpoint.ex
    lib/agent_com/dashboard_notifier.ex
    lib/agent_com/dashboard_state.ex
    lib/agent_com/channels.ex
    lib/agent_com/mailbox.ex
    lib/agent_com/config.ex
    lib/agent_com/threads.ex
    lib/agent_com/message_history.ex
  </files>
  <action>
    **All 9 modules -- common pattern:**
    1. Add `Logger.metadata(module: __MODULE__)` in init/1 (or init/2 for Socket).
    2. Convert any existing Logger calls from string interpolation to structured metadata format.
    3. These modules have 1-6 Logger calls each and NO telemetry events to add (telemetry emitters are handled in Plan 02).

    **Socket (1 Logger call -- special handling for request_id):**
    1. In init/2 (WebSocket init), set `Logger.metadata(module: __MODULE__)`.
    2. In handle_in/2 (where each incoming WS message is processed), generate and set a request_id:
       ```elixir
       request_id = Base.encode16(:crypto.strong_rand_bytes(8), case: :lower)
       Logger.metadata(request_id: request_id)
       ```
       This ensures every log entry from processing a single WS message is correlated.
    3. When the agent identifies (after successful auth), also set agent_id in metadata:
       ```elixir
       Logger.metadata(agent_id: agent_id)
       ```
    4. Convert any existing Logger calls to structured format.

    **Endpoint (1 Logger call -- add PUT /api/admin/log-level):**
    1. The existing `require Logger` in the reset endpoint should be converted to a module-level require.
    2. Add a new HTTP endpoint:
       ```elixir
       put "/api/admin/log-level" do
         conn = AgentCom.Plugs.RequireAuth.call(conn, [])
         if conn.halted do
           conn
         else
           level = conn.body_params["level"]
           if level in ~w(debug info notice warning error) do
             Logger.configure(level: String.to_existing_atom(level))
             Logger.notice("log_level_changed", new_level: level, changed_by: conn.assigns[:authenticated_agent])
             send_json(conn, 200, %{"status" => "ok", "level" => level})
           else
             send_json(conn, 422, %{"error" => "invalid_level", "valid" => ["debug", "info", "notice", "warning", "error"]})
           end
         end
       end
       ```
       Place this near other admin endpoints. Note: requires auth. Override resets on restart (per user decision -- config.exs default reasserted on next start).
    3. Add the endpoint to the @moduledoc route list.
    4. Convert the existing Logger.warning call in the reset handler to structured format.

    **Dashboard modules (dashboard_notifier: 6 calls, dashboard_state: 4 calls):**
    - Add Logger.metadata(module: __MODULE__) in init/1.
    - Convert all Logger calls. These are internal modules with no telemetry events.

    **DETS-owning modules (channels: 2, mailbox: 2, config: 2, threads: 3, message_history: 1):**
    - Add Logger.metadata(module: __MODULE__) in init/1.
    - Convert Logger calls. Most are DETS corruption warnings -- keep at :warning level.

    IMPORTANT: Do NOT add telemetry events to these modules. Only the 6 modules in Plan 02 emit telemetry events. These modules just need structured logging.
  </action>
  <verify>
    Run `mix compile` -- zero errors.
    Run `mix test` -- all tests pass.
    Grep for string interpolation in ALL modified files: should return zero matches.
    Verify the log-level endpoint: `mix run -e "Logger.info(\"before\"); Logger.configure(level: :warning); Logger.info(\"should_not_appear\"); Logger.warning(\"should_appear\")"` -- only the warning should appear.
  </verify>
  <done>
    All 9 remaining Elixir modules converted to structured logging with Logger.metadata in init/1.
    Socket generates request_id per WebSocket message and sets agent_id after identification.
    PUT /api/admin/log-level endpoint added with auth, validates level, resets on restart.
    Zero string interpolation Logger calls remain in the entire codebase.
  </done>
</task>

<task type="auto">
  <name>Task 2: Convert Node.js sidecar to structured JSON logging</name>
  <files>
    sidecar/lib/log.js
    sidecar/index.js
  </files>
  <action>
    1. Create sidecar/lib/log.js -- a structured JSON logger matching Elixir hub field conventions:
       ```javascript
       'use strict';
       const fs = require('fs');
       const os = require('os');

       const LEVELS = { debug: 10, info: 20, notice: 30, warning: 40, error: 50 };
       const LEVEL_NAMES = Object.fromEntries(
         Object.entries(LEVELS).map(([k, v]) => [v, k])
       );

       let _config = null;
       let _logLevel = LEVELS.info;
       let _logStream = null;
       const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
       const MAX_FILES = 5;

       function initLogger(config) {
         _config = config;
         if (config.log_level && LEVELS[config.log_level] !== undefined) {
           _logLevel = LEVELS[config.log_level];
         }
         if (config.log_file) {
           _rotateIfNeeded(config.log_file);
           _logStream = fs.createWriteStream(config.log_file, { flags: 'a' });
         }
       }

       function log(level, event, data = {}, moduleName = 'sidecar/index') {
         const numLevel = typeof level === 'number' ? level : (LEVELS[level] || LEVELS.info);
         if (numLevel < _logLevel) return;

         const entry = {
           time: new Date().toISOString(),
           severity: LEVEL_NAMES[numLevel] || 'info',
           message: event,
           module: moduleName,
           pid: process.pid,
           node: os.hostname(),
           agent_id: _config ? _config.agent_id : 'unknown',
           ...data
         };

         // Redact sensitive fields (matching Elixir hub redaction keys)
         if (entry.token) entry.token = '[REDACTED]';
         if (entry.auth_token) entry.auth_token = '[REDACTED]';
         if (entry.secret) entry.secret = '[REDACTED]';

         const line = JSON.stringify(entry) + '\n';
         process.stdout.write(line);

         if (_logStream && _config && _config.log_file) {
           _logStream.write(line);
         }
       }

       function _rotateIfNeeded(filePath) {
         try {
           const stats = fs.statSync(filePath);
           if (stats.size >= MAX_FILE_SIZE) {
             for (let i = MAX_FILES - 1; i >= 1; i--) {
               const from = i === 1 ? filePath : `${filePath}.${i - 1}`;
               const to = `${filePath}.${i}`;
               try { fs.renameSync(from, to); } catch (_) {}
             }
             fs.renameSync(filePath, `${filePath}.1`);
           }
         } catch (_) {
           // File doesn't exist yet, no rotation needed
         }
       }

       module.exports = { initLogger, log, LEVELS };
       ```

    2. Modify sidecar/index.js:
       - Add `const { initLogger, log, LEVELS } = require('./lib/log');` at the top with other requires.
       - After config is loaded, call `initLogger(config)` with the sidecar config (which has agent_id and can optionally have log_file and log_level).
       - Replace ALL `console.log()` calls with `log(level, event, data, moduleName)` calls. The existing sidecar code likely uses `console.log()` for various events. Convert each one:
         - Connection events: `log('info', 'ws_connected', { hub_url: url })`
         - Message received: `log('debug', 'ws_message_received', { type: msg.type })`
         - Task events: `log('info', 'task_received', { task_id: task.task_id })`
         - Errors: `log('error', 'ws_error', { error: err.message })`
         - Heartbeat: `log('debug', 'heartbeat_sent')` (debug level -- high frequency)
       - Replace ALL `console.error()` calls with `log('error', event, data)`.
       - Add global error handlers to route through structured logger:
         ```javascript
         process.on('unhandledRejection', (reason) => {
           log('error', 'unhandled_rejection', { reason: String(reason) });
         });
         process.on('uncaughtException', (err) => {
           log('error', 'uncaught_exception', { error: err.message, stack: err.stack });
           process.exit(1);
         });
         ```

    3. Check if sidecar/index.js has an existing `log()` function. If so, replace it with the import from lib/log.js. The research mentions "The sidecar already has a partially structured log() function that writes JSON to a file but uses console.log() for stdout." -- the new lib/log.js replaces this entirely.

    4. Also check and update sidecar/lib/queue.js, sidecar/lib/git-workflow.js, sidecar/lib/wake.js if they have any console.log/console.error calls. If they import a log function, update the import. Pass the moduleName parameter matching the file (e.g., 'sidecar/queue', 'sidecar/git-workflow', 'sidecar/wake').

    IMPORTANT: Do NOT add any npm dependencies. The structured logger uses only Node.js built-ins (fs, os, process). This matches the project's zero-external-test-deps philosophy for the sidecar.
  </action>
  <verify>
    Run sidecar tests if they exist: `cd sidecar && npm test`
    Manually verify: `node -e "const {initLogger, log} = require('./sidecar/lib/log'); initLogger({agent_id: 'test'}); log('info', 'test_event', {key: 'value'});"` -- should output valid JSON to stdout with all required fields (time, severity, message, module, pid, node, agent_id).
    Verify redaction: `node -e "const {initLogger, log} = require('./sidecar/lib/log'); initLogger({agent_id: 'test'}); log('info', 'auth_test', {token: 'secret123'});"` -- token field should show "[REDACTED]".
    Grep for remaining console.log calls in sidecar/index.js -- should return zero (all replaced with structured log calls).
  </verify>
  <done>
    sidecar/lib/log.js created with NDJSON output, level filtering, file rotation, and secret redaction.
    All console.log/console.error calls in sidecar/index.js replaced with structured log() calls.
    Sidecar log field conventions match Elixir hub (time, severity, message, module, pid, node, agent_id).
    Global error handlers route unhandled rejections and uncaught exceptions through the structured logger.
  </done>
</task>

</tasks>

<verification>
- `mix compile && mix test` -- all Elixir tests pass
- `cd sidecar && npm test` -- sidecar tests pass
- Zero string interpolation Logger calls remain in any Elixir module
- Zero console.log/console.error calls remain in sidecar/index.js
- PUT /api/admin/log-level endpoint responds correctly
- Sidecar JSON output matches Elixir hub field conventions
</verification>

<success_criteria>
1. All 22 remaining Logger calls across 9 Elixir modules converted to structured format
2. Socket generates request_id per WS message and sets agent_id after auth
3. PUT /api/admin/log-level endpoint operational with auth and validation
4. sidecar/lib/log.js provides structured JSON logging with same field conventions as hub
5. All sidecar stdout output is NDJSON (no console.log calls remain)
6. Both Elixir and sidecar redact auth tokens in log output
</success_criteria>

<output>
After completion, create `.planning/phases/13-structured-logging/13-03-SUMMARY.md`
</output>
