---
phase: 06-dashboard
plan: 03
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - lib/agent_com/dashboard_notifier.ex
  - lib/agent_com/dashboard.ex
  - lib/agent_com/endpoint.ex
  - lib/agent_com/application.ex
  - mix.exs
autonomous: false

must_haves:
  truths:
    - "Browser push notifications fire when an agent goes offline"
    - "Browser push notifications fire when the queue stalls (queue growing 3 consecutive checks)"
    - "Dashboard shows 'Enable Notifications' button that handles permission flow"
    - "Push notifications work on localhost without HTTPS"
    - "Dashboard degrades gracefully when notifications are denied or unsupported"
    - "Service worker registered at /sw.js serves push event handler"
  artifacts:
    - path: "lib/agent_com/dashboard_notifier.ex"
      provides: "Web Push notification sender GenServer"
      exports: ["start_link/1", "subscribe/1"]
    - path: "mix.exs"
      provides: "web_push_elixir dependency"
      contains: "web_push_elixir"
    - path: "lib/agent_com/endpoint.ex"
      provides: "Service worker route at /sw.js and push subscription API"
      contains: "sw.js"
  key_links:
    - from: "lib/agent_com/dashboard_notifier.ex"
      to: "AgentCom.DashboardState"
      via: "Polls DashboardState.snapshot() every 60s for health status changes; subscribes to PubSub presence for agent_left"
      pattern: "DashboardState\\.snapshot|PubSub\\.subscribe"
    - from: "lib/agent_com/dashboard_notifier.ex"
      to: "web_push_elixir"
      via: "WebPush.send_notification for push delivery"
      pattern: "WebPush\\.send_notification"
    - from: "lib/agent_com/endpoint.ex"
      to: "lib/agent_com/dashboard_notifier.ex"
      via: "POST /api/dashboard/push-subscribe stores subscription"
      pattern: "push-subscribe"
---

<objective>
Add browser push notifications for critical dashboard alerts (agent offline, queue stalls) and verify the complete dashboard with a human checkpoint.

Purpose: Per locked decision, the dashboard sends browser push notifications when an agent goes offline or the queue stalls. This is a progressive enhancement -- the dashboard works fully without it. This plan also includes human verification of the complete dashboard experience.

Output: `dashboard_notifier.ex`, updated `mix.exs`, `endpoint.ex`, `dashboard.ex`, and service worker
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-dashboard/06-RESEARCH.md
@.planning/phases/06-dashboard/06-01-SUMMARY.md
@.planning/phases/06-dashboard/06-02-SUMMARY.md

@lib/agent_com/dashboard_notifier.ex
@lib/agent_com/dashboard.ex
@lib/agent_com/endpoint.ex
@lib/agent_com/application.ex
@mix.exs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add web push notification infrastructure</name>
  <files>lib/agent_com/dashboard_notifier.ex, lib/agent_com/endpoint.ex, lib/agent_com/dashboard.ex, lib/agent_com/application.ex, mix.exs</files>
  <action>
**1. Add dependency to mix.exs:**
Add `{:web_push_elixir, "~> 0.4"}` to the deps list. Run `mix deps.get`.

**2. Create `lib/agent_com/dashboard_notifier.ex`:**

A GenServer that:

- **State:** `%{subscriptions: MapSet.t(), vapid_keys: %{public: string, private: string}, last_health: :ok}`
- **`init/1`:**
  - Subscribe to PubSub topic `"presence"` (for agent offline events).
  - Generate or load VAPID keys. For simplicity, generate on startup if env vars not set:
    ```elixir
    vapid_public = System.get_env("VAPID_PUBLIC_KEY")
    vapid_private = System.get_env("VAPID_PRIVATE_KEY")
    # If not set, generate ephemeral keys (notifications reset on restart -- acceptable for v1)
    {vapid_public, vapid_private} = if vapid_public && vapid_private do
      {vapid_public, vapid_private}
    else
      # Generate VAPID keys using web_push_elixir
      %{public: pub, private: priv} = WebPush.generate_vapid_key()
      {pub, priv}
    end
    ```
  - Schedule `:check_health` every 60_000ms (piggyback on DashboardState health to detect queue stalls).
  - State: `%{subscriptions: MapSet.new(), vapid_public: vapid_public, vapid_private: vapid_private, last_health_status: :ok}`

- **`subscribe/1` public function** (GenServer.cast):
  Accepts a push subscription map (from browser PushManager.subscribe), adds to MapSet.

- **`get_vapid_public_key/0` public function** (GenServer.call):
  Returns the VAPID public key (needed by client to subscribe).

- **`handle_info({:agent_left, agent_id}, state)`:**
  Send push notification to all subscriptions: "Agent Offline: {agent_id} disconnected from hub"
  Use `WebPush.send_notification(subscription, payload, vapid_params)`.
  Catch errors silently (progressive enhancement). Remove failed subscriptions from MapSet.

- **`handle_info(:check_health, state)`:**
  Call `AgentCom.DashboardState.snapshot()`, check `health.status`.
  If status changed from `:ok` to `:warning` or `:critical`:
    Send push notification with condition text.
  Update `last_health_status` in state.
  Reschedule timer.

- **Push notification format:**
  ```json
  {"title": "AgentCom Alert", "body": "Agent offline: agent-1", "icon": "/favicon.ico"}
  ```

**3. Add routes to endpoint.ex:**

Before the catch-all `match _`, add:

```elixir
get "/sw.js" do
  conn
  |> put_resp_content_type("application/javascript")
  |> put_resp_header("service-worker-allowed", "/")
  |> send_resp(200, AgentCom.Dashboard.service_worker())
end

get "/api/dashboard/vapid-key" do
  key = AgentCom.DashboardNotifier.get_vapid_public_key()
  send_json(conn, 200, %{"vapid_public_key" => key})
end

post "/api/dashboard/push-subscribe" do
  subscription = conn.body_params
  AgentCom.DashboardNotifier.subscribe(subscription)
  send_json(conn, 200, %{"status" => "subscribed"})
end
```

**4. Add service worker function to dashboard.ex:**

Add a new public function `service_worker/0` that returns the JavaScript string:

```javascript
self.addEventListener('push', function(event) {
  const data = event.data ? event.data.json() : {title: 'AgentCom', body: 'New notification'};
  event.waitUntil(
    self.registration.showNotification(data.title, {
      body: data.body,
      icon: data.icon || '/favicon.ico',
      badge: data.badge,
      tag: 'agentcom-alert',
      renotify: true
    })
  );
});

self.addEventListener('notificationclick', function(event) {
  event.notification.close();
  event.waitUntil(
    clients.matchAll({type: 'window'}).then(function(clientList) {
      for (var i = 0; i < clientList.length; i++) {
        if (clientList[i].url.includes('/dashboard') && 'focus' in clientList[i]) {
          return clientList[i].focus();
        }
      }
      if (clients.openWindow) {
        return clients.openWindow('/dashboard');
      }
    })
  );
});
```

**5. Add notification UI to dashboard.ex HTML:**

In the header bar area of the dashboard HTML, add an "Enable Notifications" button:

```html
<button id="notif-btn" class="notif-btn" style="display:none" onclick="enableNotifications()">Enable Notifications</button>
```

In the JavaScript section, add:
- On page load, check `if ('serviceWorker' in navigator && 'PushManager' in window)` -- if true, show the button (unless already granted).
- `enableNotifications()` function: request Notification.permission, register service worker, subscribe to push manager with VAPID key fetched from `/api/dashboard/vapid-key`, send subscription to `/api/dashboard/push-subscribe`.
- If permission already granted, auto-register without showing button.
- If permission denied, show small text "Notifications blocked" near the button area.

**6. Add DashboardNotifier to supervision tree:**

In `application.ex`, add `{AgentCom.DashboardNotifier, []}` after DashboardState and before Bandit.
  </action>
  <verify>
1. `mix deps.get` succeeds (web_push_elixir installed)
2. `mix compile` succeeds with no warnings
3. `mix test` passes
4. `curl http://localhost:4000/api/dashboard/vapid-key` returns JSON with vapid_public_key
5. `curl http://localhost:4000/sw.js` returns JavaScript service worker
6. Open dashboard in browser -- "Enable Notifications" button visible (if browser supports push)
  </verify>
  <done>
Web push notification infrastructure is complete: DashboardNotifier GenServer manages VAPID keys and push subscriptions, sends alerts when agents go offline or health degrades, service worker handles push events, dashboard has notification enable button, and all endpoint routes are wired.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify complete dashboard experience</name>
  <files>lib/agent_com/dashboard.ex</files>
  <action>
CHECKPOINT: Human verification of the complete Phase 6 dashboard.

What was built: Complete real-time command center dashboard with dark theme grid layout, WebSocket-driven real-time updates (no polling), agent table, queue summary, throughput metrics, recent tasks, dead-letter panel with retry buttons, connection indicator with auto-reconnect, flash animations on state changes, sortable/filterable task table, browser push notification support, hub uptime, and health traffic light.

How to verify:
1. Start the hub: `cd C:/Users/nrosq/src/AgentCom && mix run --no-halt`
2. Open http://localhost:4000/dashboard in your browser
3. Verify: Dark theme with command center grid layout
4. Verify: Green "Connected" dot in header
5. Verify: Uptime counter incrementing
6. Verify: Health shows "Healthy" (green dot)
7. Verify: Agent table, queue summary, throughput, recent tasks, dead-letter panels all visible
8. Submit a test task: `curl -X POST http://localhost:4000/api/tasks -H "Authorization: Bearer YOUR_TOKEN" -H "Content-Type: application/json" -d '{"description":"test dashboard task"}'`
9. Verify: Dashboard updates in real-time (queue count bumps, task appears)
10. Click "Enable Notifications" and allow permission
11. Verify: Task table sorting works (click column headers)
12. Verify: Task table filtering works (type in filter input)
13. Verify: Responsive layout (resize browser window)
14. Also verify JSON API: `curl http://localhost:4000/api/dashboard/state | jq .`

Resume signal: Type "approved" to complete Phase 6, or describe issues to fix.
  </action>
  <verify>Human opens dashboard and confirms all panels render correctly with real-time updates</verify>
  <done>Human has verified the complete dashboard experience: dark theme command center layout, real-time WebSocket updates, all panels visible and functional, push notifications working, and JSON API returns proper snapshots.</done>
</task>

</tasks>

<verification>
1. `mix compile` succeeds with no warnings
2. `mix test` passes
3. `mix deps.get` includes web_push_elixir
4. Dashboard loads with all panels, real-time updates, push notifications
5. GET /api/dashboard/state returns complete JSON snapshot
6. Human verification confirms visual layout matches command center design
</verification>

<success_criteria>
- Browser push notifications fire on agent disconnect and queue stall events
- Dashboard degrades gracefully when notifications unsupported or denied
- Service worker registered at /sw.js
- VAPID key endpoint available for push subscription
- Human confirms complete dashboard experience meets requirements
</success_criteria>

<output>
After completion, create `.planning/phases/06-dashboard/06-03-SUMMARY.md`
</output>
