---
phase: 06-dashboard
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - lib/agent_com/dashboard.ex
autonomous: true

must_haves:
  truths:
    - "HTML dashboard renders a command center grid layout with dark theme on /dashboard"
    - "Dashboard connects to /ws/dashboard WebSocket and renders agent table, queue summary, dead-letter panel, throughput metrics, and recent completions in real-time"
    - "Connection indicator shows green dot when connected, red pulsing dot when disconnected"
    - "Auto-reconnect with exponential backoff restores connection without manual reload"
    - "State changes flash/highlight briefly with CSS transitions"
    - "Queue counts animate on change"
    - "Agent table shows columns: name, state, current task, capabilities, last seen"
    - "Task table is sortable and filterable with columns: task, agent, status, duration, tokens"
    - "Dead-letter tasks appear in a separate dedicated panel with retry button"
    - "Hub uptime is displayed prominently at top"
    - "Queue summary shows counts by priority lane at top"
    - "PR links column exists as placeholder in task table (empty until Phase 7)"
  artifacts:
    - path: "lib/agent_com/dashboard.ex"
      provides: "Self-contained HTML command center dashboard with inline CSS and JS"
      exports: ["render/0"]
  key_links:
    - from: "lib/agent_com/dashboard.ex"
      to: "ws/dashboard"
      via: "JavaScript WebSocket connection in inline script"
      pattern: "ws://.*ws/dashboard"
    - from: "lib/agent_com/dashboard.ex"
      to: "DashboardState snapshot shape"
      via: "JavaScript renderFullState parsing snapshot JSON"
      pattern: "renderFullState|snapshot"
---

<objective>
Replace the existing polling-based dashboard with a real-time command center that connects via WebSocket and renders a dense, dark-themed grid layout with all system observability panels.

Purpose: This is the user-facing deliverable -- the HTML page Nathan opens to see the full state of the system at a glance. All locked layout/interaction decisions are implemented here.

Output: Updated `dashboard.ex` with command center layout
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-dashboard/06-RESEARCH.md
@.planning/phases/06-dashboard/06-01-SUMMARY.md

@lib/agent_com/dashboard.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build command center HTML layout with dark theme and grid panels</name>
  <files>lib/agent_com/dashboard.ex</files>
  <action>
Replace the entire `AgentCom.Dashboard.render/0` function with a new self-contained HTML page. The page uses ONLY inline CSS and vanilla JavaScript (no external dependencies). This is a complete rewrite of the existing dashboard.

**HTML Structure (command center grid):**

```
+----------------------------------------------------------+
| AgentCom Command Center   [Uptime: 2h 15m]  [Health: OK] |
| [Connected agents: 3]  [Queue: 5]  [Throughput: 12/hr]   |
+----------------------------------------------------------+
| Connection: * Connected              [Last update: 12:34] |
+----------------------------------------------------------+
|                    |                    |                  |
|  AGENT TABLE       |  QUEUE SUMMARY     |  THROUGHPUT      |
|  (compact rows)    |  (priority lanes)  |  (stats cards)   |
|                    |  + expandable list |                  |
+----------------------------------------------------------+
|                                        |                  |
|  RECENT TASKS (sortable/filterable)    |  DEAD LETTER     |
|                                        |  (separate panel)|
+----------------------------------------------------------+
```

**CSS (dark theme per locked decision):**
- Background: `#0a0a0f` (matches existing dashboard)
- Panel background: `#141420` with `border: 1px solid #2a2a3a` (matches existing card style)
- Accent color: `#7eb8da` (matches existing)
- Grid: CSS Grid with `grid-template-columns` for responsive layout, 3 columns on large screens, 1 column on mobile
- Font: `-apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif` (matches existing)
- Table headers: `#1a1a2e` background, `#7eb8da` text, uppercase 0.8em (matches existing)
- Status dots: green `#4ade80` (idle/connected), yellow `#fbbf24` (assigned/warning), red `#ef4444` (offline/critical), blue `#60a5fa` (working)
- Flash animation: `.flash { background-color: rgba(126, 184, 218, 0.3) !important; }` with transition
- Count bump: `.bumped { transform: scale(1.15); }` with 0.2s transition
- Pulsing disconnected dot: `@keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }`

**Header bar:**
- Title: "AgentCom Command Center"
- Health traffic light: colored dot (green/yellow/red) + text ("Healthy", "Warning -- N conditions", "Critical -- description"). Click expands condition list. (Claude's discretion: traffic light with text format)
- Uptime: format as "Xd Xh Xm" prominently
- Connected agent count
- Queue depth (total queued)
- Throughput: "X tasks/hr"
- Connection indicator: green dot + "Connected" or red pulsing dot + "Disconnected" (per locked decision)

**Agent Table panel:**
- Compact table with columns: Name, State, Current Task, Capabilities, Last Seen
- State shown as colored dot + text (idle=green, assigned=yellow, working=blue, blocked=orange, offline=gray)
- Current Task: shows task description snippet or "--" if none (Claude's discretion: column in agent table per research recommendation)
- Capabilities: comma-separated tags
- Last Seen: relative time (e.g., "2m ago")
- Row highlights on state change (flash class)

**Queue Summary panel:**
- 4 cards for priority lanes: Urgent (red accent), High (orange), Normal (blue), Low (gray)
- Each card shows count with animated bump on change
- Below cards: expandable full task list (collapsed by default, click "Show N queued tasks" to expand)
- Expanded list shows: description, priority, submitted_by, created_at
- PR links column: present but empty, with "---" placeholder (per locked decision, wired in Phase 7)

**Throughput panel:**
- 3 metric cards:
  - Tasks completed last hour (count)
  - Average completion time (formatted as "Xm Xs")
  - Total tokens used last hour
- All with animated count transitions

**Recent Tasks table:**
- Sortable by clicking column headers (columns: Task, Agent, Status, Duration, Tokens, PR, Completed At)
- Filterable: text input at top that filters task descriptions
- PR column: placeholder "---" (Phase 7)
- Status shown as colored badge
- Duration formatted as "Xm Xs"
- Sorting: click column header toggles asc/desc, visual indicator (arrow)
- Default sort: completed_at descending (most recent first)
- Claude's discretion on time window: show last 100 completions (matching DashboardState ring buffer)

**Dead Letter panel (separate, per locked decision):**
- Dedicated panel with red accent border
- Table: Task Description, Error, Retries, Created At
- "Retry" button on each row (per Claude's discretion: include safe retry action). Button sends `{"type": "retry_task", "task_id": "..."}` over WebSocket.
- Flash green on successful retry, flash red on failure

**JavaScript WebSocket client:**
- `DashboardConnection` class with exponential backoff reconnect (per locked decision, same pattern as sidecar):
  - Initial delay: 1000ms, max: 30000ms, factor: 2x, jitter: 30%
  - On open: reset delay, set connection indicator green, send `request_snapshot` if this is a reconnect
  - On close: set connection indicator red/pulsing, start backoff timer
  - On message: dispatch to handler

- Message handlers:
  - `snapshot`: call `renderFullState(data)` which replaces ALL panel contents
  - `events`: iterate array, call per-event handlers that do targeted DOM updates + flash animations
  - `retry_result`: flash the retry button green (requeued) or red (not found)

- `renderFullState(data)`:
  - Update header: uptime, health, connected count, queue depth, throughput
  - Render agent table rows
  - Render queue summary cards + expandable list
  - Render throughput cards
  - Render recent completions table
  - Render dead letter table

- Per-event handlers for incremental updates:
  - `task_event`: update relevant table row, bump queue counts, add to recent if completed
  - `agent_joined`: add row to agent table with flash
  - `agent_left`: remove row from agent table (or mark offline) with flash
  - `status_changed`: update agent row

- Utility functions:
  - `timeAgo(ms)` -- relative time formatter
  - `formatDuration(ms)` -- "Xm Xs" formatter
  - `formatUptime(ms)` -- "Xd Xh Xm" formatter
  - `flashElement(el)` -- add flash class, remove after 1500ms
  - `bumpCount(el)` -- add bumped class, remove after 200ms
  - `sortTable(tableId, colIndex)` -- client-side sort
  - `filterTable(tableId, query)` -- client-side text filter

**Key implementation notes:**
- Use `EEx` is NOT needed -- build the HTML as a heredoc string in `render/0`. This matches the existing pattern. The HTML is large but self-contained.
- The JavaScript uses `document.getElementById` and `querySelector` with data attributes for targeted updates.
- All data attributes: `data-agent-id`, `data-task-id`, `data-priority` for targeted DOM updates.
- Event delegation for sort/filter/retry click handlers (attach to parent, check `event.target`).
- WebSocket URL: `ws://${location.host}/ws/dashboard` (works for both localhost and remote).
- Last update timestamp shown and updated on every message/event batch.
  </action>
  <verify>
Run `mix compile` -- no warnings. Start hub with `mix run --no-halt`. Open `http://localhost:4000/dashboard` in browser. Verify:
1. Dark theme loads with command center grid layout
2. Connection indicator shows green "Connected"
3. Header shows uptime, health status, connected count
4. Agent table, queue summary, throughput, recent tasks, and dead-letter panels are all visible
5. If no agents connected, panels show empty state (not errors)
  </verify>
  <done>
Dashboard page at /dashboard renders a dark-themed command center with: header bar (uptime, health traffic light, connection indicator), agent table (name, state, current task, capabilities, last seen), queue summary (priority lane cards + expandable list with PR placeholder column), throughput metrics (3 cards), sortable/filterable recent tasks table, and dedicated dead-letter panel with retry buttons. WebSocket connection with exponential backoff reconnect, flash animations on state changes, and animated count bumps.
  </done>
</task>

</tasks>

<verification>
1. `mix compile` succeeds with no warnings
2. Start hub: `mix run --no-halt`
3. Open http://localhost:4000/dashboard in browser
4. Verify dark theme, grid layout, all panels visible
5. Verify WebSocket connects (green dot visible)
6. Submit a task via API: `curl -X POST http://localhost:4000/api/tasks -H "Authorization: Bearer TOKEN" -H "Content-Type: application/json" -d '{"description":"test task"}'`
7. Verify dashboard updates in real-time without page reload
8. Verify sorting works on recent tasks table
9. Verify filter input filters task descriptions
10. Verify connection indicator turns red when hub stops, and dashboard reconnects automatically when hub restarts
</verification>

<success_criteria>
- Dashboard renders command center layout with all required panels
- Dark theme with bright accents matches locked design decision
- WebSocket connection with reconnect and connection indicator works
- State changes produce flash/highlight animations
- Queue counts animate on change
- Agent table shows all required columns
- Recent tasks table is sortable and filterable
- Dead-letter panel has working retry buttons
- PR links column exists as placeholder
- Hub uptime displayed prominently
- No external dependencies (all inline CSS/JS)
</success_criteria>

<output>
After completion, create `.planning/phases/06-dashboard/06-02-SUMMARY.md`
</output>
