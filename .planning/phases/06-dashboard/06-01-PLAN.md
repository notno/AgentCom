---
phase: 06-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/agent_com/dashboard_state.ex
  - lib/agent_com/dashboard_socket.ex
  - lib/agent_com/endpoint.ex
  - lib/agent_com/application.ex
autonomous: true

must_haves:
  truths:
    - "GET /api/dashboard/state returns JSON with queue depth, agent states, recent completions, throughput, and health status"
    - "WebSocket at /ws/dashboard pushes a full state snapshot on connect"
    - "PubSub events (task_event, agent_joined, agent_left) are forwarded as JSON to connected dashboard WebSocket clients"
    - "Health heuristics compute green/yellow/red status based on agent offline, queue growing, failure rate, stuck tasks"
    - "DashboardState starts under the application supervisor and aggregates metrics in-memory"
  artifacts:
    - path: "lib/agent_com/dashboard_state.ex"
      provides: "State aggregation GenServer with snapshot, health, throughput, ring buffer"
      exports: ["snapshot/0", "start_link/1"]
    - path: "lib/agent_com/dashboard_socket.ex"
      provides: "WebSocket handler for real-time dashboard push"
      exports: ["init/1", "handle_in/2", "handle_info/2"]
    - path: "lib/agent_com/endpoint.ex"
      provides: "Routes for /ws/dashboard and /api/dashboard/state"
      contains: "ws/dashboard"
    - path: "lib/agent_com/application.ex"
      provides: "DashboardState in supervision tree"
      contains: "DashboardState"
  key_links:
    - from: "lib/agent_com/dashboard_state.ex"
      to: "AgentCom.PubSub"
      via: "Phoenix.PubSub.subscribe in init"
      pattern: "PubSub\\.subscribe.*tasks"
    - from: "lib/agent_com/dashboard_state.ex"
      to: "AgentCom.TaskQueue"
      via: "TaskQueue.stats() and TaskQueue.list_dead_letter() in snapshot"
      pattern: "TaskQueue\\.(stats|list_dead_letter)"
    - from: "lib/agent_com/dashboard_socket.ex"
      to: "lib/agent_com/dashboard_state.ex"
      via: "DashboardState.snapshot() on init"
      pattern: "DashboardState\\.snapshot"
    - from: "lib/agent_com/endpoint.ex"
      to: "lib/agent_com/dashboard_socket.ex"
      via: "WebSockAdapter.upgrade for /ws/dashboard"
      pattern: "WebSockAdapter\\.upgrade.*DashboardSocket"
---

<objective>
Build the backend data layer for the real-time dashboard: a DashboardState GenServer that aggregates system state and computes health/throughput metrics, a DashboardSocket WebSocket handler that pushes real-time updates to browser clients, and the JSON API endpoint for curl-friendly access.

Purpose: Foundation for the command center dashboard. DashboardState pre-computes snapshots so neither the WebSocket handler nor API endpoint needs to make expensive queries at request time. DashboardSocket provides the real-time push channel the frontend will connect to.

Output: `dashboard_state.ex`, `dashboard_socket.ex`, updated `endpoint.ex` and `application.ex`
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-dashboard/06-RESEARCH.md

@lib/agent_com/application.ex
@lib/agent_com/endpoint.ex
@lib/agent_com/socket.ex
@lib/agent_com/task_queue.ex
@lib/agent_com/agent_fsm.ex
@lib/agent_com/analytics.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DashboardState GenServer for state aggregation and health metrics</name>
  <files>lib/agent_com/dashboard_state.ex, lib/agent_com/application.ex</files>
  <action>
Create `lib/agent_com/dashboard_state.ex` -- a GenServer that:

1. **Subscribes to PubSub** topics `"tasks"` and `"presence"` in `init/1`.

2. **Maintains in-memory state:**
   - `started_at` -- hub start time (System.system_time(:millisecond) in init)
   - `recent_completions` -- ring buffer (list) capped at 100 entries, each with: `%{task_id, agent_id, description, duration_ms, tokens_used, completed_at}`
   - `hourly_stats` -- `%{completed: 0, failed: 0, total_tokens: 0, completion_times: []}` reset every hour
   - `queue_growth_checks` -- list of last 3 queue depths (for "queue growing" heuristic), checked every 60s
   - `last_known_agents` -- MapSet of agent_ids seen recently (for "agent offline" detection)

3. **`snapshot/0` public function** (GenServer.call :snapshot):
   Returns a map matching this shape:
   ```
   %{
     uptime_ms: integer,
     timestamp: integer,
     health: %{status: :ok | :warning | :critical, conditions: [string]},
     agents: [%{agent_id, name, fsm_state, current_task_id, capabilities, connected_at, last_state_change}],
     queue: %{by_status: %{queued: N, assigned: N, completed: N}, by_priority: %{0 => N, 1 => N, 2 => N, 3 => N}, dead_letter: N},
     dead_letter_tasks: [%{id, description, last_error, retry_count, created_at}],
     recent_completions: [%{task_id, agent_id, description, duration_ms, tokens_used, completed_at}],
     throughput: %{completed_last_hour: N, avg_completion_ms: N, total_tokens_hour: N}
   }
   ```
   Pull live data from: `AgentCom.AgentFSM.list_all()`, `AgentCom.TaskQueue.stats()`, `AgentCom.TaskQueue.list_dead_letter()`. Throughput and completions come from local state.

4. **Health heuristics** (computed in snapshot, using local state):
   - **Agent Offline (WARNING):** An agent_id was in `last_known_agents` but is no longer in `AgentFSM.list_all()` results.
   - **Queue Growing (WARNING):** `queue_growth_checks` has 3 entries and all are strictly increasing.
   - **High Failure Rate (CRITICAL):** `hourly_stats.failed / (hourly_stats.completed + hourly_stats.failed) > 0.5` when total > 0.
   - **Stuck Tasks (WARNING):** Any task from `TaskQueue.list(status: :assigned)` where `updated_at < now - 300_000` (5 min).
   - Status: `:critical` if any CRITICAL condition, `:warning` if any WARNING, `:ok` otherwise.

5. **handle_info for PubSub events:**
   - `{:task_event, event}` where `event.event == "task_complete"` -- add to `recent_completions` ring buffer (pop oldest if >100), increment `hourly_stats.completed`, accumulate tokens and duration.
   - `{:task_event, event}` where `event.event == "task_failed"` -- increment `hourly_stats.failed`.
   - `{:agent_joined, info}` -- add `info.agent_id` to `last_known_agents`.
   - `{:agent_left, agent_id}` -- remove from `last_known_agents` (note: the "offline" condition triggers if they were recently known but not in FSM list, which handles the transient window).

6. **Periodic timers:**
   - Every 60_000ms (`:check_queue_growth`): read `TaskQueue.stats()`, push `by_status.queued` count onto `queue_growth_checks` (keep last 3).
   - Every 3_600_000ms (`:reset_hourly`): reset `hourly_stats` to zeroes.

7. **Add to supervision tree** in `application.ex`: Insert `{AgentCom.DashboardState, []}` BEFORE the Bandit line (so dashboard data is ready before HTTP starts).

Use `@name __MODULE__` for GenServer registration (same pattern as TaskQueue, Analytics).
  </action>
  <verify>
Run `mix compile` -- no warnings or errors. Verify `AgentCom.DashboardState` appears in application.ex children list. Grep for `DashboardState.snapshot` to confirm public API exists. Run `mix test` to confirm no regressions.
  </verify>
  <done>
DashboardState GenServer compiles, starts in supervision tree, subscribes to PubSub topics "tasks" and "presence", returns a properly shaped snapshot map via `snapshot/0`, computes health heuristics, tracks hourly throughput metrics, and maintains a ring buffer of recent completions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DashboardSocket WebSocket handler and endpoint routes</name>
  <files>lib/agent_com/dashboard_socket.ex, lib/agent_com/endpoint.ex</files>
  <action>
Create `lib/agent_com/dashboard_socket.ex` -- a WebSock handler (same pattern as `AgentCom.Socket`):

1. **`@behaviour WebSock`** with `init/1`, `handle_in/2`, `handle_info/2`.

2. **`init/1`:**
   - Subscribe to PubSub topics `"tasks"` and `"presence"`.
   - Call `AgentCom.DashboardState.snapshot()` to get initial state.
   - Set up a flush timer: `Process.send_after(self(), :flush, 100)`.
   - State: `%{pending_events: [], flush_timer: ref}`.
   - Return `{:push, {:text, Jason.encode!(%{type: "snapshot", data: snapshot})}, state}`.

3. **Event batching** (Pitfall 1 from research: PubSub message flood):
   - `handle_info` for PubSub events (`:task_event`, `:agent_joined`, `:agent_left`, `:status_changed`) -- accumulate events into `state.pending_events` list, return `{:ok, state}`.
   - `handle_info(:flush, state)`:
     - If `pending_events` is non-empty, encode all events as a JSON array message: `%{type: "events", data: events}` and push.
     - Schedule next flush: `Process.send_after(self(), :flush, 100)` (10 flushes/second max).
     - Clear `pending_events`.
     - Return `{:push, ...}` or `{:ok, ...}` depending on whether there were events.

4. **Event formatting** for each PubSub message type:
   - `{:task_event, event}` -> `%{type: "task_event", task_id: event.task_id, event: event.event, agent_id: event.agent_id, timestamp: event.timestamp}`
   - `{:agent_joined, info}` -> `%{type: "agent_joined", agent_id: info.agent_id, name: info[:name], capabilities: info[:capabilities] || []}`
   - `{:agent_left, agent_id}` -> `%{type: "agent_left", agent_id: agent_id}`
   - `{:status_changed, info}` -> `%{type: "status_changed", agent_id: info.agent_id, status: info[:status]}`

5. **`handle_in/2`** for client messages:
   - `{"type": "request_snapshot"}` -> call `DashboardState.snapshot()`, push as `%{type: "snapshot", data: snapshot}`.
   - `{"type": "retry_task", "task_id": task_id}` -> call `AgentCom.TaskQueue.retry_dead_letter(task_id)`, push result as `%{type: "retry_result", task_id: task_id, status: "requeued" | "not_found"}`. (Claude's discretion: include safe retry action)
   - Unknown messages -> `{:ok, state}` (ignore silently).

6. **No `terminate` callback needed** -- PubSub subscriptions are cleaned up automatically when the process exits.

7. **Add routes to `endpoint.ex`:**
   - BEFORE the existing `get "/ws"` route, add:
     ```elixir
     get "/ws/dashboard" do
       conn
       |> WebSockAdapter.upgrade(AgentCom.DashboardSocket, [], timeout: 60_000)
       |> halt()
     end
     ```
   - BEFORE the existing `match _` catch-all, add:
     ```elixir
     get "/api/dashboard/state" do
       snapshot = AgentCom.DashboardState.snapshot()
       send_json(conn, 200, snapshot)
     end
     ```
   Note: The `/api/dashboard/state` endpoint has NO auth (same as existing `/dashboard` page per research recommendation -- dashboard is on local network). Place it after the authenticated task routes but before the catch-all.

Route ordering in endpoint.ex matters. Place `/ws/dashboard` BEFORE `/ws` because Plug.Router matches top-to-bottom and `/ws` would match `/ws/dashboard` as a prefix if Plug.Router uses prefix matching. Actually, Plug.Router uses exact path match for `get "/ws"` so `/ws/dashboard` won't collide. But place it above `/ws` for clarity.
  </action>
  <verify>
Run `mix compile` -- no warnings or errors. Verify that:
1. `grep "ws/dashboard" lib/agent_com/endpoint.ex` finds the route.
2. `grep "api/dashboard/state" lib/agent_com/endpoint.ex` finds the route.
3. `grep "DashboardSocket" lib/agent_com/dashboard_socket.ex` confirms the module exists.
4. Run `mix test` to confirm no regressions.
  </verify>
  <done>
DashboardSocket WebSocket handler compiles and handles PubSub events with batched flushing (max 10 pushes/sec). Endpoint serves `/ws/dashboard` for WebSocket upgrade and `/api/dashboard/state` for JSON API. Client can send `request_snapshot` and `retry_task` messages over WebSocket.
  </done>
</task>

</tasks>

<verification>
1. `mix compile` succeeds with no warnings
2. `mix test` passes (no regressions)
3. Start hub with `mix run --no-halt`, then:
   - `curl http://localhost:4000/api/dashboard/state` returns JSON with keys: uptime_ms, health, agents, queue, dead_letter_tasks, recent_completions, throughput
   - `curl http://localhost:4000/api/dashboard/state | jq '.health.status'` returns "ok"
</verification>

<success_criteria>
- DashboardState GenServer runs in supervision tree and returns properly shaped snapshots
- DashboardSocket accepts WebSocket connections on /ws/dashboard and pushes initial snapshot
- PubSub events are batched and forwarded to connected dashboard clients
- Health heuristics correctly compute green/yellow/red status
- JSON API endpoint returns full system state at /api/dashboard/state
</success_criteria>

<output>
After completion, create `.planning/phases/06-dashboard/06-01-SUMMARY.md`
</output>
