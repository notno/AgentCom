---
phase: 25-cost-control-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/agent_com/cost_ledger.ex
  - lib/agent_com/application.ex
  - lib/agent_com/dets_backup.ex
autonomous: true

must_haves:
  truths:
    - "CostLedger GenServer starts in the supervision tree and survives restart"
    - "check_budget/1 returns :ok or :budget_exhausted based on rolling window invocation counts"
    - "record_invocation/2 persists invocations to DETS and updates ETS counters atomically"
    - "Budget limits are read from Config GenServer and configurable at runtime"
    - "ETS counters are rebuilt from DETS history on GenServer restart"
    - "CostLedger DETS table is registered with DetsBackup for backup and compaction"
  artifacts:
    - path: "lib/agent_com/cost_ledger.ex"
      provides: "CostLedger GenServer with dual-layer DETS+ETS store"
      exports: ["start_link/1", "check_budget/1", "record_invocation/2", "stats/0", "history/1"]
    - path: "lib/agent_com/application.ex"
      provides: "CostLedger added to supervision tree after Config"
      contains: "AgentCom.CostLedger"
    - path: "lib/agent_com/dets_backup.ex"
      provides: "CostLedger DETS table registered for backup"
      contains: ":cost_ledger"
  key_links:
    - from: "lib/agent_com/cost_ledger.ex"
      to: "AgentCom.Config"
      via: "Config.get(:hub_invocation_budgets) for budget limits"
      pattern: "Config\\.get\\(:hub_invocation_budgets\\)"
    - from: "lib/agent_com/cost_ledger.ex"
      to: ":cost_budget ETS table"
      via: "Direct ETS reads in check_budget/1 (no GenServer call)"
      pattern: ":ets\\.lookup\\(:cost_budget"
    - from: "lib/agent_com/dets_backup.ex"
      to: "AgentCom.CostLedger"
      via: "table_owner/1 mapping for backup orchestration"
      pattern: "table_owner\\(:cost_ledger\\)"
---

<objective>
Implement the CostLedger GenServer with dual-layer DETS/ETS persistence, synchronous budget checking, invocation recording, and integration with the supervision tree and DetsBackup.

Purpose: CostLedger must exist before any hub-side Claude Code CLI call (Phase 26+). It enforces hard invocation caps in code -- the LLM cannot be trusted to self-limit.

Output: Working CostLedger GenServer that tracks invocations per hour/day/session with per-state budgets (Executing, Improving, Contemplating), reads budget limits from Config, and is registered with DetsBackup.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/25-cost-control-infrastructure/25-RESEARCH.md

@lib/agent_com/repo_registry.ex (pattern: simpler GenServer + DETS, follow this structure)
@lib/agent_com/rate_limiter.ex (pattern: ETS-based hot-path reads without GenServer call)
@lib/agent_com/metrics_collector.ex (pattern: ETS counter/gauge with rolling windows)
@lib/agent_com/application.ex (supervision tree ordering)
@lib/agent_com/dets_backup.ex (DetsBackup @tables list and table_owner/1)
@lib/agent_com/config.ex (Config.get/put for dynamic thresholds)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement CostLedger GenServer with dual-layer DETS+ETS store</name>
  <files>lib/agent_com/cost_ledger.ex</files>
  <action>
Create `lib/agent_com/cost_ledger.ex` as a single-file GenServer following the RepoRegistry pattern (simpler than TaskQueue). The module implements:

**Data stores:**
- DETS table `:cost_ledger` storing invocation records as `{id, record_map}` tuples. Record map: `%{id, hub_state, timestamp, duration_ms, prompt_type}`. Use `:set` type with `auto_save: 5_000`.
- ETS table `:cost_budget` with `[:named_table, :public, :set, {:read_concurrency, true}]` for hot-path budget checks. Stores rolling window counters keyed by `{:hourly, hub_state}`, `{:daily, hub_state}`, `{:session, hub_state}`.
- Data directory from `Application.get_env(:agent_com, :cost_ledger_data_dir, "priv/data/cost_ledger")`.

**Public API (5 functions):**

1. `start_link/1` -- Standard GenServer start with `name: __MODULE__`.

2. `check_budget/1` -- Synchronous budget gate. Takes `hub_state` atom (`:executing`, `:improving`, `:contemplating`). Reads directly from ETS (NO GenServer.call -- follows RateLimiter pattern). Returns `:ok` or `:budget_exhausted`. Logic:
   - Read current hourly/daily counts from ETS for the given state
   - Read budget limits from Config via `read_budget_limits/1` private function
   - If hourly_count >= hourly_limit OR daily_count >= daily_limit, return `:budget_exhausted`
   - Otherwise return `:ok`
   - If ETS table doesn't exist or Config unavailable, return `:ok` (fail-open for safety during startup)

3. `record_invocation/2` -- GenServer.call. Takes `hub_state` atom and `metadata` map (keys: `:duration_ms`, `:prompt_type`). Creates record with unique ID (`System.unique_integer([:positive, :monotonic])`), persists to DETS, increments ETS counters, recalculates rolling window counts. Returns `:ok`.

4. `stats/0` -- GenServer.call. Returns map with per-state breakdowns:
   ```
   %{
     hourly: %{executing: N, improving: N, contemplating: N, total: N},
     daily: %{executing: N, improving: N, contemplating: N, total: N},
     session: %{executing: N, improving: N, contemplating: N, total: N},
     budgets: %{executing: %{hourly_limit: N, daily_limit: N}, ...}
   }
   ```

5. `history/1` -- GenServer.call. Takes keyword opts: `state:` (filter by hub_state), `since:` (ms timestamp), `limit:` (max records, default 100). Returns list of record maps sorted by timestamp descending.

**init/1 callback:**
- Create data directory with `File.mkdir_p!/1`
- Open DETS with `file:` charlist path, `type: :set`, `auto_save: 5_000`
- Create ETS table `:cost_budget`
- Call `rebuild_ets_from_history/0` to restore counters from DETS
- Schedule cleanup timer via `Process.send_after(self(), :cleanup, @cleanup_interval_ms)` (24 hours)
- Return `{:ok, %{session_start: System.system_time(:millisecond)}}`

**Private functions:**

- `rebuild_ets_from_history/0` -- Scan all DETS records. For each state in `[:executing, :improving, :contemplating]`, count records where `timestamp > now - 3_600_000` (hourly) and `timestamp > now - 86_400_000` (daily). Insert counts into ETS. Count all records since session start (but since we just started, session count = total in DETS from current session -- use all records for session on cold start).

- `read_budget_limits/1` -- Read from `AgentCom.Config.get(:hub_invocation_budgets)`. Fall back to `default_budgets/0` if nil or Config unavailable. Merge with defaults for missing states.

- `default_budgets/0` -- Returns map:
  ```
  %{
    executing: %{max_per_hour: 20, max_per_day: 100},
    improving: %{max_per_hour: 10, max_per_day: 40},
    contemplating: %{max_per_hour: 5, max_per_day: 15}
  }
  ```

- `recalculate_window_counts/1` -- For a given hub_state, scan DETS records within rolling window and update ETS counters. Called after each `record_invocation` to keep ETS accurate.

- `handle_info(:cleanup, state)` -- Delete DETS records older than 7 days (`@retention_ms 7 * 24 * 60 * 60 * 1000`). Rebuild ETS counters after cleanup. Reschedule timer.

- `generate_id/0` -- `System.unique_integer([:positive, :monotonic])`.

**Module attributes:**
- `@dets_table :cost_ledger`
- `@ets_table :cost_budget`
- `@hourly_window_ms 3_600_000`
- `@daily_window_ms 86_400_000`
- `@retention_ms 7 * 24 * 60 * 60 * 1000`
- `@cleanup_interval_ms 24 * 60 * 60 * 1000`
- `@hub_states [:executing, :improving, :contemplating]`

**terminate/2 callback:** Close DETS table with `:dets.close(@dets_table)`.
  </action>
  <verify>
Run `mix compile --warnings-as-errors` -- no compilation errors or warnings. Verify the module defines all 5 public functions by checking with `mix run -e "AgentCom.CostLedger.module_info(:exports) |> IO.inspect()"`.
  </verify>
  <done>
CostLedger GenServer compiles cleanly with check_budget/1 (ETS direct read), record_invocation/2 (GenServer.call with DETS+ETS write), stats/0, history/1, and start_link/1. Default budgets: Executing 20/hr 100/day, Improving 10/hr 40/day, Contemplating 5/hr 15/day. Rolling window counters with 7-day retention.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add CostLedger to supervision tree and register with DetsBackup</name>
  <files>lib/agent_com/application.ex, lib/agent_com/dets_backup.ex</files>
  <action>
**application.ex** -- Add `{AgentCom.CostLedger, []}` to the `children` list. Place it AFTER `{AgentCom.Config, []}` (CostLedger reads Config for budgets) and BEFORE `{AgentCom.Auth, []}`. This ensures Config is available when CostLedger starts, and CostLedger is available before any future ClaudeClient/HubFSM processes.

The children list should read:
```
{AgentCom.Config, []},
{AgentCom.CostLedger, []},
{AgentCom.Auth, []},
```

**dets_backup.ex** -- Two changes:

1. Add `:cost_ledger` to the `@tables` module attribute list (after `:repo_registry`):
```
@tables [
  :task_queue,
  :task_dead_letter,
  :agent_mailbox,
  :message_history,
  :agent_channels,
  :channel_history,
  :agentcom_config,
  :thread_messages,
  :thread_replies,
  :repo_registry,
  :cost_ledger
]
```

2. Add a `table_owner/1` clause for `:cost_ledger` after the existing `:task_dead_letter` clause:
```
defp table_owner(:cost_ledger), do: AgentCom.CostLedger
```

Also update the `@moduledoc` to say "11 DETS tables" instead of "10 DETS tables" (appears in two places: the moduledoc header and the daily backup description).
  </action>
  <verify>
Run `mix compile --warnings-as-errors` -- compiles cleanly. Verify supervision order: `mix run -e "children = Supervisor.which_children(AgentCom.Supervisor); children |> Enum.map(&elem(&1, 0)) |> IO.inspect()"` -- CostLedger appears after Config and before Auth. Verify DetsBackup registration: `mix run -e "IO.inspect(AgentCom.DetsBackup.health())"` -- response includes `:cost_ledger` in the table list.
  </verify>
  <done>
CostLedger starts in supervision tree after Config. DetsBackup manages the :cost_ledger DETS table for backup, compaction, and recovery. Module doc updated to reflect 11 tables.
  </done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` passes with zero warnings
2. Application starts successfully: `mix run --no-halt` (Ctrl+C to exit)
3. CostLedger is running: `mix run -e "Process.alive?(GenServer.whereis(AgentCom.CostLedger)) |> IO.inspect()"`
4. Budget check works: `mix run -e "AgentCom.CostLedger.check_budget(:executing) |> IO.inspect()"`
5. DetsBackup includes cost_ledger: `mix run -e "AgentCom.DetsBackup.health() |> Map.keys() |> IO.inspect()"`
</verification>

<success_criteria>
- CostLedger GenServer starts, creates DETS and ETS tables, and responds to check_budget/1
- check_budget/1 reads from ETS without GenServer.call (verified by pattern in source)
- record_invocation/2 persists to DETS and updates ETS
- Budget limits read from Config with fallback to defaults
- DetsBackup manages the :cost_ledger table
- Application supervision tree orders: Config -> CostLedger -> Auth
</success_criteria>

<output>
After completion, create `.planning/phases/25-cost-control-infrastructure/25-01-SUMMARY.md`
</output>
