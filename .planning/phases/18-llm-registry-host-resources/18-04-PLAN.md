---
phase: 18-llm-registry-host-resources
plan: 04
type: execute
wave: 3
depends_on: ["18-01", "18-03"]
files_modified:
  - lib/agent_com/dashboard_state.ex
  - lib/agent_com/dashboard_socket.ex
  - lib/agent_com/dashboard.ex
autonomous: false

must_haves:
  truths:
    - "Dashboard shows a table of registered Ollama endpoints with host, port, status, models, and source"
    - "Dashboard shows per-host resource utilization bars (CPU, RAM, VRAM)"
    - "Dashboard shows fleet-level model summary at top (e.g. '3 hosts have llama3')"
    - "Dashboard has controls to add and remove endpoints (not API-only)"
    - "Dashboard updates in real-time when endpoints register, go unhealthy, or report resources"
  artifacts:
    - path: "lib/agent_com/dashboard_state.ex"
      provides: "PubSub subscription to llm_registry topic, LLM data in snapshot"
      contains: "llm_registry"
    - path: "lib/agent_com/dashboard_socket.ex"
      provides: "Forwards llm_registry_update events to browser"
      contains: "llm_registry_update"
    - path: "lib/agent_com/dashboard.ex"
      provides: "HTML section for LLM Registry table, resource bars, fleet summary, add/remove controls"
      contains: "llm-registry"
  key_links:
    - from: "lib/agent_com/dashboard_state.ex"
      to: "lib/agent_com/llm_registry.ex"
      via: "Calls LlmRegistry.snapshot() in snapshot/0"
      pattern: "LlmRegistry\\.snapshot"
    - from: "lib/agent_com/dashboard_socket.ex"
      to: "Phoenix.PubSub"
      via: "Subscribes to llm_registry topic"
      pattern: "subscribe.*llm_registry"
    - from: "lib/agent_com/dashboard.ex"
      to: "dashboard WebSocket"
      via: "JavaScript handles llm_registry_update events and renders table"
      pattern: "llm.registry|llm_registry"
---

<objective>
Integrate LLM Registry data into the dashboard: DashboardState includes registry snapshot, DashboardSocket forwards real-time events, and Dashboard HTML renders the registry table, resource utilization bars, fleet model summary, and add/remove controls.

Purpose: Per locked decision, dashboard must show registry data with table view, utilization bars, fleet summary, and controls for add/remove (not API-only).
Output: Complete dashboard section for LLM registry and host resources with real-time updates.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/18-llm-registry-host-resources/18-CONTEXT.md
@.planning/phases/18-llm-registry-host-resources/18-RESEARCH.md
@.planning/phases/18-llm-registry-host-resources/18-01-SUMMARY.md
@.planning/phases/18-llm-registry-host-resources/18-03-SUMMARY.md

@lib/agent_com/dashboard_state.ex
@lib/agent_com/dashboard_socket.ex
@lib/agent_com/dashboard.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire DashboardState and DashboardSocket for LLM registry data</name>
  <files>lib/agent_com/dashboard_state.ex, lib/agent_com/dashboard_socket.ex</files>
  <action>
    **DashboardState changes:**

    1. In `init/1`, add PubSub subscription: `Phoenix.PubSub.subscribe(AgentCom.PubSub, "llm_registry")`
    2. In `handle_call(:snapshot, ...)`, add LLM registry data to the snapshot map:
       ```elixir
       llm_registry = try do
         AgentCom.LlmRegistry.snapshot()
       rescue
         _ -> %{endpoints: [], resources: %{}, fleet_models: %{}}
       end
       ```
       Add `llm_registry: llm_registry` to the snapshot map (alongside existing fields like `agents`, `queue`, etc.).
    3. Add `handle_info` clause for llm_registry events (no local state change needed -- data is fetched live in snapshot):
       ```elixir
       def handle_info({:llm_registry_update, _detail}, state) do
         {:noreply, state}
       end
       ```

    **DashboardSocket changes:**

    1. In `init/1`, add PubSub subscription: `Phoenix.PubSub.subscribe(AgentCom.PubSub, "llm_registry")`
    2. Add `handle_info` clause to forward llm_registry events to browser:
       ```elixir
       def handle_info({:llm_registry_update, detail}, state) do
         formatted = %{
           type: "llm_registry_update",
           detail: to_string(detail)
         }
         {:ok, %{state | pending_events: [formatted | state.pending_events]}}
       end
       ```
    3. Add client message handler for dashboard add/remove endpoint controls:
       ```elixir
       {:ok, %{"type" => "register_llm_endpoint", "host" => host} = body} ->
         port = body["port"] || 11434
         name = body["name"] || "#{host}:#{port}"
         result = case AgentCom.LlmRegistry.register_endpoint(%{host: host, port: port, name: name, source: :manual}) do
           {:ok, endpoint} -> %{type: "llm_endpoint_registered", endpoint: endpoint}
           {:error, reason} -> %{type: "llm_endpoint_error", error: to_string(reason)}
         end
         {:push, {:text, Jason.encode!(result)}, state}

       {:ok, %{"type" => "remove_llm_endpoint", "id" => id}} ->
         result = case AgentCom.LlmRegistry.remove_endpoint(id) do
           :ok -> %{type: "llm_endpoint_removed", id: id}
           {:error, :not_found} -> %{type: "llm_endpoint_error", error: "not_found"}
         end
         {:push, {:text, Jason.encode!(result)}, state}
       ```
       Add these as new pattern matches in the `handle_in` function, alongside existing `request_snapshot`, `retry_task`, and `acknowledge_alert` handlers.
  </action>
  <verify>
    `mix compile --warnings-as-errors` -- no warnings. Grep confirms `llm_registry` subscription in both DashboardState and DashboardSocket. Grep confirms `LlmRegistry.snapshot` call in DashboardState.
  </verify>
  <done>
    DashboardState includes LLM registry data in snapshots. DashboardSocket forwards registry update events and handles add/remove endpoint commands from browser.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add LLM Registry section to dashboard HTML</name>
  <files>lib/agent_com/dashboard.ex</files>
  <action>
    Add a new dashboard section to the HTML in `dashboard.ex`. The dashboard is a 2082-line self-contained HTML page with inline CSS and JS. Add the new section following the existing patterns.

    **CSS additions (in the existing style block):**
    ```css
    /* LLM Registry */
    .llm-fleet-summary { display: flex; gap: 12px; flex-wrap: wrap; margin-bottom: 12px; }
    .llm-fleet-chip { background: #1a1a2e; border: 1px solid #333; border-radius: 6px; padding: 4px 10px; font-size: 0.85em; }
    .llm-table { width: 100%; border-collapse: collapse; font-size: 0.9em; }
    .llm-table th, .llm-table td { padding: 8px 10px; text-align: left; border-bottom: 1px solid #222; }
    .llm-table th { color: #888; font-weight: 500; font-size: 0.85em; text-transform: uppercase; }
    .llm-status-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 6px; }
    .llm-status-healthy { background: #4caf50; }
    .llm-status-unhealthy { background: #f44336; }
    .llm-status-unknown { background: #888; }
    .resource-bar-container { width: 100%; max-width: 120px; height: 8px; background: #1a1a2e; border-radius: 4px; overflow: hidden; display: inline-block; vertical-align: middle; }
    .resource-bar { height: 100%; border-radius: 4px; transition: width 0.5s ease; }
    .resource-bar-cpu { background: #7eb8da; }
    .resource-bar-ram { background: #a78bfa; }
    .resource-bar-vram { background: #f59e0b; }
    .llm-add-form { display: flex; gap: 8px; margin-top: 10px; align-items: center; }
    .llm-add-form input { background: #1a1a2e; border: 1px solid #333; border-radius: 4px; padding: 6px 10px; color: #e0e0e0; font-size: 0.9em; }
    .llm-add-form input::placeholder { color: #666; }
    .llm-add-btn { background: #2563eb; color: white; border: none; border-radius: 4px; padding: 6px 14px; cursor: pointer; font-size: 0.9em; }
    .llm-add-btn:hover { background: #1d4ed8; }
    .llm-remove-btn { background: none; border: none; color: #f44336; cursor: pointer; font-size: 0.85em; padding: 2px 6px; }
    .llm-remove-btn:hover { text-decoration: underline; }
    ```

    **HTML section (add after the existing DETS Health / Rate Limits sections, before closing tags):**
    ```html
    <div class="card" id="llm-registry-section">
      <h2>LLM Registry</h2>
      <div id="llm-fleet-summary" class="llm-fleet-summary"></div>
      <table class="llm-table">
        <thead>
          <tr>
            <th>Status</th>
            <th>Host</th>
            <th>Port</th>
            <th>Models</th>
            <th>Source</th>
            <th>CPU</th>
            <th>RAM</th>
            <th>VRAM</th>
            <th>Last Checked</th>
            <th></th>
          </tr>
        </thead>
        <tbody id="llm-registry-body"></tbody>
      </table>
      <div class="llm-add-form">
        <input type="text" id="llm-add-host" placeholder="Host (e.g. 192.168.1.10)" />
        <input type="number" id="llm-add-port" placeholder="Port" value="11434" style="width: 80px;" />
        <input type="text" id="llm-add-name" placeholder="Name (optional)" />
        <button class="llm-add-btn" onclick="addLlmEndpoint()">Add Endpoint</button>
      </div>
    </div>
    ```

    **JavaScript additions (in the existing script block):**

    Add a `renderLlmRegistry(data)` function that:
    1. Receives `data.llm_registry` from snapshot (contains `endpoints`, `resources`, `fleet_models`).
    2. Renders fleet model summary as chips: e.g. `<span class="llm-fleet-chip">llama3 (3 hosts)</span>`.
    3. Renders each endpoint as a table row with:
       - Status dot (green=healthy, red=unhealthy, gray=unknown)
       - Host, Port
       - Models (comma-separated)
       - Source (auto/manual)
       - CPU bar (from resources map, keyed by endpoint-associated agent or host)
       - RAM bar
       - VRAM bar (or "N/A" if null)
       - Last Checked (relative time, e.g. "30s ago")
       - Remove button (only for manual endpoints, with confirmation)
    4. Resource bars use percentage fill: e.g. CPU bar width = `cpu_percent%`, RAM bar width = `(ram_used / ram_total * 100)%`.

    Add `addLlmEndpoint()` function:
    - Reads host/port/name from form inputs
    - Sends `{"type": "register_llm_endpoint", "host": host, "port": port, "name": name}` via dashboard WebSocket
    - Clears form on success

    Add `removeLlmEndpoint(id)` function:
    - Confirms with user: `confirm("Remove endpoint " + id + "?")`
    - Sends `{"type": "remove_llm_endpoint", "id": id}` via dashboard WebSocket

    Call `renderLlmRegistry(data)` from the existing snapshot handler (where `renderAgents`, `renderQueue`, etc. are called).

    Handle `llm_registry_update` event type in the events handler: trigger a snapshot refresh (send `{"type": "request_snapshot"}` to get fresh data).

    Handle `llm_endpoint_registered` and `llm_endpoint_removed` responses: trigger snapshot refresh.

    **Per locked decisions:**
    - Table view (not cards) -- using `<table>` element
    - Utilization bars alongside endpoint status per host
    - Fleet-level model summary at top
    - Dashboard controls for add/remove (the inline form and remove buttons)
  </action>
  <verify>
    `mix compile --warnings-as-errors` -- no warnings. Start hub with `mix run --no-halt`, navigate to `/dashboard`, confirm LLM Registry section renders (even if empty with no endpoints registered).
  </verify>
  <done>
    Dashboard displays LLM Registry section with fleet model summary, endpoint table with status/models/resources, utilization bars, add endpoint form, and remove buttons. Real-time updates work via WebSocket events.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify dashboard LLM Registry section</name>
  <files>lib/agent_com/dashboard.ex</files>
  <action>
    Human verification of dashboard visual output. No code changes -- this is a visual check of Tasks 1 and 2 output.

    **What was built:** Complete LLM Registry dashboard integration: fleet model summary, endpoint table with status dots and resource utilization bars, add/remove endpoint controls, real-time updates via WebSocket.

    **How to verify:**
    1. Start the hub: `mix run --no-halt`
    2. Open http://localhost:4000/dashboard in browser
    3. Verify the "LLM Registry" section appears (empty table with headers)
    4. Use the "Add Endpoint" form to add a test endpoint (e.g. host: localhost, port: 11434)
       - If Ollama is running locally, it should show as healthy with models listed
       - If not, it should show as unhealthy/unknown after health check runs
    5. Verify the fleet model summary shows model chips (if Ollama is running)
    6. Verify the remove button works (click remove, confirm, endpoint disappears)
    7. Check that resource bars render (they will show data once a sidecar connects and reports)
  </action>
  <verify>User confirms visual output matches expectations.</verify>
  <done>User types "approved" or describes issues to fix.</done>
</task>

</tasks>

<verification>
- `mix compile --warnings-as-errors` -- clean compilation
- `mix test` -- no regressions
- Dashboard loads without JavaScript errors
- LLM Registry section renders correctly
- Add/remove endpoint controls work through the dashboard
</verification>

<success_criteria>
- DashboardState snapshot includes `llm_registry` data
- DashboardSocket forwards `llm_registry_update` events
- Dashboard HTML shows fleet summary, endpoint table, resource bars
- Dashboard controls allow add/remove endpoints (per locked decision: not API-only)
- Real-time updates propagate from LlmRegistry through PubSub to browser
</success_criteria>

<output>
After completion, create `.planning/phases/18-llm-registry-host-resources/18-04-SUMMARY.md`
</output>
