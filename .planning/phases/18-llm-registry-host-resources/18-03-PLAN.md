---
phase: 18-llm-registry-host-resources
plan: 03
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - lib/agent_com/socket.ex
  - lib/agent_com/endpoint.ex
  - lib/agent_com/validation/schemas.ex
  - lib/agent_com/application.ex
autonomous: true

must_haves:
  truths:
    - "Sidecar ollama_report WS message triggers auto-registration in LlmRegistry"
    - "Sidecar resource_report WS message stores metrics in LlmRegistry ETS"
    - "Admin can register an Ollama endpoint via POST /api/admin/llm-registry"
    - "Admin can remove an endpoint via DELETE /api/admin/llm-registry/:id"
    - "Admin can list all endpoints via GET /api/admin/llm-registry"
    - "LlmRegistry GenServer is started in the supervisor tree"
    - "All new WS and HTTP messages have validation schemas"
  artifacts:
    - path: "lib/agent_com/socket.ex"
      provides: "Handlers for ollama_report and resource_report WS messages"
    - path: "lib/agent_com/endpoint.ex"
      provides: "HTTP admin routes for LLM registry CRUD"
      contains: "/api/admin/llm-registry"
    - path: "lib/agent_com/validation/schemas.ex"
      provides: "Schemas for ollama_report, resource_report WS types and HTTP bodies"
    - path: "lib/agent_com/application.ex"
      provides: "LlmRegistry added to supervisor children"
      contains: "AgentCom.LlmRegistry"
  key_links:
    - from: "lib/agent_com/socket.ex"
      to: "lib/agent_com/llm_registry.ex"
      via: "Calls register_endpoint and report_resources"
      pattern: "LlmRegistry\\.(register_endpoint|report_resources)"
    - from: "lib/agent_com/endpoint.ex"
      to: "lib/agent_com/llm_registry.ex"
      via: "Calls register_endpoint, remove_endpoint, list_endpoints"
      pattern: "LlmRegistry\\.(register_endpoint|remove_endpoint|list_endpoints)"
    - from: "lib/agent_com/application.ex"
      to: "lib/agent_com/llm_registry.ex"
      via: "Supervisor child spec"
      pattern: "AgentCom\\.LlmRegistry"
---

<objective>
Wire the LlmRegistry GenServer into the application: supervisor tree entry, WebSocket message handlers for sidecar auto-reporting, HTTP admin endpoints for manual registration, and validation schemas for all new message types.

Purpose: This connects Plan 01's GenServer to the transport layer so sidecars can auto-report and admins can manually manage endpoints.
Output: Working WS handlers, HTTP routes, validation schemas, and supervisor entry.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/18-llm-registry-host-resources/18-CONTEXT.md
@.planning/phases/18-llm-registry-host-resources/18-RESEARCH.md
@.planning/phases/18-llm-registry-host-resources/18-01-SUMMARY.md

@lib/agent_com/socket.ex
@lib/agent_com/endpoint.ex
@lib/agent_com/validation/schemas.ex
@lib/agent_com/application.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WS handlers, HTTP routes, and supervisor entry</name>
  <files>lib/agent_com/socket.ex, lib/agent_com/endpoint.ex, lib/agent_com/application.ex</files>
  <action>
    **1. Application.ex -- Add LlmRegistry to supervisor tree:**
    - Add `{AgentCom.LlmRegistry, []}` to the `children` list in `start/2`.
    - Place it BEFORE `AgentCom.DashboardState` (DashboardState subscribes to PubSub topics from LlmRegistry, so LlmRegistry must start first).
    - Also add ETS table creation for `:llm_resource_metrics` in the ETS setup block at top of start/2 (alongside `:validation_backoff`, `:rate_limit_buckets`, etc.): `:ets.new(:llm_resource_metrics, [:named_table, :public, :set])`. Actually -- if LlmRegistry.init/1 creates its own ETS table, skip this. Check Plan 01 implementation. If the GenServer creates ETS in init, just add the child spec. If it expects pre-created ETS (like rate limiter), create it in application.ex.

    **2. Socket.ex -- Handle ollama_report and resource_report messages:**

    Add two new `handle_msg` clauses after the existing message handlers (before the catch-all):

    ```elixir
    # Sidecar auto-reports local Ollama endpoint
    defp handle_msg(%{"type" => "ollama_report", "ollama_url" => url}, state) when is_binary(url) do
      # Parse URL into host and port
      uri = URI.parse(url)
      host = uri.host || "localhost"
      port = uri.port || 11434

      AgentCom.LlmRegistry.register_endpoint(%{
        host: host,
        port: port,
        name: "#{state.agent_id}-local",
        source: :auto
      })

      reply = Jason.encode!(%{type: "ollama_report_ack", status: "registered"})
      {:push, {:text, reply}, state}
    end

    # Sidecar reports host resource metrics
    defp handle_msg(%{"type" => "resource_report"} = msg, state) do
      metrics = %{
        cpu_percent: msg["cpu_percent"],
        ram_used_bytes: msg["ram_used_bytes"],
        ram_total_bytes: msg["ram_total_bytes"],
        vram_used_bytes: msg["vram_used_bytes"],
        vram_total_bytes: msg["vram_total_bytes"]
      }

      AgentCom.LlmRegistry.report_resources(state.agent_id, metrics)

      # No reply needed -- fire and forget like task_progress
      {:ok, state}
    end
    ```

    Also extend the identify handler: if the identify message contains an `"ollama_url"` field, trigger auto-registration after successful identification. Add this after the existing identify success path:
    ```elixir
    # After successful identify, check for ollama_url
    if ollama_url = msg["ollama_url"] do
      uri = URI.parse(ollama_url)
      host = uri.host || "localhost"
      port = uri.port || 11434
      AgentCom.LlmRegistry.register_endpoint(%{
        host: host,
        port: port,
        name: "#{agent_id}-local",
        source: :auto
      })
    end
    ```

    **3. Endpoint.ex -- Add HTTP admin routes:**

    Add routes in the admin section (after existing `/api/admin/rate-limits` routes):

    ```elixir
    # --- LLM Registry Admin Routes ---

    get "/api/admin/llm-registry" do
      conn = AgentCom.Plugs.RequireAuth.call(conn, [])
      if conn.halted do
        conn
      else
        endpoints = AgentCom.LlmRegistry.list_endpoints()
        send_json(conn, 200, %{endpoints: endpoints})
      end
    end

    get "/api/admin/llm-registry/:id" do
      conn = AgentCom.Plugs.RequireAuth.call(conn, [])
      if conn.halted do
        conn
      else
        case AgentCom.LlmRegistry.get_endpoint(id) do
          {:ok, endpoint} -> send_json(conn, 200, endpoint)
          {:error, :not_found} -> send_json(conn, 404, %{error: "endpoint_not_found"})
        end
      end
    end

    post "/api/admin/llm-registry" do
      conn = AgentCom.Plugs.RequireAuth.call(conn, [])
      if conn.halted do
        conn
      else
        body = conn.body_params
        params = %{
          host: body["host"],
          port: body["port"] || 11434,
          name: body["name"] || "#{body["host"]}:#{body["port"] || 11434}",
          source: :manual
        }

        case AgentCom.LlmRegistry.register_endpoint(params) do
          {:ok, endpoint} -> send_json(conn, 201, endpoint)
          {:error, reason} -> send_json(conn, 400, %{error: to_string(reason)})
        end
      end
    end

    delete "/api/admin/llm-registry/:id" do
      conn = AgentCom.Plugs.RequireAuth.call(conn, [])
      if conn.halted do
        conn
      else
        case AgentCom.LlmRegistry.remove_endpoint(id) do
          :ok -> send_json(conn, 200, %{status: "removed", id: id})
          {:error, :not_found} -> send_json(conn, 404, %{error: "endpoint_not_found"})
        end
      end
    end

    get "/api/admin/llm-registry/snapshot" do
      conn = AgentCom.Plugs.RequireAuth.call(conn, [])
      if conn.halted do
        conn
      else
        snapshot = AgentCom.LlmRegistry.snapshot()
        send_json(conn, 200, snapshot)
      end
    end
    ```

    Update the moduledoc route listing at the top of endpoint.ex to include the new routes.

    **Important:** The `/api/admin/llm-registry/snapshot` route MUST be defined BEFORE `/api/admin/llm-registry/:id` to avoid "snapshot" being captured as an :id parameter. Reorder accordingly.
  </action>
  <verify>
    `mix compile --warnings-as-errors` -- no warnings. Grep for `LlmRegistry` in socket.ex, endpoint.ex, application.ex confirms all wiring present.
  </verify>
  <done>
    LlmRegistry is in the supervisor tree. Socket handles ollama_report and resource_report messages calling LlmRegistry API. HTTP admin routes allow GET/POST/DELETE for endpoint management. Identify message triggers auto-registration when ollama_url is present.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add validation schemas for new WS and HTTP message types</name>
  <files>lib/agent_com/validation/schemas.ex</files>
  <action>
    Add validation schemas for the new message types to `AgentCom.Validation.Schemas`:

    **New WS schemas (add to @ws_schemas map):**

    ```elixir
    "ollama_report" => %{
      required: %{
        "type" => :string,
        "ollama_url" => :string
      },
      optional: %{},
      description: "Sidecar reports local Ollama endpoint URL for auto-registration."
    },
    "resource_report" => %{
      required: %{
        "type" => :string
      },
      optional: %{
        "cpu_percent" => :number,
        "ram_used_bytes" => :number,
        "ram_total_bytes" => :number,
        "vram_used_bytes" => :number,
        "vram_total_bytes" => :number,
        "timestamp" => :number
      },
      description: "Sidecar reports host resource utilization (CPU, RAM, VRAM)."
    },
    ```

    **New HTTP schemas (add to @http_schemas map):**

    ```elixir
    "post_llm_registry" => %{
      required: %{
        "host" => :string
      },
      optional: %{
        "port" => :number,
        "name" => :string
      },
      description: "Register an Ollama endpoint. Port defaults to 11434."
    },
    ```

    Also add "ollama_url" to the `@length_limits` map with a limit of 512 (same as "repo").

    Ensure the identify schema's optional fields include `"ollama_url" => :string` so the extended identify message validates.
  </action>
  <verify>
    `mix compile --warnings-as-errors` -- no warnings. `curl http://localhost:4000/api/schemas` should include the new schemas (when hub is running).
  </verify>
  <done>
    Validation schemas exist for ollama_report, resource_report WS types and post_llm_registry HTTP body. Identify schema accepts optional ollama_url. Length limit on ollama_url is 512.
  </done>
</task>

</tasks>

<verification>
- `mix compile --warnings-as-errors` -- clean compilation
- `mix test` -- existing tests still pass (no regressions)
- Grep confirms: `LlmRegistry` referenced in application.ex, socket.ex, endpoint.ex
- Grep confirms: `ollama_report` and `resource_report` in validation schemas
</verification>

<success_criteria>
- LlmRegistry GenServer starts with the application
- WebSocket ollama_report triggers endpoint registration
- WebSocket resource_report stores metrics
- HTTP GET/POST/DELETE /api/admin/llm-registry routes work
- All message types have validation schemas
- No compilation warnings, no test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/18-llm-registry-host-resources/18-03-SUMMARY.md`
</output>
