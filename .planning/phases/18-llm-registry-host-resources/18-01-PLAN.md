---
phase: 18-llm-registry-host-resources
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/agent_com/llm_registry.ex
  - test/agent_com/llm_registry_test.exs
autonomous: true

must_haves:
  truths:
    - "LlmRegistry stores endpoint registrations in DETS and reloads them on restart"
    - "LlmRegistry discovers models by querying Ollama /api/tags after registration"
    - "Health check timer marks unreachable endpoints as unhealthy within one cycle"
    - "A previously unhealthy endpoint is immediately re-marked healthy on successful check"
    - "Resource metrics are stored in ETS and cleared after a configurable stale timeout"
    - "Endpoints can be registered, listed, and removed via public API functions"
  artifacts:
    - path: "lib/agent_com/llm_registry.ex"
      provides: "GenServer managing Ollama endpoint registry with DETS + ETS hybrid"
      exports: ["start_link/1", "register_endpoint/1", "remove_endpoint/1", "list_endpoints/0", "get_endpoint/1", "report_resources/2", "get_resources/1", "snapshot/0"]
    - path: "test/agent_com/llm_registry_test.exs"
      provides: "Tests for registration CRUD, health checks, resource tracking, stale clearing"
  key_links:
    - from: "lib/agent_com/llm_registry.ex"
      to: ":dets"
      via: "DETS table for endpoint persistence"
      pattern: ":dets\\.(open_file|insert|lookup|delete)"
    - from: "lib/agent_com/llm_registry.ex"
      to: ":ets"
      via: "ETS table for ephemeral resource metrics"
      pattern: ":ets\\.(new|insert|lookup|delete)"
    - from: "lib/agent_com/llm_registry.ex"
      to: ":httpc"
      via: "HTTP GET to Ollama /api/tags and health check"
      pattern: ":httpc\\.request"
    - from: "lib/agent_com/llm_registry.ex"
      to: "Phoenix.PubSub"
      via: "Broadcasts registry changes on llm_registry topic"
      pattern: "PubSub\\.broadcast.*llm_registry"
---

<objective>
Build the AgentCom.LlmRegistry GenServer that tracks Ollama endpoints, performs health checks, discovers models, and stores ephemeral resource metrics.

Purpose: This is the core data layer for Phase 18. All other plans (HTTP API, WS handlers, dashboard) depend on this module's public API.
Output: Working, tested GenServer with DETS persistence for endpoints and ETS for resources.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/18-llm-registry-host-resources/18-CONTEXT.md
@.planning/phases/18-llm-registry-host-resources/18-RESEARCH.md

@lib/agent_com/config.ex (GenServer + DETS pattern reference)
@lib/agent_com/metrics_collector.ex (ETS pattern reference)
@lib/agent_com/application.ex (supervisor tree -- do NOT modify in this plan)
</context>

<feature>
  <name>LLM Registry GenServer</name>
  <files>lib/agent_com/llm_registry.ex, test/agent_com/llm_registry_test.exs</files>
  <behavior>
    ## Data Model

    Endpoint (DETS-persisted):
    ```
    %{
      id: "host:port" (string, primary key),
      host: string,
      port: integer,
      name: string (optional display name),
      source: :auto | :manual,
      status: :unknown | :healthy | :unhealthy,
      models: [string],           # binary list from /api/tags, e.g. ["llama3", "codellama"]
      registered_at: integer (ms),
      last_checked_at: integer (ms) | nil,
      consecutive_failures: integer
    }
    ```

    Resource metrics (ETS-ephemeral):
    ```
    Key: host_id (string, e.g. agent_id or host identifier)
    Value: %{
      cpu_percent: float,          # average across cores (0.0-100.0)
      ram_used_bytes: integer,
      ram_total_bytes: integer,
      vram_used_bytes: integer | nil,
      vram_total_bytes: integer | nil,
      reported_at: integer (ms),
      source_agent_id: string
    }
    ```

    ## Public API

    - `register_endpoint(%{host: h, port: p, name: n, source: :auto | :manual})` -> `{:ok, endpoint}` | `{:error, reason}`
      Stores in DETS, triggers async model discovery via /api/tags, sets status to :unknown.
    - `remove_endpoint(id)` -> `:ok` | `{:error, :not_found}`
      Removes from DETS.
    - `list_endpoints()` -> [endpoint]
      Returns all endpoints from DETS.
    - `get_endpoint(id)` -> `{:ok, endpoint}` | `{:error, :not_found}`
    - `report_resources(host_id, metrics_map)` -> `:ok`
      Writes to ETS. Resets stale timer for that host.
    - `get_resources(host_id)` -> `{:ok, metrics}` | `{:error, :not_found}`
    - `snapshot()` -> `%{endpoints: [...], resources: %{}, fleet_models: %{}}`
      Pre-computed summary for dashboard.

    ## Health Check Behavior (Claude's Discretion)

    - Poll every 30 seconds via `Process.send_after(self(), :health_check, 30_000)`
    - HTTP GET to `http://{host}:{port}/api/tags` using `:httpc`
    - Success: status -> :healthy, consecutive_failures -> 0, update models list
    - Failure: increment consecutive_failures; mark :unhealthy after 2 consecutive failures
    - Recovery: immediate on first success (per research recommendation)
    - On hub restart: load from DETS, set all statuses to :unknown, schedule immediate health check

    ## Stale Resource Clearing

    - Every 60 seconds, sweep ETS for entries where `reported_at` is older than 90 seconds
    - Delete stale entries (they show as "unknown" on dashboard when absent)

    ## PubSub Events

    - Broadcast `{:llm_registry_update, :endpoint_changed}` on register/remove/health change
    - Broadcast on "llm_registry" topic

    ## Test Cases

    - register_endpoint/1 with valid params returns {:ok, endpoint} with correct fields
    - register_endpoint/1 with duplicate id updates existing (upsert)
    - remove_endpoint/1 returns :ok for existing, {:error, :not_found} for missing
    - list_endpoints/0 returns all registered endpoints
    - get_endpoint/1 returns {:ok, _} for existing, {:error, :not_found} for missing
    - report_resources/2 stores in ETS, get_resources/1 retrieves it
    - Health check marks endpoint :unhealthy after 2 consecutive failures
    - Health check marks endpoint :healthy immediately on success
    - snapshot/0 includes endpoints, resources, and fleet_models aggregation
    - Stale resources are cleared after timeout
  </behavior>
  <implementation>
    GenServer with `use GenServer`. DETS table opened in `init/1` at `~/.agentcom/data/llm_registry.dets`.
    ETS table `:llm_resource_metrics` created in `init/1` as `:named_table, :public, :set`.

    Health check timer via `Process.send_after` in `init/1` and recurring in `handle_info(:health_check, state)`.
    Stale sweep timer via `Process.send_after` in `init/1` and recurring in `handle_info(:sweep_stale_resources, state)`.

    Model discovery: on register, spawn `Task.async` to GET `http://host:port/api/tags`, parse JSON response for model names, update DETS entry. Use `:httpc.request(:get, {url, []}, [{:timeout, 5000}], [])` pattern.

    For health checks, iterate all endpoints and call `:httpc.request` for each. For small numbers of endpoints (< 20), sequential in handle_info is fine per research recommendation.

    Fleet model summary: computed in snapshot/0 by grouping endpoints by model name and counting hosts.

    Follow the Config.ex pattern for DETS open/close/init. Follow MetricsCollector pattern for ETS usage.
  </implementation>
</feature>

<verification>
- `mix test test/agent_com/llm_registry_test.exs` -- all tests pass
- `mix compile --warnings-as-errors` -- no warnings
</verification>

<success_criteria>
- LlmRegistry GenServer starts, opens DETS table, creates ETS table
- Endpoint CRUD operations work correctly with DETS persistence
- Health checks poll endpoints and update status correctly
- Resource metrics stored in ETS and cleared when stale
- All test cases pass
- PubSub broadcasts on registry changes
</success_criteria>

<output>
After completion, create `.planning/phases/18-llm-registry-host-resources/18-01-SUMMARY.md`
</output>
