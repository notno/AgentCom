---
phase: 40-sidecar-tool-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["40-01"]
files_modified:
  - sidecar/lib/tools/tool-executor.js
  - sidecar/test/tools/tool-executor.test.js
autonomous: true
must_haves:
  truths:
    - "executeTool dispatches to correct handler for all 5 tool names"
    - "read_file returns file content with line count and path in structured JSON"
    - "write_file creates files with parent directories and returns bytes_written"
    - "list_directory returns entries with name, type, and size"
    - "run_command executes commands with timeout enforcement and SIGTERM/SIGKILL escalation"
    - "search_files returns matching lines with file path, line number, and content"
    - "All tools return structured JSON observations with success, tool, output, and error fields"
    - "File tools reject paths outside workspace via sandbox"
    - "run_command rejects blocked commands via sandbox"
    - "Per-tool timeout kills long-running commands"
  artifacts:
    - path: "sidecar/lib/tools/tool-executor.js"
      provides: "Tool execution dispatch with 5 handlers"
      exports: ["executeTool"]
    - path: "sidecar/test/tools/tool-executor.test.js"
      provides: "Tool executor integration tests"
  key_links:
    - from: "sidecar/lib/tools/tool-executor.js"
      to: "sidecar/lib/tools/sandbox.js"
      via: "validatePath and isCommandBlocked calls"
      pattern: "require.*sandbox"
    - from: "sidecar/lib/tools/tool-executor.js"
      to: "sidecar/lib/tools/tool-registry.js"
      via: "getToolByName for validation"
      pattern: "require.*tool-registry"
---

<objective>
Create the tool executor that dispatches tool calls to handler functions and returns structured JSON observations.

Purpose: This is the execution engine that Phase 41's ReAct loop calls when Ollama returns tool_calls. Each tool call goes through sandbox validation, then handler execution, then structured response formatting.

Output: tool-executor.js with handlers for all 5 tools plus comprehensive integration tests.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/40-sidecar-tool-infrastructure/40-RESEARCH.md
@.planning/phases/40-sidecar-tool-infrastructure/40-01-SUMMARY.md
@sidecar/lib/tools/tool-registry.js
@sidecar/lib/tools/sandbox.js
@sidecar/lib/execution/shell-executor.js
@sidecar/lib/log.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Tool executor with 5 handlers and structured observations</name>
  <files>sidecar/lib/tools/tool-executor.js</files>
  <action>
Create `sidecar/lib/tools/tool-executor.js` with a single export: `executeTool(toolName, args, workspaceRoot)`.

**Response envelope** — every tool returns this shape:
```javascript
{
  success: true|false,
  tool: 'tool_name',
  output: { /* typed fields per tool */ } | null,
  error: { code: 'ERROR_CODE', message: 'Human-readable' } | null
}
```

**Handler implementations:**

1. **read_file(args, workspaceRoot)**
   - Validate path via `sandbox.validatePath(args.path, workspaceRoot)`
   - Check file size — if > 1MB, return error `FILE_TOO_LARGE` with file size in message
   - Check for binary content — read first 8KB, if contains null bytes return error `BINARY_FILE` with file size as output
   - Read with `fs.readFileSync(resolved, 'utf-8')`
   - If start_line/end_line provided, slice lines (1-based inclusive)
   - Return: `{ content: string, lines: number, path: string, truncated: boolean }`

2. **write_file(args, workspaceRoot)**
   - Validate path via sandbox
   - If `create_dirs !== false`, create parent dirs with `fs.mkdirSync(dir, { recursive: true })`
   - Write with `fs.writeFileSync(resolved, args.content, 'utf-8')`
   - Return: `{ path: string, bytes_written: number, created: boolean }` (created = file didn't exist before)

3. **list_directory(args, workspaceRoot)**
   - Validate path via sandbox
   - Read directory with `fs.readdirSync(resolved, { withFileTypes: true })`
   - If recursive, walk subdirectories (limit depth to 5 levels to prevent runaway)
   - If pattern provided, filter entries by simple glob match (startsWith/endsWith/includes for basic patterns, or convert simple globs like `*.js` to regex)
   - Return: `{ entries: [{ name, type: 'file'|'directory', size: number|null }], total: number, path: string }`
   - Cap entries at 500 to prevent memory issues

4. **run_command(args, workspaceRoot)**
   - Check command is not blocked via `sandbox.isCommandBlocked(args.command)`
   - Use `child_process.spawn` with `shell: true`, `cwd: workspaceRoot`, `windowsHide: true`
   - Timeout: `args.timeout_ms || 30000` — use SIGTERM then SIGKILL after 5s grace (same pattern as ShellExecutor)
   - Collect stdout and stderr as strings
   - Return: `{ stdout: string, stderr: string, exit_code: number, timed_out: boolean }`
   - On timeout, set timed_out: true, include partial stdout/stderr

5. **search_files(args, workspaceRoot)**
   - Validate path via sandbox (args.path defaults to ".")
   - Walk files recursively from search root
   - Skip `.git`, `node_modules`, and other common ignore directories
   - For each file, read line-by-line using `fs.createReadStream` + `readline.createInterface`
   - Match each line against `new RegExp(args.pattern)` — wrap in try/catch for invalid regex
   - If file_pattern provided, filter files (e.g., `*.js` matches only .js files)
   - Cap at `args.max_results || 50` matches
   - Return: `{ matches: [{ file: string, line: number, content: string }], total_matches: number, files_searched: number, truncated: boolean }`

**Error handling:** Wrap each handler in try/catch. If SandboxError, return `{ success: false, error: { code: err.code, message: err.message } }`. For other errors, use code `EXECUTION_ERROR`.

**Logging:** Use the sidecar log module for tool executions: `log('info', 'tool_executed', { tool, success, duration_ms })`.
  </action>
  <verify>
Run `node -e "const t = require('./sidecar/lib/tools/tool-executor'); t.executeTool('read_file', {path: 'package.json'}, './sidecar').then(r => console.log(JSON.stringify(r, null, 2)))"` — outputs structured JSON with success:true, content of package.json.
  </verify>
  <done>
All 5 tool handlers implemented with sandbox validation, timeout enforcement, and structured JSON observation responses.
  </done>
</task>

<task type="auto">
  <name>Task 2: Comprehensive tool executor tests</name>
  <files>sidecar/test/tools/tool-executor.test.js</files>
  <action>
Create `sidecar/test/tools/tool-executor.test.js` using Node.js built-in test runner (`node:test` + `node:assert`).

Use a temporary directory as workspace for each test (create in `before`, clean up in `after`). Use `fs.mkdtempSync(path.join(os.tmpdir(), 'tool-test-'))` for isolation.

**Test groups:**

**1. executeTool dispatch:**
- Returns error for unknown tool name
- Returns structured JSON envelope for all known tools

**2. read_file tests:**
- Reads a text file and returns content with line count
- Respects start_line and end_line (1-based inclusive)
- Rejects path traversal (../../../etc/passwd)
- Returns error for nonexistent file
- Returns FILE_TOO_LARGE for files > 1MB (create a temp file > 1MB for this)

**3. write_file tests:**
- Writes a new file and returns bytes_written
- Creates parent directories automatically
- Overwrites existing file
- Rejects path traversal
- Returns created: true for new file, created: false for overwrite

**4. list_directory tests:**
- Lists files and directories with correct types
- Recursive listing includes subdirectory contents
- Pattern filtering works (e.g., `*.js` filters correctly)
- Rejects path traversal

**5. run_command tests:**
- Runs simple command (echo hello) and captures stdout
- Captures stderr separately
- Returns exit_code for failed commands (exit 1)
- Blocks dangerous commands (sudo, rm -rf /)
- Enforces timeout — run `node -e "setTimeout(()=>{}, 60000)"` with 500ms timeout, verify timed_out: true
  (Use a short timeout to keep test fast)

**6. search_files tests:**
- Finds pattern in files, returns matches with file/line/content
- Respects max_results limit
- Returns error for invalid regex
- Skips .git and node_modules directories
- file_pattern filtering works

**Important test patterns:**
- Each test creates its own files in the temp workspace — fully isolated
- Use `describe`/`it` style with `node:test`
- Assert structured JSON envelope shape: `{ success, tool, output, error }`
- Use `assert.strictEqual`, `assert.ok`, `assert.deepStrictEqual`
  </action>
  <verify>
Run `node --test sidecar/test/tools/tool-executor.test.js` — all tests pass.
Count: at least 15 test cases covering all 5 tools plus dispatch and error handling.
  </verify>
  <done>
Comprehensive test suite validates all 5 tools with both happy path and error/security cases, all tests pass.
  </done>
</task>

</tasks>

<verification>
1. `node --test sidecar/test/tools/tool-executor.test.js` — all pass
2. `node --test sidecar/test/tools/tool-registry.test.js` — still passes (regression)
3. `node --test sidecar/test/tools/sandbox.test.js` — still passes (regression)
4. Manual smoke test: read_file returns structured JSON, write_file creates a file, list_directory lists entries, run_command captures output, search_files finds patterns
5. Path traversal blocked in all file tools
6. Blocked commands rejected in run_command
7. Timeout kills long-running commands
</verification>

<success_criteria>
- executeTool dispatches all 5 tools correctly (AGENT-01, AGENT-02)
- Path traversal blocked on all file operations (AGENT-02)
- Command timeout kills exceeded processes (AGENT-02)
- Every tool returns structured JSON observation (AGENT-06)
- All tests pass (15+ test cases)
- Zero new npm dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/40-sidecar-tool-infrastructure/40-02-SUMMARY.md`
</output>
