---
phase: 29-hub-fsm-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/agent_com/hub_fsm.ex
  - lib/agent_com/hub_fsm/predicates.ex
  - lib/agent_com/hub_fsm/history.ex
  - lib/agent_com/application.ex
autonomous: true

must_haves:
  truths:
    - "HubFSM starts as a singleton GenServer in :resting state on application boot"
    - "HubFSM transitions from :resting to :executing when GoalBacklog has pending goals"
    - "HubFSM transitions from :executing to :resting when no pending or active goals remain"
    - "HubFSM can be paused, halting all autonomous transitions until resumed"
    - "Watchdog timer force-transitions to :resting after 2 hours stuck in any state"
    - "Every transition is recorded in ETS history with timestamp, reason, and duration"
    - "Budget exhaustion in any state forces transition to :resting"
  artifacts:
    - path: "lib/agent_com/hub_fsm.ex"
      provides: "HubFSM GenServer with 2-state core, tick-based evaluation, timer management, PubSub subscriptions"
      contains: "@valid_transitions"
    - path: "lib/agent_com/hub_fsm/predicates.ex"
      provides: "Pure transition predicate functions"
      exports: ["evaluate/2"]
    - path: "lib/agent_com/hub_fsm/history.ex"
      provides: "ETS-backed transition history with cap and query"
      exports: ["init_table/0", "record/4", "list/1", "current_state/0"]
  key_links:
    - from: "lib/agent_com/hub_fsm.ex"
      to: "lib/agent_com/hub_fsm/predicates.ex"
      via: "Predicates.evaluate/2 called during tick"
      pattern: "Predicates\\.evaluate"
    - from: "lib/agent_com/hub_fsm.ex"
      to: "lib/agent_com/hub_fsm/history.ex"
      via: "History.record/4 called on every transition"
      pattern: "History\\.record"
    - from: "lib/agent_com/hub_fsm.ex"
      to: "lib/agent_com/goal_backlog.ex"
      via: "GoalBacklog.stats/0 called in gather_system_state"
      pattern: "GoalBacklog\\.stats"
    - from: "lib/agent_com/hub_fsm.ex"
      to: "lib/agent_com/cost_ledger.ex"
      via: "CostLedger.check_budget/1 called in gather_system_state"
      pattern: "CostLedger\\.check_budget"
    - from: "lib/agent_com/application.ex"
      to: "lib/agent_com/hub_fsm.ex"
      via: "Supervision tree child after GoalBacklog"
      pattern: "AgentCom\\.HubFSM"
---

<objective>
Implement the HubFSM GenServer -- the autonomous brain of the system -- with a 2-state core (Executing + Resting), tick-based evaluation, comprehensive timer management, and pause/resume support.

Purpose: This is the central state machine that drives all autonomous hub behavior. It determines when the hub should execute goals vs rest, using queue state and budget as transition inputs.

Output: Three source files (hub_fsm.ex, predicates.ex, history.ex) and supervision tree integration. The FSM starts in :resting and transitions based on GoalBacklog and CostLedger state.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-hub-fsm-core/29-RESEARCH.md
@.planning/phases/29-hub-fsm-core/29-CONTEXT.md
@lib/agent_com/agent_fsm.ex (reference pattern: @valid_transitions, timer management)
@lib/agent_com/scheduler.ex (reference pattern: PubSub subscriptions, tick-based evaluation)
@lib/agent_com/cost_ledger.ex (reference pattern: ETS for fast reads, check_budget/1 API)
@lib/agent_com/goal_backlog.ex (reference: stats/0, dequeue/0, list/1 APIs)
@lib/agent_com/claude_client.ex (reference: set_hub_state/1 API)
@lib/agent_com/application.ex (supervision tree)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement HubFSM.Predicates and HubFSM.History modules</name>
  <files>lib/agent_com/hub_fsm/predicates.ex, lib/agent_com/hub_fsm/history.ex</files>
  <action>
Create `lib/agent_com/hub_fsm/predicates.ex`:
- Module `AgentCom.HubFSM.Predicates`
- `evaluate/2` pure function: `evaluate(current_state, system_state) -> {:transition, new_state, reason} | :stay`
- `system_state` is a map with keys: `:pending_goals`, `:active_goals`, `:budget_exhausted`
- For 2-state core:
  - `:resting` + pending_goals > 0 -> `{:transition, :executing, "pending goals in backlog"}`
  - `:resting` + budget_exhausted -> `:stay` (already resting)
  - `:executing` + budget_exhausted -> `{:transition, :resting, "budget exhausted"}`
  - `:executing` + pending_goals == 0 AND active_goals == 0 -> `{:transition, :resting, "no pending or active goals"}`
  - `:executing` + otherwise -> `:stay`
  - `:resting` + otherwise -> `:stay`
- Include @moduledoc and @doc on evaluate/2

Create `lib/agent_com/hub_fsm/history.ex`:
- Module `AgentCom.HubFSM.History`
- ETS table name: `:hub_fsm_history`
- `init_table/0` -- creates ETS named_table, public, ordered_set, read_concurrency: true. Returns `:ok`. Uses safe pattern: if table exists already, skip creation.
- `record/4` -- `record(from_state, to_state, reason, transition_number)`. Computes timestamp via System.system_time(:millisecond). Inserts `{{-timestamp, transition_number}, %{from: from, to: to, reason: reason, timestamp: timestamp, transition_number: transition_number}}`. Calls `trim/0` after insert.
- `list/1` -- `list(opts \\ [])`. Options: `:limit` (default 50). Returns list of history entry maps sorted newest-first. Uses `:ets.tab2list/1` then sorts and takes limit.
- `current_state/0` -- Returns the most recent `to` state from history, or nil if empty. Reads from ETS directly (for dashboard fast reads without GenServer.call).
- `trim/0` (private) -- Caps history at 200 entries. If size > 200, deletes oldest entries (highest key values since timestamps are negated).
- `clear/0` -- Deletes all entries (for testing).
- Include @moduledoc
  </action>
  <verify>
Run `mix compile --warnings-as-errors` and verify both modules compile without warnings. Run `mix format --check-formatted` on both files.
  </verify>
  <done>
Both Predicates and History modules exist with documented public APIs. Predicates.evaluate/2 handles all 2-state transitions. History provides ETS-backed storage with init, record, list, current_state, and trim.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement HubFSM GenServer with supervision tree integration</name>
  <files>lib/agent_com/hub_fsm.ex, lib/agent_com/application.ex</files>
  <action>
Create `lib/agent_com/hub_fsm.ex`:
- Module `AgentCom.HubFSM`, `use GenServer`, `require Logger`
- @valid_transitions map (2-state core):
  ```
  %{resting: [:executing], executing: [:resting]}
  ```
- @tick_interval_ms 1_000 (1 second tick for transition evaluation)
- @watchdog_ms 2 * 60 * 60 * 1_000 (2 hours)

- Struct fields: fsm_state, last_state_change, tick_ref, watchdog_ref, cycle_count (integer, increments each time we go resting->executing), paused (boolean, default false), transition_count (integer, default 0)

- Client API:
  - `start_link/1` with name: __MODULE__
  - `get_state/0` -> GenServer.call :get_state. Returns map: %{fsm_state, paused, last_state_change, cycle_count, transition_count}
  - `pause/0` -> GenServer.call :pause. Cancels all timers. Sets paused: true. Broadcasts state change. Returns :ok or {:error, :already_paused}
  - `resume/0` -> GenServer.call :resume. Sets paused: false. Re-arms tick and watchdog timers. Broadcasts state change. Returns :ok or {:error, :not_paused}
  - `history/1` -> GenServer.call {:history, opts}. Delegates to History.list/1
  - `force_transition/2` -> GenServer.call {:force_transition, new_state, reason}. For testing/admin. Validates against @valid_transitions.

- init/1:
  1. Call History.init_table() FIRST
  2. Subscribe to PubSub topics: "goals", "tasks"
  3. Set initial state: fsm_state: :resting, last_state_change: System.system_time(:millisecond), cycle_count: 0
  4. Arm tick timer and watchdog timer
  5. Record initial transition via History.record(nil, :resting, "hub_fsm_started", 0)
  6. Broadcast state change via PubSub to "hub_fsm" topic
  7. Call ClaudeClient.set_hub_state(:executing) -- use try/catch in case ClaudeClient not started yet
  8. Logger.info("hub_fsm_started")

- handle_call(:get_state, ...) -- return state map
- handle_call(:pause, ...) -- check paused flag, cancel timers, set paused, broadcast, log
- handle_call(:resume, ...) -- check paused flag, re-arm timers, unset paused, broadcast, log
- handle_call({:history, opts}, ...) -- delegate to History.list(opts)
- handle_call({:force_transition, new_state, reason}, ...) -- validate and do_transition

- handle_info(:tick, %{paused: true} = state):
  - Re-arm tick timer (keep ticking even when paused so resume doesn't need special logic)
  - {:noreply, updated_state}

- handle_info(:tick, state):
  - Call gather_system_state()
  - Call Predicates.evaluate(state.fsm_state, system_state)
  - If {:transition, new_state, reason} -> do_transition(state, new_state, reason)
  - Re-arm tick timer
  - {:noreply, updated_state}

- handle_info(:watchdog_timeout, %{paused: true} = state):
  - Log warning "watchdog_timeout while paused, ignoring"
  - {:noreply, state}

- handle_info(:watchdog_timeout, state):
  - Log warning with current state and duration
  - Emit telemetry [:agent_com, :hub_fsm, :watchdog_timeout]
  - Force transition to :resting with reason "watchdog timeout: stuck in #{state.fsm_state} for > 2 hours"
  - {:noreply, updated_state}

- handle_info for PubSub events (catch-all for goal and task events):
  - Simply {:noreply, state} -- we rely on tick-based evaluation, NOT per-event evaluation. PubSub subscription exists so future phases can add event-specific behavior. Per research: "tick-based evaluation at 1-second intervals, NOT per-event evaluation".

- Private functions:
  - `gather_system_state/0`: Call GoalBacklog.stats() (with try/catch for safety), extract pending_goals count from by_status.submitted, active_goals count from decomposing+executing+verifying. Call CostLedger.check_budget(:executing) (with try/catch). Return system_state map.
  - `do_transition/3`: Validate new_state is in @valid_transitions[current_state]. Cancel watchdog timer. Record in History. Update ClaudeClient hub state (try/catch). Emit telemetry [:agent_com, :hub_fsm, :transition]. Broadcast to "hub_fsm" PubSub topic. Arm new watchdog timer. Update cycle_count if transitioning resting->executing. Log transition. Return updated state struct.
  - `broadcast_state_change/1`: Phoenix.PubSub.broadcast to "hub_fsm" topic with {:hub_fsm_state_change, %{fsm_state, paused, last_state_change, cycle_count, timestamp}}
  - `cancel_timer/1`: nil -> :ok, ref -> Process.cancel_timer(ref)
  - `arm_tick/0`, `arm_watchdog/0`: Process.send_after helpers

Update `lib/agent_com/application.ex`:
- Add `{AgentCom.HubFSM, []}` AFTER GoalBacklog and BEFORE Bandit in the children list (position 28, between GoalBacklog and Bandit).
  </action>
  <verify>
Run `mix compile --warnings-as-errors`. Verify `AgentCom.HubFSM` appears in the supervision tree children list. Run `mix format --check-formatted`.
  </verify>
  <done>
HubFSM GenServer starts in supervision tree after GoalBacklog. It initializes in :resting state, subscribes to PubSub, runs tick-based evaluation every 1 second, has pause/resume support, watchdog timer, and broadcasts state changes to "hub_fsm" topic. All timers are properly cancelled on every transition.
  </done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` passes with zero warnings
2. `mix format --check-formatted` passes for all new files
3. Application supervision tree includes HubFSM after GoalBacklog
4. HubFSM module defines @valid_transitions with 2-state core
5. Predicates module has evaluate/2 for both :resting and :executing states
6. History module creates ETS table and provides record/list/current_state
</verification>

<success_criteria>
HubFSM GenServer compiles, starts in supervision tree, and has complete 2-state core with tick-based evaluation, timer management, pause/resume, watchdog, ETS history, PubSub broadcasting, and CostLedger/GoalBacklog integration.
</success_criteria>

<output>
After completion, create `.planning/phases/29-hub-fsm-core/29-01-SUMMARY.md`
</output>
