---
phase: 29-hub-fsm-core
plan: 02
type: execute
wave: 2
depends_on: ["29-01"]
files_modified:
  - lib/agent_com/endpoint.ex
  - lib/agent_com/telemetry.ex
  - lib/agent_com/dashboard_socket.ex
  - lib/agent_com/dashboard_state.ex
  - lib/agent_com/dashboard.ex
autonomous: true

must_haves:
  truths:
    - "POST /api/hub/pause pauses the HubFSM and returns 200 with status paused"
    - "POST /api/hub/resume resumes the HubFSM and returns 200 with status resumed"
    - "GET /api/hub/state returns current FSM state, paused flag, and transition count"
    - "GET /api/hub/history returns transition history with timestamps and reasons"
    - "Dashboard WebSocket receives hub_fsm_state_change events in real time"
    - "Dashboard shows current FSM state, paused indicator, and transition timeline"
    - "Telemetry handler logs hub_fsm transition events"
  artifacts:
    - path: "lib/agent_com/endpoint.ex"
      provides: "Hub FSM API routes: pause, resume, state, history"
      contains: "/api/hub/"
    - path: "lib/agent_com/telemetry.ex"
      provides: "Telemetry handler for hub_fsm transitions"
      contains: "hub_fsm"
    - path: "lib/agent_com/dashboard_socket.ex"
      provides: "PubSub subscription to hub_fsm topic"
      contains: "hub_fsm"
    - path: "lib/agent_com/dashboard_state.ex"
      provides: "Hub FSM state in dashboard snapshot"
      contains: "hub_fsm"
  key_links:
    - from: "lib/agent_com/endpoint.ex"
      to: "lib/agent_com/hub_fsm.ex"
      via: "API routes call HubFSM.pause/resume/get_state/history"
      pattern: "HubFSM\\."
    - from: "lib/agent_com/dashboard_socket.ex"
      to: "lib/agent_com/hub_fsm.ex"
      via: "Subscribes to hub_fsm PubSub topic"
      pattern: "hub_fsm"
    - from: "lib/agent_com/dashboard_state.ex"
      to: "lib/agent_com/hub_fsm.ex"
      via: "Includes HubFSM state in snapshot"
      pattern: "HubFSM\\.get_state"
---

<objective>
Wire HubFSM into the API layer, dashboard, and telemetry so the FSM state is observable and controllable from external interfaces.

Purpose: The FSM is only useful if humans can see its state, pause it for safety, and monitor transitions. This plan adds all the integration points.

Output: API endpoints for pause/resume/state/history, dashboard WebSocket integration, dashboard HTML panel for FSM state, and telemetry handler for transition logging.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-hub-fsm-core/29-RESEARCH.md
@.planning/phases/29-hub-fsm-core/29-01-SUMMARY.md
@lib/agent_com/endpoint.ex (existing API routes to follow pattern)
@lib/agent_com/telemetry.ex (existing telemetry handlers)
@lib/agent_com/dashboard_socket.ex (existing PubSub subscription pattern)
@lib/agent_com/dashboard_state.ex (existing snapshot aggregation)
@lib/agent_com/dashboard.ex (existing dashboard HTML)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Hub FSM API endpoints and telemetry handler</name>
  <files>lib/agent_com/endpoint.ex, lib/agent_com/telemetry.ex</files>
  <action>
Add to `lib/agent_com/endpoint.ex` -- Place these routes AFTER the goal API routes section, BEFORE the catch-all match. Add a comment header `# --- Hub FSM API ---`:

1. `POST /api/hub/pause` (auth required):
   - Call AgentCom.Plugs.RequireAuth.call(conn, [])
   - If not halted, call AgentCom.HubFSM.pause()
   - On :ok -> send_json(conn, 200, %{"status" => "paused"})
   - On {:error, :already_paused} -> send_json(conn, 200, %{"status" => "already_paused"})

2. `POST /api/hub/resume` (auth required):
   - Call AgentCom.Plugs.RequireAuth.call(conn, [])
   - If not halted, call AgentCom.HubFSM.resume()
   - On :ok -> send_json(conn, 200, %{"status" => "resumed"})
   - On {:error, :not_paused} -> send_json(conn, 200, %{"status" => "not_paused"})

3. `GET /api/hub/state` (no auth -- dashboard reads this):
   - try/catch around AgentCom.HubFSM.get_state()
   - On success: send_json(conn, 200, state_map) -- convert atom keys to strings for JSON
   - On error (HubFSM not started): send_json(conn, 503, %{"error" => "hub_fsm not available"})

4. `GET /api/hub/history` (no auth -- dashboard reads this):
   - Parse optional query param "limit" (default 50, max 200)
   - try/catch around AgentCom.HubFSM.history(limit: limit)
   - On success: send_json(conn, 200, %{"transitions" => transitions}) -- convert atom values to strings for JSON
   - On error: send_json(conn, 503, %{"error" => "hub_fsm not available"})

Update `lib/agent_com/telemetry.ex`:

1. Add to the event catalog in the @moduledoc:
   - `[:agent_com, :hub_fsm, :transition]` -- Hub FSM state transition. measurements: `%{duration_ms: integer}`, metadata: `%{from_state: atom, to_state: atom, reason: string}`
   - `[:agent_com, :hub_fsm, :watchdog_timeout]` -- Watchdog timer fired. measurements: `%{}`, metadata: `%{from_state: atom}`

2. In `attach_handlers/0`, add a new :telemetry.attach call:
   ```
   :telemetry.attach(
     "hub-fsm-transition-logger",
     [:agent_com, :hub_fsm, :transition],
     &__MODULE__.handle_hub_fsm_transition/4,
     nil
   )
   ```

3. Add handler function `handle_hub_fsm_transition/4`:
   - Log at :info level: "hub_fsm_transition from=#{meta.from_state} to=#{meta.to_state} reason=#{meta.reason} duration_ms=#{measurements.duration_ms}"
   - Pattern: follow existing handler functions in the module
  </action>
  <verify>
Run `mix compile --warnings-as-errors`. Verify the new routes appear in endpoint.ex. Verify telemetry handler compiles.
  </verify>
  <done>
Four API endpoints exist (pause, resume, state, history) with auth on mutation routes. Telemetry handler logs every hub_fsm transition at :info level. All atom values are converted to strings for JSON serialization.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate HubFSM into dashboard WebSocket, state, and HTML</name>
  <files>lib/agent_com/dashboard_socket.ex, lib/agent_com/dashboard_state.ex, lib/agent_com/dashboard.ex</files>
  <action>
Update `lib/agent_com/dashboard_socket.ex`:

1. In `init/1`, add PubSub subscription:
   ```
   Phoenix.PubSub.subscribe(AgentCom.PubSub, "hub_fsm")
   ```
   Place after existing subscriptions.

2. Add handle_info clause for hub_fsm events:
   ```
   def handle_info({:hub_fsm_state_change, info}, state) do
     # Convert atoms to strings for JSON serialization
     formatted = %{
       type: "hub_fsm_state",
       data: %{
         fsm_state: to_string(info.fsm_state),
         paused: info.paused,
         last_state_change: info.last_state_change,
         cycle_count: info.cycle_count,
         timestamp: info.timestamp
       }
     }
     {:ok, %{state | pending_events: [formatted | state.pending_events]}}
   end
   ```
   Place this clause BEFORE the catch-all handle_info that handles unknown messages.

Update `lib/agent_com/dashboard_state.ex`:

1. In the `snapshot/0` handler (handle_call :snapshot), add hub_fsm state to the returned map:
   ```
   hub_fsm = try do
     AgentCom.HubFSM.get_state()
   catch
     :exit, _ -> %{fsm_state: :unknown, paused: false, cycle_count: 0, transition_count: 0}
   end
   ```
   Add `hub_fsm: hub_fsm` to the snapshot map.

Update `lib/agent_com/dashboard.ex`:

1. In the HTML string, add a "Hub FSM" panel. Find the existing panel grid and add a new card/section. The panel should show:
   - Current FSM state with color indicator (green for executing, blue for resting, yellow for improving, purple for contemplating, red if paused)
   - Paused indicator (red badge when paused)
   - Cycle count
   - Last state change timestamp (formatted as relative time)
   - Transition count

2. In the JavaScript WebSocket handler section, add handling for `hub_fsm_state` message type:
   - Update the FSM state display with incoming data
   - Update the state color indicator
   - Update paused badge visibility

3. In the initial snapshot rendering (where the page loads initial state), render hub_fsm data from the snapshot.

Keep the dashboard panel simple and functional -- no animations. Follow the existing card/panel pattern used by other dashboard sections (queue stats, agent list, etc.). Use inline CSS consistent with the existing dashboard styling.
  </action>
  <verify>
Run `mix compile --warnings-as-errors`. Run `mix format --check-formatted`. Verify dashboard_socket.ex subscribes to "hub_fsm" topic. Verify dashboard_state.ex includes hub_fsm in snapshot. Verify dashboard.ex HTML contains hub FSM panel.
  </verify>
  <done>
Dashboard WebSocket receives real-time hub_fsm_state_change events. Dashboard state snapshot includes hub_fsm data. Dashboard HTML shows FSM state panel with current state, paused indicator, cycle count, and transition timeline. All updates are real-time via WebSocket.
  </done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` passes
2. `mix format --check-formatted` passes
3. POST /api/hub/pause and POST /api/hub/resume routes exist with auth
4. GET /api/hub/state and GET /api/hub/history routes exist
5. Telemetry handler for [:agent_com, :hub_fsm, :transition] is attached
6. DashboardSocket subscribes to "hub_fsm" PubSub topic
7. DashboardState.snapshot/0 includes hub_fsm key
8. Dashboard HTML contains hub FSM state panel
</verification>

<success_criteria>
Hub FSM is fully observable: API endpoints for control (pause/resume) and monitoring (state/history), dashboard shows real-time FSM state with WebSocket updates, and telemetry logs all transitions.
</success_criteria>

<output>
After completion, create `.planning/phases/29-hub-fsm-core/29-02-SUMMARY.md`
</output>
