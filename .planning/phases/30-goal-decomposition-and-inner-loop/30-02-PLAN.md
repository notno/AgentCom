---
phase: 30-goal-decomposition-and-inner-loop
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/agent_com/goal_orchestrator/decomposer.ex
  - lib/agent_com/goal_orchestrator/verifier.ex
  - test/agent_com/goal_orchestrator/decomposer_test.exs
  - test/agent_com/goal_orchestrator/verifier_test.exs
autonomous: true

must_haves:
  truths:
    - "Decomposer builds a decomposition context including file tree and constraints, then calls ClaudeClient.decompose_goal/2"
    - "Decomposer validates the LLM response: DAG structure, file references, task count bounds (2-10)"
    - "Decomposer submits validated tasks to TaskQueue in topological order with goal_id and resolved depends_on IDs"
    - "Verifier gathers task results for a goal and calls ClaudeClient.verify_completion/2"
    - "Verifier creates follow-up tasks from gaps when verification fails (not full redecomposition)"
    - "Verifier tracks retry count and marks goal as needs_human_review after 2 retries"
  artifacts:
    - path: "lib/agent_com/goal_orchestrator/decomposer.ex"
      provides: "Goal decomposition pipeline: context building, LLM call, validation, task submission"
      exports: ["decompose/1"]
    - path: "lib/agent_com/goal_orchestrator/verifier.ex"
      provides: "Goal verification pipeline: result gathering, LLM call, gap-based follow-up task creation"
      exports: ["verify/2"]
    - path: "test/agent_com/goal_orchestrator/decomposer_test.exs"
      provides: "Decomposer unit tests"
    - path: "test/agent_com/goal_orchestrator/verifier_test.exs"
      provides: "Verifier unit tests"
  key_links:
    - from: "lib/agent_com/goal_orchestrator/decomposer.ex"
      to: "AgentCom.ClaudeClient.decompose_goal/2"
      via: "GenServer.call for LLM decomposition"
    - from: "lib/agent_com/goal_orchestrator/decomposer.ex"
      to: "AgentCom.TaskQueue.submit/1"
      via: "Submits tasks in topological order with goal_id and depends_on"
    - from: "lib/agent_com/goal_orchestrator/verifier.ex"
      to: "AgentCom.ClaudeClient.verify_completion/2"
      via: "GenServer.call for LLM verification"
    - from: "lib/agent_com/goal_orchestrator/verifier.ex"
      to: "AgentCom.TaskQueue.tasks_for_goal/1"
      via: "Gathers task results for verification context"
---

<objective>
Build the Decomposer and Verifier modules that encapsulate the two LLM-powered operations in the goal lifecycle: breaking goals into tasks and verifying goal completion.

Purpose: These modules contain the core logic that the GoalOrchestrator GenServer will call. Decomposer handles the full pipeline from file tree gathering through LLM decomposition to validated task submission. Verifier handles result gathering, LLM verification, and follow-up task creation for gaps.

Output: Two tested modules under `lib/agent_com/goal_orchestrator/`.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-goal-decomposition-and-inner-loop/30-RESEARCH.md
@lib/agent_com/claude_client.ex
@lib/agent_com/claude_client/prompt.ex
@lib/agent_com/claude_client/response.ex
@lib/agent_com/task_queue.ex
@lib/agent_com/goal_backlog.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Decomposer module</name>
  <files>lib/agent_com/goal_orchestrator/decomposer.ex, test/agent_com/goal_orchestrator/decomposer_test.exs</files>
  <action>
Create `AgentCom.GoalOrchestrator.Decomposer` as a library module (no GenServer). This module orchestrates the full decomposition pipeline.

**`decompose/1`** -- Takes a goal map (from GoalBacklog), returns `{:ok, submitted_task_ids}` or `{:error, reason}`.

Pipeline steps:

1. **Resolve repo path:** The goal has a `:repo` field (URL string like "https://github.com/user/repo"). Use `AgentCom.RepoRegistry.list/0` to find the matching repo entry. If the repo has no local path info, use `File.cwd!/0` as the fallback repo path (the hub's own codebase). Store the resolved path for file tree gathering.

2. **Gather file tree:** Call `AgentCom.GoalOrchestrator.FileTree.gather/1` with the resolved repo path. If it fails, return `{:error, {:file_tree_error, reason}}`.

3. **Build decomposition context:** Create a context map with:
   - `:repo` -- the goal's repo URL
   - `:files` -- the file tree list
   - `:constraints` -- a string including: "These are the ONLY files that exist. Do NOT reference files not in this list. Each task should be completable in 15-30 minutes. Return 3-8 tasks. Use depends-on indices (1-based) to mark sequential dependencies. Tasks with no dependencies can execute in parallel. The dependency graph must be a DAG -- no cycles."

4. **Call ClaudeClient:** `AgentCom.ClaudeClient.decompose_goal(goal, context)`. On `{:error, :budget_exhausted}`, return the error directly. On `{:error, :timeout}` or other errors, retry once, then return the error.

5. **Validate task count:** If fewer than 2 tasks, treat as atomic -- wrap the single task (or the goal description if 0 tasks) into a single-element list. If more than 10 tasks, log a warning but proceed (per user decision: "smell but not blocking").

6. **Validate DAG:** Call `AgentCom.GoalOrchestrator.DagValidator.validate/1`. On error, re-prompt ClaudeClient once with feedback: "The dependency graph is invalid: {reason}. Please fix the depends-on indices." If the second attempt also fails, return `{:error, {:dag_invalid, reason}}`.

7. **Validate file references:** Call `AgentCom.GoalOrchestrator.FileTree.validate_references/2`. If there are invalid references, re-prompt once with feedback: "The following files do not exist: {files}. Please revise task descriptions to use only files from the provided file tree." If second attempt also has invalid references, strip the invalid file references from descriptions and proceed (per research recommendation: "better to have slightly imprecise tasks than no tasks").

8. **Submit tasks in topological order:** Call `AgentCom.GoalOrchestrator.DagValidator.topological_order/1` to get execution order. Iterate in that order, submitting each task to `AgentCom.TaskQueue.submit/1` with:
   - `:description` -- task description from LLM
   - `:goal_id` -- the goal's ID
   - `:depends_on` -- resolved task IDs (map 1-based indices to already-submitted task IDs)
   - `:repo` -- the goal's repo
   - `:file_hints` -- extract file paths from the task description (reuse FileTree's regex)
   - `:success_criteria` -- the task's success criteria from LLM as a list
   - `:priority` -- inherit from goal (map goal priority integer to string: 0->"urgent", 1->"high", 2->"normal", 3->"low")

   Build an index-to-ID map as tasks are submitted. If any submit fails, log the error but continue with remaining tasks.

9. **Return** `{:ok, submitted_task_ids}` with all successfully submitted task IDs.

**Tests (using Mox or manual mocking):**

Since Decomposer calls ClaudeClient, TaskQueue, and FileTree, tests should focus on the pure logic portions. Create helper functions that are testable in isolation:

- `build_context/2` (goal, file_tree) -- test that context map has correct structure.
- `validate_task_count/1` -- test boundary cases: 0, 1, 5, 11 tasks.
- `build_submit_params/3` (task, goal, index_to_id_map) -- test parameter construction.
- `priority_to_string/1` -- test integer-to-string mapping.

For integration-level logic, test with descriptive comments explaining what would be tested with real dependencies. Use `async: true`.
  </action>
  <verify>Run `mix test test/agent_com/goal_orchestrator/decomposer_test.exs` -- all tests pass. Run `mix compile --warnings-as-errors` -- no warnings.</verify>
  <done>Decomposer.decompose/1 implements the full pipeline: file tree gathering, context building, LLM call with retry, DAG validation, file reference validation, and topological task submission to TaskQueue. Pure helper functions are unit tested.</done>
</task>

<task type="auto">
  <name>Task 2: Implement Verifier module</name>
  <files>lib/agent_com/goal_orchestrator/verifier.ex, test/agent_com/goal_orchestrator/verifier_test.exs</files>
  <action>
Create `AgentCom.GoalOrchestrator.Verifier` as a library module (no GenServer).

**`verify/2`** -- Takes a goal map and a retry count (integer), returns `{:ok, :pass}` or `{:ok, :fail, gaps}` or `{:ok, :needs_human_review}` or `{:error, reason}`.

Pipeline steps:

1. **Gather task results:** Call `AgentCom.TaskQueue.tasks_for_goal(goal.id)` to get all child tasks. Build a results map:
   - `:summary` -- Concatenate each task's description and result (if non-nil) into a formatted string: "Task: {description}\nStatus: {status}\nResult: {result || 'completed'}" joined by double newlines.
   - `:files_modified` -- Collect all `:file_hints` from tasks, flatten and deduplicate.
   - `:test_outcomes` -- Empty string for now (future phases may add test result aggregation).

2. **Call ClaudeClient:** `AgentCom.ClaudeClient.verify_completion(goal, results)`. Handle errors (budget_exhausted, timeout) by returning `{:error, reason}`.

3. **Process verdict:**
   - If `%{verdict: :pass}` -- return `{:ok, :pass}`.
   - If `%{verdict: :fail, gaps: gaps}` and retry_count >= 2 -- return `{:ok, :needs_human_review}` (max 2 retries per user decision).
   - If `%{verdict: :fail, gaps: gaps}` and retry_count < 2 -- return `{:ok, :fail, gaps}`.

**`create_followup_tasks/2`** -- Takes a goal map and a list of gap maps (from verification), returns `{:ok, task_ids}` or `{:error, reason}`.

For each gap:
- Submit a new task to TaskQueue with:
  - `:description` -- "Follow-up: {gap.description}" with context from the original goal
  - `:goal_id` -- the goal's ID
  - `:depends_on` -- empty (follow-up tasks are independent of each other)
  - `:repo` -- the goal's repo
  - `:priority` -- inherit from goal, but bump severity "critical" gaps to one level higher priority
  - `:success_criteria` -- derived from the gap description

This creates targeted follow-up tasks, NOT a full redecomposition (per user decision).

**`build_results_summary/1`** -- Public helper that takes a list of task maps and returns the results map. This is testable without mocking ClaudeClient.

**Tests:**
- `build_results_summary/1` with tasks having results returns formatted summary string.
- `build_results_summary/1` with tasks having nil results uses "completed" fallback.
- `build_results_summary/1` with empty task list returns empty summary.
- `build_results_summary/1` collects and deduplicates file_hints.
- Test that gap-to-followup-task parameter construction works correctly.
- Test retry count boundary: retry_count=1 returns :fail, retry_count=2 returns :needs_human_review.
- Test priority bump logic for critical gaps.

Use `async: true`.
  </action>
  <verify>Run `mix test test/agent_com/goal_orchestrator/verifier_test.exs` -- all tests pass. Run `mix compile --warnings-as-errors` -- no warnings.</verify>
  <done>Verifier.verify/2 gathers task results, calls ClaudeClient for verification, and handles pass/fail/needs_human_review outcomes. Verifier.create_followup_tasks/2 creates targeted follow-up tasks from verification gaps without full redecomposition. Max 2 retry cycles enforced.</done>
</task>

</tasks>

<verification>
1. `mix test test/agent_com/goal_orchestrator/` -- all tests pass (including Plan 01 tests if already executed)
2. `mix compile --warnings-as-errors` -- no warnings
3. Decomposer correctly calls ClaudeClient.decompose_goal/2 and TaskQueue.submit/1
4. Verifier correctly calls ClaudeClient.verify_completion/2 and TaskQueue.tasks_for_goal/1
</verification>

<success_criteria>
- Decomposer.decompose/1 handles the full pipeline including retry on LLM errors
- Decomposer submits tasks in topological order so depends_on IDs are valid at submit time
- Verifier.verify/2 enforces max 2 retry cycles, then returns :needs_human_review
- Verifier.create_followup_tasks/2 creates targeted gap-closing tasks (not redecomposition)
- All helper functions are unit tested
</success_criteria>

<output>
After completion, create `.planning/phases/30-goal-decomposition-and-inner-loop/30-02-SUMMARY.md`
</output>
