---
phase: 42-agent-self-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - sidecar/lib/pm2-manager.js
  - sidecar/index.js
  - sidecar/ecosystem.config.js
  - lib/agent_com/socket.ex
  - lib/agent_com/endpoint.ex
  - sidecar/test/pm2-manager.test.js
autonomous: true
must_haves:
  truths:
    - "Sidecar can query its own pm2 process name and running status"
    - "Sidecar can trigger its own graceful restart via pm2 (process exits, pm2 auto-restarts)"
    - "Hub sends restart command over WebSocket and target sidecar executes graceful pm2 restart"
  artifacts:
    - path: "sidecar/lib/pm2-manager.js"
      provides: "pm2 self-awareness and graceful restart"
      exports: ["getProcessName", "getStatus", "getInfo", "gracefulRestart"]
    - path: "sidecar/test/pm2-manager.test.js"
      provides: "Unit tests for pm2-manager"
  key_links:
    - from: "sidecar/index.js"
      to: "sidecar/lib/pm2-manager.js"
      via: "require and restart_sidecar message handler"
      pattern: "require.*pm2-manager"
    - from: "lib/agent_com/socket.ex"
      to: "sidecar/index.js"
      via: "restart_sidecar WebSocket message"
      pattern: "restart_sidecar"
    - from: "lib/agent_com/endpoint.ex"
      to: "lib/agent_com/socket.ex"
      via: "POST /api/admin/agents/:id/restart HTTP endpoint"
      pattern: "restart_sidecar"
---

<objective>
Add pm2 self-awareness to the sidecar and hub-commanded restart capability.

Purpose: Enable the hub (and future healing state) to command sidecars to restart themselves, which is essential for autonomous infrastructure management. Sidecars need to know their own pm2 process identity to report status and execute restarts.

Output: `sidecar/lib/pm2-manager.js` module, updated `sidecar/index.js` with restart_sidecar handler, hub-side WebSocket and HTTP endpoint support, and unit tests.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-agent-self-management/42-RESEARCH.md
@sidecar/index.js
@sidecar/ecosystem.config.js
@lib/agent_com/socket.ex
@lib/agent_com/endpoint.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pm2-manager module and update ecosystem.config.js</name>
  <files>sidecar/lib/pm2-manager.js, sidecar/ecosystem.config.js, sidecar/test/pm2-manager.test.js</files>
  <action>
Create `sidecar/lib/pm2-manager.js` with the following exports:

1. **`getProcessName()`** — Returns the pm2 process name. Primary source: `process.env.PM2_PROCESS_NAME`. Fallback: call `pm2 jlist` via `child_process.execSync` with 5s timeout, parse JSON, find entry where `pid === process.pid`, return `name`. Returns `null` if not running under pm2.

2. **`getStatus()`** — Returns the pm2 process status string ("online", "stopped", "errored") or `null` if not under pm2. Uses `pm2 jlist` and matches by process name (from `getProcessName()`).

3. **`getInfo()`** — Returns object `{ name, status, uptime_ms, restart_count, memory_bytes }` or `null`. Parses `pm2 jlist` output. Uptime calculated from `pm2_env.pm_uptime`. Memory from `monit.memory`. Restart count from `pm2_env.restart_time`.

4. **`gracefulRestart(hub, queue, reason)`** — Async function:
   - If `queue.active` exists and `queue.active.status === 'working'`: set module-level `_pendingRestart = { hub, reason }` flag and return (restart will be triggered after task completion by the caller checking `hasPendingRestart()`).
   - Otherwise: call `hub.send({ type: 'agent_restarting', reason })`, then `setTimeout(() => process.exit(0), 500)`.

5. **`hasPendingRestart()`** — Returns the pending restart object or `null`.

6. **`clearPendingRestart()`** — Clears the pending restart flag.

All `execSync` calls should be wrapped in try/catch. On any error (pm2 not found, parse failure), log a warning and return null/default.

Use the existing `log` function from `../lib/log.js` for structured logging (import pattern: `const { log } = require('./log');` since pm2-manager is in the same lib/ directory).

Update `sidecar/ecosystem.config.js`:
- Add `PM2_PROCESS_NAME: 'agentcom-sidecar'` to the `env` object in the app config. This makes the process name available as an env var without needing to call `pm2 jlist`.

Create `sidecar/test/pm2-manager.test.js`:
- Test `getProcessName()` returns `PM2_PROCESS_NAME` env var when set.
- Test `getProcessName()` returns null when env var not set and pm2 jlist fails (not in pm2).
- Test `getInfo()` returns null when not running under pm2.
- Test `hasPendingRestart()` returns null initially.
- Use Node.js built-in test runner (`node:test`).
  </action>
  <verify>
Run `node --test sidecar/test/pm2-manager.test.js` — all tests pass.
Verify `sidecar/lib/pm2-manager.js` exports the 6 functions listed above.
Verify `sidecar/ecosystem.config.js` has `PM2_PROCESS_NAME` in env.
  </verify>
  <done>
pm2-manager module exists with getProcessName, getStatus, getInfo, gracefulRestart, hasPendingRestart, clearPendingRestart exports. Tests pass. ecosystem.config.js sets PM2_PROCESS_NAME env var.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire pm2-manager into sidecar and add hub-side restart support</name>
  <files>sidecar/index.js, lib/agent_com/socket.ex, lib/agent_com/endpoint.ex</files>
  <action>
**sidecar/index.js changes:**

1. Add require at top: `const pm2Manager = require('./lib/pm2-manager');`

2. In `HubConnection.handleMessage()` switch statement, add a new case before the `default`:
```javascript
case 'restart_sidecar':
  log('info', 'restart_commanded', { reason: msg.reason });
  pm2Manager.gracefulRestart(this, _queue, msg.reason || 'hub_commanded');
  break;
```

3. After task completion in `handleResult()` (after `_queue.active = null`), add a pending restart check:
```javascript
// Check for pending restart (Phase 42: hub-commanded restart deferred during task)
const pendingRestart = pm2Manager.hasPendingRestart();
if (pendingRestart) {
  log('info', 'deferred_restart_executing', { reason: pendingRestart.reason });
  pm2Manager.clearPendingRestart();
  this.send({ type: 'agent_restarting', reason: pendingRestart.reason });
  setTimeout(() => process.exit(0), 500);
}
```

4. Add the same pending restart check after task completion in `executeTask()` (after `_queue.active = null; saveQueue(...)` at the end of the try block):
```javascript
const pendingRestart = pm2Manager.hasPendingRestart();
if (pendingRestart) {
  log('info', 'deferred_restart_executing', { reason: pendingRestart.reason });
  pm2Manager.clearPendingRestart();
  this.send({ type: 'agent_restarting', reason: pendingRestart.reason });
  setTimeout(() => process.exit(0), 500);
  return;
}
```

5. In the `identify()` method, include pm2 info in the identify payload:
```javascript
const pm2Info = pm2Manager.getInfo();
if (pm2Info) {
  payload.pm2_info = pm2Info;
}
```

**lib/agent_com/socket.ex changes:**

1. Add a new `handle_info` clause for `:restart_sidecar` (before the catch-all `handle_info(_msg, state)`):
```elixir
def handle_info({:restart_sidecar, reason}, state) do
  push = %{
    "type" => "restart_sidecar",
    "reason" => reason || "hub_commanded"
  }
  {:push, {:text, Jason.encode!(push)}, state}
end
```

2. Add a new `handle_msg` clause for `"agent_restarting"` messages from sidecar (after the `resource_report` handler):
```elixir
defp handle_msg(%{"type" => "agent_restarting"} = msg, state) do
  reason = Map.get(msg, "reason", "unknown")
  Logger.info("Agent #{state.agent_id} restarting: #{reason}")
  # Update agent status via Presence so dashboard sees it
  Presence.update_status(state.agent_id, "restarting")
  {:ok, state}
end
```

**lib/agent_com/endpoint.ex changes:**

Add a new HTTP endpoint `POST /api/admin/agents/:agent_id/restart` (near the existing agent admin endpoints):
```elixir
post "/api/admin/agents/:agent_id/restart" do
  with :ok <- require_auth(conn) do
    reason = case conn.body_params do
      %{"reason" => r} when is_binary(r) -> r
      _ -> "admin_commanded"
    end

    case Presence.get_pid(agent_id) do
      nil ->
        send_json(conn, 404, %{"error" => "agent_not_connected"})
      pid ->
        send(pid, {:restart_sidecar, reason})
        send_json(conn, 200, %{"status" => "restart_commanded", "agent_id" => agent_id, "reason" => reason})
    end
  end
end
```

Also update the `@moduledoc` route list to include the new endpoint:
```
- POST   /api/admin/agents/:agent_id/restart — Command agent restart (auth required)
```
  </action>
  <verify>
1. `mix compile --warnings-as-errors` passes (no warnings from new Elixir code).
2. `node --test sidecar/test/pm2-manager.test.js` still passes.
3. Grep for `restart_sidecar` in both `sidecar/index.js` and `lib/agent_com/socket.ex` — found in both.
4. Grep for `agent_restarting` in both `sidecar/index.js` and `lib/agent_com/socket.ex` — found in both.
5. Grep for `/api/admin/agents/:agent_id/restart` in `lib/agent_com/endpoint.ex` — found.
6. `mix test --exclude skip --exclude smoke` passes.
  </verify>
  <done>
Sidecar handles `restart_sidecar` WebSocket message and executes graceful pm2 restart (deferred if task active). Hub can push restart commands to specific agents via WebSocket. HTTP endpoint exists for admin/healing to trigger restarts. Agent sends `agent_restarting` status before exiting. All requirements PM2-01, PM2-02, PM2-03 are satisfied.
  </done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` exits 0
2. `mix test --exclude skip --exclude smoke` exits 0
3. `node --test sidecar/test/pm2-manager.test.js` exits 0
4. `sidecar/lib/pm2-manager.js` exports: getProcessName, getStatus, getInfo, gracefulRestart, hasPendingRestart, clearPendingRestart
5. `sidecar/ecosystem.config.js` contains `PM2_PROCESS_NAME` env var
6. `sidecar/index.js` handles `restart_sidecar` message type
7. `lib/agent_com/socket.ex` handles `:restart_sidecar` info and `"agent_restarting"` message
8. `lib/agent_com/endpoint.ex` has `POST /api/admin/agents/:agent_id/restart` route
</verification>

<success_criteria>
- PM2-01: Sidecar can query its own pm2 process name and running status via pm2-manager.getProcessName() and getStatus()
- PM2-02: Sidecar can trigger its own graceful restart via pm2-manager.gracefulRestart() (exits cleanly, pm2 auto-restarts)
- PM2-03: Hub sends restart_sidecar command over WebSocket (via HTTP endpoint or direct send), sidecar executes graceful pm2 restart
</success_criteria>

<output>
After completion, create `.planning/phases/42-agent-self-management/42-01-SUMMARY.md`
</output>
