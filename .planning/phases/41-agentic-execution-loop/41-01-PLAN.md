---
phase: 41-agentic-execution-loop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - sidecar/lib/execution/tool-call-parser.js
  - sidecar/lib/execution/ollama-executor.js
  - sidecar/test/execution/tool-call-parser.test.js
autonomous: true

must_haves:
  truths:
    - "OllamaExecutor sends tools array to Ollama /api/chat with stream: false and receives tool_calls in response"
    - "Tool call parser extracts tool calls from native tool_calls field, JSON-in-content, and XML-in-content"
    - "ReAct loop iterates: call Ollama, parse tool_calls, execute tools via executeTool(), feed results back as role:tool messages"
    - "Loop exits when model returns final answer (content without tool_calls)"
  artifacts:
    - path: "sidecar/lib/execution/tool-call-parser.js"
      provides: "3-layer output parser"
      exports: ["parseToolCalls"]
    - path: "sidecar/lib/execution/ollama-executor.js"
      provides: "Multi-turn ReAct loop"
      exports: ["OllamaExecutor"]
    - path: "sidecar/test/execution/tool-call-parser.test.js"
      provides: "Parser unit tests"
  key_links:
    - from: "sidecar/lib/execution/ollama-executor.js"
      to: "sidecar/lib/execution/tool-call-parser.js"
      via: "parseToolCalls() import"
      pattern: "require.*tool-call-parser"
    - from: "sidecar/lib/execution/ollama-executor.js"
      to: "sidecar/lib/tools/tool-executor.js"
      via: "executeTool() calls in loop"
      pattern: "executeTool"
    - from: "sidecar/lib/execution/ollama-executor.js"
      to: "sidecar/lib/tools/tool-registry.js"
      via: "getToolDefinitions() for Ollama tools param"
      pattern: "getToolDefinitions"
---

<objective>
Build the core ReAct loop in OllamaExecutor and the 3-layer tool call output parser.

Purpose: This is the heart of Phase 41 -- transforming OllamaExecutor from single-shot text generation into a multi-turn agent that calls tools, reads results, and iterates until task completion.

Output: OllamaExecutor with _agenticLoop method, tool-call-parser.js module, parser unit tests.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/41-agentic-execution-loop/41-CONTEXT.md
@.planning/phases/41-agentic-execution-loop/41-RESEARCH.md
@sidecar/lib/execution/ollama-executor.js
@sidecar/lib/tools/tool-registry.js
@sidecar/lib/tools/tool-executor.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: 3-layer tool call output parser</name>
  <files>sidecar/lib/execution/tool-call-parser.js, sidecar/test/execution/tool-call-parser.test.js</files>
  <action>
Create `sidecar/lib/execution/tool-call-parser.js` exporting `parseToolCalls(message)`.

The parser takes an Ollama response `message` object and returns one of:
- `{ type: 'tool_calls', calls: [{ name, arguments }] }` -- model wants to call tools
- `{ type: 'final_answer', content: string }` -- model is done, content is the final answer
- `{ type: 'empty', content: '' }` -- malformed/empty response

**3-layer extraction order:**

**Layer 1 -- Native tool_calls field:**
If `message.tool_calls` is a non-empty array, extract each call as `{ name: tc.function.name, arguments: tc.function.arguments || {} }`. Return type `tool_calls`.

**Layer 2 -- JSON extraction from content:**
First strip Qwen3 thinking blocks: `content.replace(/<think>[\s\S]*?<\/think>/g, '').trim()`.
Then search for JSON objects matching `{"name":"...", "arguments":{...}}` pattern in content.
Use regex: `/\{\s*"name"\s*:\s*"(\w+)"\s*,\s*"arguments"\s*:\s*(\{[^}]*\})\s*\}/g`.
If matches found, parse each and return type `tool_calls`.

**Layer 3 -- XML extraction from content:**
Search for `<tool_call>{...}</tool_call>` blocks in content (Qwen3 fallback for >5 tools).
Use regex: `/<tool_call>\s*(\{[\s\S]*?\})\s*<\/tool_call>/g`.
Parse JSON inside each block, extract name and arguments.

**Argument coercion** (apply to all layers):
After extracting arguments, coerce types for known tool parameters:
- String "true"/"false" -> boolean true/false
- String numbers for integer params (start_line, end_line, timeout_ms, max_results) -> parseInt
This handles Qwen3 8B's tendency to return string types instead of native JSON types.

**Tests:** Create `sidecar/test/execution/tool-call-parser.test.js` with tests for:
- Layer 1: native tool_calls (single call, multiple calls)
- Layer 2: JSON-in-content (single, multiple)
- Layer 3: XML-in-content (single, multiple)
- Qwen3 thinking block stripping before parsing
- Argument coercion (string booleans, string numbers)
- Final answer detection (content with no tool calls)
- Empty/malformed response handling
- Priority order: native > JSON > XML (if native exists, don't try JSON)
  </action>
  <verify>Run `cd sidecar && npx jest test/execution/tool-call-parser.test.js --verbose` -- all tests pass.</verify>
  <done>parseToolCalls() correctly extracts tool calls from all 3 formats with argument coercion, tested with 15+ test cases.</done>
</task>

<task type="auto">
  <name>Task 2: ReAct loop in OllamaExecutor</name>
  <files>sidecar/lib/execution/ollama-executor.js</files>
  <action>
Refactor `sidecar/lib/execution/ollama-executor.js` to add a multi-turn ReAct loop. Keep the existing single-shot streaming path for backward compatibility.

**New method: `_chatOnce(endpoint, model, messages, tools)`**
Non-streaming Ollama call (`stream: false`). Returns the full parsed JSON response object.
- POST to `/api/chat` with `{ model, messages, tools, stream: false }`
- Timeout: 120 seconds per call
- Parse response JSON, return the full object (has `message`, `done`, `prompt_eval_count`, `eval_count`)
- On HTTP error: throw with status code and body snippet

**New method: `_agenticLoop(endpoint, model, task, config, onProgress)`**
Multi-turn ReAct loop:

1. Build initial messages array:
   - System message: use `_buildMessages(task)` system content + tool usage instructions (basic for now, Plan 03 adds full system prompt)
   - User message: task description

2. Get tool definitions: `const tools = getToolDefinitions()` from `../tools/tool-registry`

3. Determine workspace: `config.repo_dir || config.workspace || process.cwd()`

4. Loop (max iterations from `task._agentic_max_iterations || 10`):
   a. Call `_chatOnce(endpoint, model, messages, tools)`
   b. Track token counts: accumulate `prompt_eval_count` and `eval_count` from each response
   c. Parse response: `parseToolCalls(response.message)` from `./tool-call-parser`
   d. If `type === 'final_answer'`: break, return final answer with accumulated tokens
   e. If `type === 'tool_calls'`:
      - Append assistant message to messages: `{ role: 'assistant', content: response.message.content || '', tool_calls: response.message.tool_calls }`
      - For each call: execute via `executeTool(call.name, call.arguments, workspace)` from `../tools/tool-executor`
      - Append tool result message: `{ role: 'tool', content: JSON.stringify(toolResult) }`
      - Emit progress: `onProgress({ type: 'tool_call', tool_name: call.name, args_summary: JSON.stringify(call.arguments).slice(0, 200), iteration: i })`
   f. If `type === 'empty'`: append nudge message `{ role: 'user', content: 'Please use the available tools to complete the task. Do not just describe what to do -- actually call the tools.' }`, limit nudges to 2.

5. On loop exit (max iterations): return partial output from last response content + accumulated tokens

**Modify `execute(task, config, onProgress)`:**
Add agentic detection: if `task.routing_decision?.agentic === true` OR `task._agentic === true`, call `_agenticLoop` instead of `_streamChat`. The `_streamChat` path remains for non-agentic Ollama tasks.

Return format remains the same: `{ status, output, model_used, tokens_in, tokens_out, error }`.
  </action>
  <verify>
Verify the module loads without errors: `cd sidecar && node -e "const { OllamaExecutor } = require('./lib/execution/ollama-executor'); console.log('OK:', typeof new OllamaExecutor()._agenticLoop)"`.
Run existing tests to ensure no regression: `cd sidecar && npx jest --verbose 2>&1 | tail -20`.
  </verify>
  <done>OllamaExecutor has _chatOnce() for non-streaming calls, _agenticLoop() for multi-turn ReAct with tool execution, and execute() routes agentic tasks to the loop. Single-shot streaming path preserved for backward compatibility.</done>
</task>

</tasks>

<verification>
1. `node -e "require('./sidecar/lib/execution/tool-call-parser')"` loads without error
2. `node -e "require('./sidecar/lib/execution/ollama-executor')"` loads without error
3. Parser tests pass: `cd sidecar && npx jest test/execution/tool-call-parser.test.js`
4. Existing sidecar tests still pass: `cd sidecar && npx jest --verbose`
</verification>

<success_criteria>
- parseToolCalls() handles all 3 extraction layers with correct priority ordering
- OllamaExecutor._agenticLoop() implements multi-turn ReAct: Ollama call -> parse -> execute tools -> feed back -> repeat
- Single-shot streaming path preserved (no regression for non-agentic tasks)
- Tool results fed back as role: "tool" messages in conversation
- Token counts accumulated across all loop iterations
</success_criteria>

<output>
After completion, create `.planning/phases/41-agentic-execution-loop/41-01-SUMMARY.md`
</output>
