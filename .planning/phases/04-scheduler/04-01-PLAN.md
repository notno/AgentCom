---
phase: 04-scheduler
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/agent_com/task_queue.ex
  - lib/agent_com/endpoint.ex
  - lib/agent_com/scheduler.ex
  - lib/agent_com/application.ex
autonomous: true
must_haves:
  truths:
    - "New task added to queue is automatically assigned to an idle agent with matching capabilities within seconds"
    - "Agent becoming idle after completing work immediately receives next queued task if available"
    - "Agent connecting to hub receives pending work if queue is non-empty and capabilities match"
    - "Stuck assignments (assigned but no progress for 5 minutes) are detected by 30s sweep and reclaimed"
  artifacts:
    - path: "lib/agent_com/scheduler.ex"
      provides: "Event-driven task-to-agent scheduler GenServer"
      contains: "defmodule AgentCom.Scheduler"
    - path: "lib/agent_com/task_queue.ex"
      provides: "needed_capabilities field in task struct"
      contains: "needed_capabilities"
    - path: "lib/agent_com/endpoint.ex"
      provides: "needed_capabilities in task submission API and format_task"
      contains: "needed_capabilities"
    - path: "lib/agent_com/application.ex"
      provides: "Scheduler in supervision tree"
      contains: "AgentCom.Scheduler"
  key_links:
    - from: "lib/agent_com/scheduler.ex"
      to: "Phoenix.PubSub tasks topic"
      via: "PubSub.subscribe in init"
      pattern: "subscribe.*tasks"
    - from: "lib/agent_com/scheduler.ex"
      to: "Phoenix.PubSub presence topic"
      via: "PubSub.subscribe in init"
      pattern: "subscribe.*presence"
    - from: "lib/agent_com/scheduler.ex"
      to: "lib/agent_com/task_queue.ex"
      via: "TaskQueue.list, assign_task, reclaim_task calls"
      pattern: "TaskQueue\\.(list|assign_task|reclaim_task)"
    - from: "lib/agent_com/scheduler.ex"
      to: "lib/agent_com/agent_fsm.ex"
      via: "AgentFSM.list_all call for idle agent discovery"
      pattern: "AgentFSM\\.list_all"
    - from: "lib/agent_com/scheduler.ex"
      to: "AgentCom.AgentRegistry"
      via: "Registry.lookup for WebSocket pid to push task"
      pattern: "Registry\\.lookup.*AgentRegistry"
---

<objective>
Create the event-driven Scheduler GenServer that automatically matches queued tasks to idle, capable agents. Add the `needed_capabilities` field to tasks for capability-based routing.

Purpose: This is the integration point tying Phases 1-3 together. Without the scheduler, tasks sit in the queue and agents sit idle until a human manually pushes work. With it, the system becomes autonomous -- tasks flow to agents within seconds of submission.

Output: `lib/agent_com/scheduler.ex` (new), plus modifications to task_queue.ex, endpoint.ex, and application.ex.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-scheduler/04-RESEARCH.md
@.planning/phases/02-task-queue/02-01-SUMMARY.md
@.planning/phases/02-task-queue/02-02-SUMMARY.md
@.planning/phases/03-agent-state/03-02-SUMMARY.md
@lib/agent_com/task_queue.ex
@lib/agent_com/agent_fsm.ex
@lib/agent_com/socket.ex
@lib/agent_com/endpoint.ex
@lib/agent_com/application.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add needed_capabilities field to TaskQueue and Endpoint</name>
  <files>lib/agent_com/task_queue.ex, lib/agent_com/endpoint.ex</files>
  <action>
    **In `lib/agent_com/task_queue.ex` -- handle_call({:submit, params}):**

    Add `needed_capabilities` extraction to the task map in the submit handler (around line 202-222). Insert after the `complete_by` field and before `result`:

    ```elixir
    needed_capabilities:
      Map.get(params, :needed_capabilities,
        Map.get(params, "needed_capabilities", [])),
    ```

    This follows the existing dual atom/string key lookup pattern established in submit (see `priority`, `max_retries`, etc.).

    **In `lib/agent_com/endpoint.ex` -- POST /api/tasks handler (around line 594-601):**

    Add `needed_capabilities` to the `task_params` map:

    ```elixir
    needed_capabilities: params["needed_capabilities"] || [],
    ```

    Place it after `complete_by` and before `submitted_by`.

    **In `lib/agent_com/endpoint.ex` -- format_task/1 (around line 709-734):**

    Add `needed_capabilities` to the format_task output map. Use `Map.get` for backward compatibility with existing DETS records that lack this field (Pitfall 7 from research):

    ```elixir
    "needed_capabilities" => Map.get(task, :needed_capabilities, []),
    ```

    Place it after `"max_retries"` and before `"last_error"`.

    **Why Map.get with default []:** Existing tasks stored in DETS do not have the `needed_capabilities` key. Using `task.needed_capabilities` would crash with KeyError on old records. `Map.get(task, :needed_capabilities, [])` handles both nil and missing-key cases gracefully.
  </action>
  <verify>
    1. `mix compile` -- zero errors, zero new warnings
    2. Confirm `needed_capabilities` appears in the task map structure in task_queue.ex submit handler
    3. Confirm `needed_capabilities` appears in endpoint.ex POST /api/tasks task_params
    4. Confirm `needed_capabilities` appears in endpoint.ex format_task/1 with Map.get default
  </verify>
  <done>
    Tasks submitted via API can include `needed_capabilities` field (list of capability name strings). The field persists in DETS and is returned in all task API responses. Existing tasks without the field default to `[]` (any agent qualifies).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Scheduler GenServer with event-driven matching and stuck sweep</name>
  <files>lib/agent_com/scheduler.ex, lib/agent_com/application.ex</files>
  <action>
    **Create `lib/agent_com/scheduler.ex`:**

    A GenServer that subscribes to PubSub "tasks" and "presence" topics on init. It reacts to scheduling-opportunity events and runs a greedy matching loop. It also runs a 30-second stuck assignment sweep.

    **Module constants:**
    ```elixir
    @stuck_sweep_interval_ms 30_000
    @stuck_threshold_ms 300_000  # 5 minutes
    ```

    **init/1:**
    - Subscribe to PubSub "tasks" topic (for task_submitted, task_reclaimed, task_retried, task_completed events)
    - Subscribe to PubSub "presence" topic (for agent_joined events)
    - Start stuck sweep timer with `Process.send_after(self(), :sweep_stuck, @stuck_sweep_interval_ms)`
    - State is `%{}` (stateless -- queries TaskQueue and AgentFSM for current data on every attempt)

    **handle_info for scheduling triggers (SCHED-01 + SCHED-04):**
    React to these events by calling `try_schedule_all()`:
    - `{:task_event, %{event: :task_submitted}}` -- new task queued
    - `{:task_event, %{event: :task_reclaimed}}` -- stuck/failed task returned to queue
    - `{:task_event, %{event: :task_retried}}` -- dead-letter task requeued
    - `{:task_event, %{event: :task_completed}}` -- agent finished work, now idle (Pitfall 1: do NOT react to :task_assigned or :task_dead_letter -- these are not scheduling opportunities)
    - `{:agent_joined, _info}` -- new agent connected

    Explicitly ignore (return `{:noreply, state}` without scheduling):
    - `{:task_event, %{event: event}}` for any other event (catch-all)
    - `{:agent_left, _}` -- agent disconnected, no scheduling needed
    - `{:status_changed, _}` -- presence status change, not a scheduling trigger

    Also add a catch-all `handle_info(_msg, state)` that returns `{:noreply, state}` to ignore any unexpected messages.

    **try_schedule_all/0 -- Greedy schedule loop (addresses Pitfall 3: queue head blocking):**
    1. Get all idle agents: `AgentCom.AgentFSM.list_all() |> Enum.filter(fn a -> a.fsm_state == :idle end)`
    2. If no idle agents, return `:ok`
    3. Get all queued tasks sorted by priority: `AgentCom.TaskQueue.list(status: :queued)` -- this returns tasks in priority order
    4. Call `do_match_loop(queued_tasks, idle_agents)` which iterates through tasks and agents

    **do_match_loop/2 -- Iterate tasks, matching to available agents:**
    - Base cases: empty task list or empty agent list -> `:ok`
    - For each task, find first agent in `agents` list where `agent_matches_task?(agent, task)` is true
    - If no matching agent for this task, skip it and try next task (`do_match_loop(rest_tasks, agents)`)
    - If match found, call `do_assign(task, agent)`, remove agent from available list, continue with remaining tasks and agents

    **agent_matches_task?/2 -- Capability matching (SCHED-02):**
    ```elixir
    defp agent_matches_task?(agent, task) do
      needed = Map.get(task, :needed_capabilities, [])

      if needed == [] do
        true
      else
        agent_cap_names =
          (agent.capabilities || [])
          |> Enum.map(fn
            %{name: name} -> name
            cap when is_binary(cap) -> cap
            _ -> nil
          end)
          |> Enum.reject(&is_nil/1)

        Enum.all?(needed, fn cap -> cap in agent_cap_names end)
      end
    end
    ```

    Key detail: Agent capabilities are normalized by AgentFSM to `[%{name: "cap_name"}]` maps. The matching extracts the `name` field. It also handles raw string capabilities as a defensive fallback. Exact string match per SCHED-02 -- no fuzzy matching, no case folding.

    **do_assign/2 -- Task assignment via existing infrastructure:**
    1. Call `AgentCom.TaskQueue.assign_task(task.id, agent.agent_id)` -- this updates status, bumps generation, persists to DETS, broadcasts :task_assigned
    2. On success, build task_data map: `%{task_id: assigned_task.id, description: assigned_task.description, metadata: assigned_task.metadata, generation: assigned_task.generation}`
    3. Look up agent's WebSocket pid: `Registry.lookup(AgentCom.AgentRegistry, agent.agent_id)`
    4. Send `send(pid, {:push_task, task_data})` to the WebSocket process
    5. Log info: `"Scheduler: assigned task #{task.id} to #{agent.agent_id}"`
    6. On assign_task error, log warning and continue (race conditions are self-healing per Pitfall 6)
    7. On empty Registry lookup (agent disconnected between check and assign), log warning (self-healing via AgentFSM :DOWN handler)

    **CRITICAL: Do NOT call AgentFSM.assign_task from the scheduler.** The Socket's `handle_info({:push_task, task}, state)` handler already calls `AgentCom.AgentFSM.assign_task(state.agent_id, task_id)`. Calling it from the scheduler would create duplicate assignment notifications.

    **handle_info(:sweep_stuck, state) -- Stuck assignment sweep (SCHED-03):**
    1. Get current time: `System.system_time(:millisecond)`
    2. Calculate threshold: `now - @stuck_threshold_ms`
    3. Get all assigned tasks: `AgentCom.TaskQueue.list(status: :assigned)`
    4. Filter for stuck tasks: `task.updated_at < threshold`
    5. For each stuck task, call `AgentCom.TaskQueue.reclaim_task(task.id)` and log warning with agent_id and staleness duration
    6. Reschedule sweep: `Process.send_after(self(), :sweep_stuck, @stuck_sweep_interval_ms)`
    7. Return `{:noreply, state}`

    Note: `reclaim_task` is idempotent (returns :not_assigned if already reclaimed). The reclaim broadcasts :task_reclaimed on PubSub, which triggers try_schedule_all -- so reclaimed tasks are immediately re-scheduled.

    **Add @moduledoc** documenting:
    - Event-driven design (SCHED-04): PubSub is primary, sweep is fallback
    - Scheduling triggers (SCHED-01): task_submitted, task_reclaimed, task_retried, task_completed, agent_joined
    - Capability matching (SCHED-02): exact string match, empty needed_capabilities means any agent
    - Stuck sweep (SCHED-03): 30s interval, 5-minute staleness threshold
    - Stateless design: queries TaskQueue and AgentFSM for current data on every attempt

    **In `lib/agent_com/application.ex`:**

    Add `{AgentCom.Scheduler, []}` to the children list AFTER `{AgentCom.TaskQueue, []}` and BEFORE `{Bandit, ...}`. This ensures all dependencies (PubSub, Registry, AgentSupervisor, TaskQueue) are started before the Scheduler.

    The children list should look like:
    ```elixir
    ...
    {AgentCom.TaskQueue, []},
    {AgentCom.Scheduler, []},
    {Bandit, plug: AgentCom.Endpoint, scheme: :http, port: port()}
    ```
  </action>
  <verify>
    1. `mix compile` -- zero errors, zero new warnings
    2. Confirm scheduler.ex defines `AgentCom.Scheduler` GenServer with `use GenServer`
    3. Confirm init subscribes to both "tasks" and "presence" PubSub topics
    4. Confirm handle_info clauses for :task_submitted, :task_reclaimed, :task_retried, :task_completed, :agent_joined all call try_schedule_all
    5. Confirm handle_info ignores :task_assigned, :task_dead_letter (no scheduling on these events)
    6. Confirm try_schedule_all uses TaskQueue.list(status: :queued) not dequeue_next (Pitfall 3)
    7. Confirm do_assign calls TaskQueue.assign_task then sends {:push_task, ...} to WebSocket pid
    8. Confirm do_assign does NOT call AgentFSM.assign_task (Socket handler does this)
    9. Confirm :sweep_stuck handler filters assigned tasks by updated_at staleness and calls reclaim_task
    10. Confirm application.ex has Scheduler after TaskQueue and before Bandit
  </verify>
  <done>
    The Scheduler GenServer starts with the application, subscribes to PubSub events, and automatically matches queued tasks to idle agents by capability. Stuck assignments are detected every 30 seconds and reclaimed. The hub compiles cleanly with the scheduler in the supervision tree.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Compilation:** `mix compile` produces zero errors and zero warnings related to scheduler, task_queue, or endpoint.
2. **Supervision tree:** Application starts cleanly with Scheduler in the tree (verify via `mix run --no-halt` or by observing no crash on startup).
3. **PubSub integration:** Scheduler subscribes to "tasks" and "presence" topics (verifiable in init code).
4. **Capability matching:** `agent_matches_task?/2` correctly handles: empty needed_capabilities (any agent), subset matching (task caps subset of agent caps), and exact string comparison.
5. **Event filtering:** Scheduler only reacts to scheduling-opportunity events, not to :task_assigned or :task_dead_letter (prevents feedback loops per Pitfall 1).
6. **Stuck sweep:** 30-second timer checks assigned tasks for 5-minute progress staleness and reclaims them.
7. **No duplicate FSM notification:** Scheduler does NOT call AgentFSM.assign_task -- Socket's push_task handler handles this.
</verification>

<success_criteria>
- `mix compile` succeeds with zero errors/warnings from modified files
- Application starts cleanly with Scheduler in supervision tree
- Scheduler GenServer subscribes to PubSub "tasks" and "presence" topics
- Tasks can be submitted with `needed_capabilities` field via POST /api/tasks
- Scheduler reacts to task_submitted, task_completed, agent_joined events
- Capability matching uses exact string match with subset semantics
- Stuck sweep runs every 30 seconds checking for 5-minute staleness
- All 4 phase success criteria are architecturally addressed
</success_criteria>

<output>
After completion, create `.planning/phases/04-scheduler/04-01-SUMMARY.md`
</output>
