---
phase: 12-input-validation
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - lib/agent_com/socket.ex
  - lib/agent_com/endpoint.ex
autonomous: true
must_haves:
  truths:
    - "Every WebSocket message is validated by Validation.validate_ws_message/1 before handle_msg dispatch"
    - "Every HTTP POST/PUT endpoint validates body with Validation.validate_http/2 before processing"
    - "Validation errors return structured JSON with field-level detail and offending values"
    - "10 validation failures in 1 minute disconnects agent with WebSocket close code 1008"
    - "Disconnected agents in cooldown are rejected at identify with remaining cooldown time"
    - "GET /api/schemas returns all message type schemas serialized as JSON"
  artifacts:
    - path: "lib/agent_com/socket.ex"
      provides: "WebSocket handler with validation-then-dispatch and violation tracking"
      contains: "Validation.validate_ws_message"
    - path: "lib/agent_com/endpoint.ex"
      provides: "HTTP endpoint with validation and schema discovery"
      contains: "Validation.validate_http"
  key_links:
    - from: "lib/agent_com/socket.ex"
      to: "lib/agent_com/validation.ex"
      via: "validate_ws_message call in handle_in"
      pattern: "Validation\\.validate_ws_message"
    - from: "lib/agent_com/socket.ex"
      to: "lib/agent_com/validation/violation_tracker.ex"
      via: "track_violation and check_backoff calls"
      pattern: "ViolationTracker\\.(track_violation|check_backoff|record_disconnect)"
    - from: "lib/agent_com/endpoint.ex"
      to: "lib/agent_com/validation.ex"
      via: "validate_http call before processing"
      pattern: "Validation\\.validate_http"
    - from: "lib/agent_com/endpoint.ex"
      to: "lib/agent_com/validation/schemas.ex"
      via: "GET /api/schemas serializes schemas"
      pattern: "Schemas\\.to_json"
---

<objective>
Wire the Validation module into WebSocket and HTTP handlers, add violation tracking to Socket state, enforce backoff on reconnect, and add the schema discovery endpoint.

Purpose: This is the integration plan that makes validation actually happen at the boundary. After this plan, every external message and request is validated before reaching GenServers (VALID-01, VALID-02, VALID-03). The schema discovery endpoint (GET /api/schemas) enables agent introspection (LOCKED decision).

Output: Modified socket.ex and endpoint.ex with validation gates at every entry point.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-input-validation/12-CONTEXT.md
@.planning/phases/12-input-validation/12-RESEARCH.md
@.planning/phases/12-input-validation/12-01-SUMMARY.md
@lib/agent_com/socket.ex
@lib/agent_com/endpoint.ex
@lib/agent_com/validation.ex
@lib/agent_com/validation/schemas.ex
@lib/agent_com/validation/violation_tracker.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate validation into WebSocket handler</name>
  <files>lib/agent_com/socket.ex</files>
  <action>
Modify `lib/agent_com/socket.ex` to add validation-then-dispatch at the WebSocket boundary.

**1. Update Socket struct** -- add violation tracking fields:

```elixir
defstruct [:agent_id, :identified, violation_count: 0, violation_window_start: nil]
```

**2. Update aliases** -- add at top of module:

```elixir
alias AgentCom.{Message, Presence, Router, Validation}
alias AgentCom.Validation.ViolationTracker
```

**3. Modify `handle_in/2`** -- add validation BEFORE dispatch:

The current flow is: `Jason.decode(text) -> handle_msg(msg, state)`.
New flow: `Jason.decode(text) -> Validation.validate_ws_message(msg) -> handle_msg(validated, state)`.

For the `identify` message specifically: validate first, then proceed to auth. This means `identify` validation runs pre-auth (LOCKED: validate identify fully since it IS the pre-auth message). For all other messages, the existing `identified: false` check in `handle_msg` runs AFTER validation (if message is structurally valid but agent isn't identified, they get "not_identified" error -- existing behavior preserved).

```elixir
def handle_in({text, [opcode: :text]}, state) do
  case Jason.decode(text) do
    {:ok, msg} ->
      case Validation.validate_ws_message(msg) do
        {:ok, validated} ->
          handle_msg(validated, state)
        {:error, errors} ->
          handle_validation_failure(msg, errors, state)
      end
    {:error, _} ->
      reply_error("invalid_json", state)
  end
end
```

**4. Add `handle_validation_failure/3`** -- private function:

For identified agents: track violation, check threshold, reply error or disconnect.
For unidentified agents: just reply error (no violation tracking since we don't know who they are -- but still count against the connection to prevent spam).

```elixir
defp handle_validation_failure(msg, errors, state) do
  # Track violation in connection state
  new_state = ViolationTracker.track_violation(state)

  # Broadcast for dashboard visibility
  Phoenix.PubSub.broadcast(AgentCom.PubSub, "validation", {:validation_failure, %{
    agent_id: state.agent_id,
    message_type: Map.get(msg, "type", "unknown"),
    error_count: new_state.violation_count,
    errors: errors,
    timestamp: System.system_time(:millisecond)
  }})

  case ViolationTracker.should_disconnect?(new_state) do
    true ->
      # Record disconnect for backoff tracking (only if identified)
      if state.identified and state.agent_id do
        ViolationTracker.record_disconnect(state.agent_id)
      end
      # Broadcast disconnect event
      Phoenix.PubSub.broadcast(AgentCom.PubSub, "validation", {:validation_disconnect, %{
        agent_id: state.agent_id,
        timestamp: System.system_time(:millisecond)
      }})
      # Close with policy violation code -- agent received detailed errors for each of the preceding failures
      {:stop, :normal, {1008, "too many validation errors"}, new_state}
    false ->
      reply_validation_error(msg, errors, new_state)
  end
end
```

**5. Add `reply_validation_error/3`** -- private function:

Reuse existing "error" type (discretion recommendation from research):
```elixir
defp reply_validation_error(msg, errors, state) do
  message_type = Map.get(msg, "type", "unknown")
  formatted = Validation.format_errors(errors)
  reply = Jason.encode!(%{
    "type" => "error",
    "error" => "validation_failed",
    "message_type" => message_type,
    "errors" => formatted
  })
  {:push, {:text, reply}, state}
end
```

**6. Add backoff check in identify handler** -- modify `handle_msg` for identify:

In the existing `handle_msg(%{"type" => "identify", "agent_id" => agent_id} = msg, state)`, BEFORE calling Auth.verify, check backoff:

```elixir
defp handle_msg(%{"type" => "identify", "agent_id" => agent_id} = msg, state) do
  # Check backoff before allowing identify
  case ViolationTracker.check_backoff(agent_id) do
    :ok ->
      # Proceed with existing auth flow
      token = Map.get(msg, "token")
      case AgentCom.Auth.verify(token) do
        {:ok, ^agent_id} ->
          do_identify(agent_id, msg, state)
        {:ok, _other} ->
          reply_error("token_agent_mismatch", state)
        :error ->
          reply_error("invalid_token", state)
      end
    {:cooldown, remaining_seconds} ->
      # Close connection -- agent must wait for cooldown
      {:stop, :normal, {1008, "cooldown active: retry in #{remaining_seconds}s"}, state}
  end
end
```

IMPORTANT: Preserve ALL existing handle_msg function clauses exactly as they are. The only changes to handle_msg are:
- The `identify` clause gains a backoff check wrapper at the top
- No other handle_msg clauses change
- The validation happens in handle_in, before handle_msg is called
  </action>
  <verify>
Run `mix compile --warnings-as-errors` -- compiles cleanly. Run `mix test` -- all existing tests pass (validation is additive, valid messages still work). In `iex -S mix`, connect via WebSocket and:
- Send `{"type": "ping"}` -- should get `{"type": "pong", ...}` (valid message works as before)
- Send `{"type": "task_complete", "task_id": "t1"}` -- should get validation error (missing generation)
- Send `{"type": "foobar"}` -- should get unknown_message_type error with known_types list
- Send `{"type": 123}` -- should get wrong_type error for type field
  </verify>
  <done>
Every WebSocket message is validated before reaching handle_msg. Valid messages work exactly as before. Invalid messages return structured error with field-level detail. 10 failures in 1 minute triggers disconnect with close code 1008. Agents in backoff cooldown are rejected at identify. Validation events broadcast to PubSub for dashboard consumption.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate validation into HTTP endpoints and add schema discovery</name>
  <files>lib/agent_com/endpoint.ex</files>
  <action>
Modify `lib/agent_com/endpoint.ex` to validate all POST/PUT request bodies and add the schema discovery endpoint.

**1. Add alias at top of module** (after `use Plug.Router`):

```elixir
alias AgentCom.Validation
```

**2. Add GET /api/schemas endpoint** -- BEFORE the `match _` catch-all at the bottom:

```elixir
get "/api/schemas" do
  schemas = AgentCom.Validation.Schemas.to_json()
  send_json(conn, 200, %{"schemas" => schemas, "version" => "1.0"})
end
```

This endpoint requires NO auth (agents need to introspect schemas before identifying). Place it after the dashboard routes but before `match _`.

**3. Add `send_validation_error/2`** helper -- private function:

```elixir
defp send_validation_error(conn, errors) do
  formatted = Validation.format_errors(errors)
  send_json(conn, 422, %{
    "error" => "validation_failed",
    "errors" => formatted
  })
end
```

Use 422 Unprocessable Entity (discretion recommendation: distinct from 400 for malformed JSON).

**4. Modify POST /api/message** -- replace ad-hoc `%{"payload" => payload}` pattern match with `Validation.validate_http(:post_message, params)`.

**5. Modify PUT /api/config/heartbeat-interval** -- replace ad-hoc pattern match with `Validation.validate_http(:put_heartbeat_interval, conn.body_params)`.

**6. Modify PUT /api/config/mailbox-retention** -- replace with `Validation.validate_http(:put_mailbox_retention, conn.body_params)`.

**7. Modify POST /api/channels** -- replace `%{"name" => name}` pattern with `Validation.validate_http(:post_channel, conn.body_params)`.

**8. Modify POST /api/channels/:channel/publish** -- replace `%{"payload" => payload}` pattern with `Validation.validate_http(:post_channel_publish, conn.body_params)`.

**9. Modify POST /api/mailbox/:agent_id/ack** -- replace `%{"seq" => seq}` pattern with `Validation.validate_http(:post_mailbox_ack, conn.body_params)`.

**10. Modify POST /admin/tokens** -- replace `%{"agent_id" => agent_id}` pattern with `Validation.validate_http(:post_admin_token, conn.body_params)`.

**11. Modify POST /api/admin/push-task** -- replace `%{"agent_id" => ..., "description" => ...}` pattern with `Validation.validate_http(:post_admin_push_task, conn.body_params)`.

**12. Modify POST /api/tasks** -- replace `%{"description" => description}` pattern with `Validation.validate_http(:post_task, conn.body_params)`.

**13. Modify POST /api/onboard/register** -- replace ad-hoc pattern with `Validation.validate_http(:post_onboard_register, conn.body_params)`. Note: non-empty string check for agent_id should be handled by schema.

**14. Modify PUT /api/config/default-repo** -- replace ad-hoc pattern with `Validation.validate_http(:put_default_repo, conn.body_params)`.

**15. Modify POST /api/dashboard/push-subscribe** -- add `Validation.validate_http(:post_push_subscribe, conn.body_params)`.

For each endpoint, the pattern is:
```elixir
case Validation.validate_http(:schema_key, body_params) do
  {:ok, _} -> ... existing logic using body_params fields ...
  {:error, errors} -> send_validation_error(conn, errors)
end
```

IMPORTANT: Do NOT modify GET endpoints. Do NOT modify WebSocket upgrade endpoints. Do NOT modify DELETE endpoints. Preserve all existing business logic -- only wrap the body_params handling.

IMPORTANT: Validation failures now return 422 instead of 400. This is deliberate -- 400 is reserved for malformed JSON (from Plug.Parsers), 422 for validation failures.
  </action>
  <verify>
Run `mix compile --warnings-as-errors` -- compiles cleanly. Run `mix test` -- existing tests pass. Test manually with curl:
- `curl -X GET http://localhost:4000/api/schemas` -- returns JSON with all schemas
- `curl -X POST http://localhost:4000/api/tasks -H "Authorization: Bearer TOKEN" -H "Content-Type: application/json" -d '{}'` -- returns 422 with validation error for missing description
- `curl -X POST http://localhost:4000/api/tasks -H "Authorization: Bearer TOKEN" -H "Content-Type: application/json" -d '{"description": "test"}'` -- returns 201 (works as before)
- `curl -X PUT http://localhost:4000/api/config/heartbeat-interval -H "Authorization: Bearer TOKEN" -H "Content-Type: application/json" -d '{"heartbeat_interval_ms": "not_int"}'` -- returns 422 with wrong_type error
  </verify>
  <done>
All POST/PUT HTTP endpoints validate request bodies via Validation.validate_http/2. Invalid requests return 422 with structured error JSON. GET /api/schemas returns all message type schemas. All existing functionality preserved -- valid requests produce identical responses as before.
  </done>
</task>

</tasks>

<verification>
- `mix compile --warnings-as-errors` passes
- `mix test` passes (existing tests validate that valid messages still work)
- WebSocket messages validated before dispatch
- HTTP endpoints validated before processing
- Validation errors return 422 (HTTP) or error type JSON (WebSocket)
- Schema discovery endpoint returns all schemas
- Violation tracking and backoff enforcement functional
</verification>

<success_criteria>
- Every one of the 15 WebSocket message types is validated before reaching handle_msg
- Every POST/PUT HTTP endpoint validates body before processing
- Valid messages/requests produce identical behavior to pre-validation state
- Invalid messages return structured error with field-level detail and offending values
- 10 WS validation failures in 1 minute triggers close code 1008 disconnect
- Agents in backoff cooldown rejected at identify
- GET /api/schemas returns all schemas as JSON
</success_criteria>

<output>
After completion, create `.planning/phases/12-input-validation/12-02-SUMMARY.md`
</output>
