---
phase: 12-input-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/agent_com/validation.ex
  - lib/agent_com/validation/schemas.ex
  - lib/agent_com/validation/violation_tracker.ex
  - lib/agent_com/application.ex
autonomous: true
must_haves:
  truths:
    - "Validation.validate_ws_message/1 returns {:ok, msg} for valid messages and {:error, errors} for invalid ones"
    - "Validation.validate_http/2 returns {:ok, params} for valid HTTP bodies and {:error, errors} for invalid ones"
    - "Schemas.all/0 returns all 15 WebSocket message schemas and all HTTP endpoint schemas"
    - "ViolationTracker tracks per-agent failure counts with 1-minute sliding window and triggers disconnect at 10 failures"
    - "Backoff ETS table persists disconnect counts across WebSocket reconnections with exponential cooldown (30s, 1m, 5m)"
  artifacts:
    - path: "lib/agent_com/validation.ex"
      provides: "Central validation module with validate_ws_message/1 and validate_http/2"
      exports: ["validate_ws_message/1", "validate_http/2", "format_errors/1"]
    - path: "lib/agent_com/validation/schemas.ex"
      provides: "Schema definitions for all message types and HTTP endpoints"
      exports: ["get/1", "all/0", "known_types/0", "http_schema/1", "to_json/0"]
    - path: "lib/agent_com/validation/violation_tracker.ex"
      provides: "Per-agent violation tracking with escalating disconnect and backoff"
      exports: ["record_violation/1", "check_threshold/1", "check_backoff/1", "backoff_remaining/1"]
    - path: "lib/agent_com/application.ex"
      provides: "ETS table :validation_backoff created at application startup"
      contains: ":validation_backoff"
  key_links:
    - from: "lib/agent_com/validation.ex"
      to: "lib/agent_com/validation/schemas.ex"
      via: "alias and function calls"
      pattern: "Schemas\\.get|Schemas\\.all"
    - from: "lib/agent_com/validation/violation_tracker.ex"
      to: ":validation_backoff ETS table"
      via: "ETS read/write for backoff persistence"
      pattern: ":ets\\.(lookup|insert|update_counter)"
---

<objective>
Build the core validation module, schema definitions, and violation tracking infrastructure for Phase 12 input validation.

Purpose: Create the reusable foundation that both WebSocket and HTTP handlers will call. Schemas serve dual purpose: runtime validation AND JSON serialization for the schema discovery endpoint. ViolationTracker provides the escalating disconnect mechanism (locked user decision).

Output: Three new modules (Validation, Schemas, ViolationTracker) and ETS table creation in application.ex.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-input-validation/12-CONTEXT.md
@.planning/phases/12-input-validation/12-RESEARCH.md
@lib/agent_com/socket.ex
@lib/agent_com/endpoint.ex
@lib/agent_com/application.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Validation module and Schemas</name>
  <files>lib/agent_com/validation.ex, lib/agent_com/validation/schemas.ex</files>
  <action>
Create `lib/agent_com/validation/schemas.ex` defining ALL schemas as Elixir maps:

**WebSocket message schemas (15 types):**
Define a module attribute `@ws_schemas` as a map where each key is the message type string and each value has `required`, `optional`, and `description` fields.

Required/optional fields per type (from research, verified against socket.ex):
- `identify`: required `type` :string, `agent_id` :string, `token` :string; optional `name` :string, `status` :string, `capabilities` {:list, :string}
- `message`: required `type` :string, `payload` :map; optional `to` :string, `message_type` :string, `reply_to` :string
- `status`: required `type` :string, `status` :string
- `list_agents`: required `type` :string
- `ping`: required `type` :string
- `channel_subscribe`: required `type` :string, `channel` :string
- `channel_unsubscribe`: required `type` :string, `channel` :string
- `channel_publish`: required `type` :string, `channel` :string, `payload` :map; optional `message_type` :string, `reply_to` :string
- `channel_history`: required `type` :string, `channel` :string; optional `limit` :integer, `since` :integer
- `list_channels`: required `type` :string
- `task_accepted`: required `type` :string, `task_id` :string
- `task_progress`: required `type` :string, `task_id` :string; optional `progress` :integer
- `task_complete`: required `type` :string, `task_id` :string, `generation` :integer; optional `result` :map, `tokens_used` :integer
- `task_failed`: required `type` :string, `task_id` :string, `generation` :integer; optional `error` :string, `reason` :string
- `task_recovering`: required `type` :string, `task_id` :string

Note: `generation` is required for `task_complete` and `task_failed` -- verified sidecar sends it (line 511-519 of sidecar/index.js).

**HTTP endpoint schemas:**
Define `@http_schemas` map keyed by atom identifiers:
- `:post_message` -- required `payload` :map; optional `to` :string, `type` :string, `reply_to` :string
- `:put_heartbeat_interval` -- required `heartbeat_interval_ms` :positive_integer
- `:put_mailbox_retention` -- required `mailbox_ttl_ms` :positive_integer
- `:post_channel` -- required `name` :string; optional `description` :string
- `:post_channel_publish` -- required `payload` :map; optional `type` :string, `reply_to` :string
- `:post_mailbox_ack` -- required `seq` :integer
- `:post_admin_token` -- required `agent_id` :string
- `:post_admin_push_task` -- required `agent_id` :string, `description` :string; optional `metadata` :map
- `:post_task` -- required `description` :string; optional `priority` :string, `metadata` :map, `max_retries` :integer, `complete_by` :integer, `needed_capabilities` {:list, :string}
- `:post_onboard_register` -- required `agent_id` :string (non-empty)
- `:put_default_repo` -- required `url` :string (non-empty)
- `:post_push_subscribe` -- required `endpoint` :string (push subscription object must have endpoint)

Public functions: `get(type)`, `all()`, `known_types()`, `http_schema(atom)`, `to_json()` (serializes all schemas to JSON-friendly format for GET /api/schemas).

**String length limits** (per research discretion):
Define `@length_limits` map: `"agent_id"` => 128, `"description"` => 10_000, `"status"` => 256, `"channel"` => 64, `"token"` => 256, `"error"` => 2_000, `"reason"` => 2_000, `"name"` => 256. Apply in validation -- check after type validation passes.

Create `lib/agent_com/validation.ex` with the central validation logic:

**`validate_ws_message(msg)`** -- accepts a decoded JSON map:
1. Check `msg` is a map. If not, return `{:error, [%{field: "message", error: :wrong_type, detail: "expected JSON object"}]}`.
2. Check `"type"` field exists and is a string.
3. Look up schema with `Schemas.get(type)`. If nil, return `{:error, [%{field: "type", error: :unknown_message_type, detail: "unknown message type '#{type}'", known_types: Schemas.known_types()}]}`.
4. Call `validate_against_schema(msg, schema)`.

**`validate_http(schema_key, params)`** -- accepts an atom and body_params map:
1. Look up schema with `Schemas.http_schema(schema_key)`.
2. Call `validate_against_schema(params, schema)`.

**`validate_against_schema(data, schema)`** -- private:
1. Check required fields -- each must be present (not nil) and match expected type.
2. Check optional fields -- only if present, validate type.
3. Check string length limits where applicable.
4. Return `{:ok, data}` if no errors, `{:error, errors}` otherwise.
5. Unknown fields pass through untouched (LOCKED user decision: accept and pass through).

**Type checking** -- strict, no coercion (LOCKED user decision):
- `:string` -- `is_binary(v)`
- `:integer` -- `is_integer(v)`
- `:positive_integer` -- `is_integer(v) and v > 0`
- `:map` -- `is_map(v)`
- `{:list, item_type}` -- `is_list(v)` (check item types too)
- `:any` -- always valid
- `:boolean` -- `is_boolean(v)`

**Error format** -- each error is a map with: `field` (string), `error` (atom like :required, :wrong_type, :too_long, :unknown_message_type), `detail` (human-readable string). For :wrong_type and :too_long, include `value` key echoing the offending value (LOCKED: echo back offending fields).

**`format_errors(errors)`** -- converts internal error maps to JSON-friendly maps (string keys, atom error to string).

Do NOT use Ecto, ex_json_schema, or any external dependency. Pure Elixir pattern matching and guards only.
  </action>
  <verify>
Run `mix compile --warnings-as-errors` -- should compile with zero warnings. Manually verify in `iex -S mix`:
- `AgentCom.Validation.Schemas.known_types()` returns list of 15 message types
- `AgentCom.Validation.validate_ws_message(%{"type" => "ping"})` returns `{:ok, %{"type" => "ping"}}`
- `AgentCom.Validation.validate_ws_message(%{"type" => "identify"})` returns `{:error, [%{field: "agent_id", ...}, %{field: "token", ...}]}`
- `AgentCom.Validation.validate_ws_message(%{"type" => "bogus"})` returns error with :unknown_message_type and known_types list
- `AgentCom.Validation.validate_ws_message(%{"type" => "task_complete", "task_id" => "t1", "generation" => "not_int"})` returns error with :wrong_type for generation
- `AgentCom.Validation.validate_http(:post_task, %{"description" => "test"})` returns `{:ok, ...}`
- `AgentCom.Validation.validate_http(:post_task, %{})` returns error for missing description
  </verify>
  <done>
Validation module compiles, validates all 15 WS message types and all HTTP endpoint schemas, returns {:ok, data} for valid input and {:error, errors} with field-level detail for invalid input. Unknown fields pass through. Types are strictly checked (no coercion). String length limits enforced.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ViolationTracker and ETS backoff table</name>
  <files>lib/agent_com/validation/violation_tracker.ex, lib/agent_com/application.ex</files>
  <action>
Create `lib/agent_com/validation/violation_tracker.ex`:

This module provides functions (NOT a GenServer) for tracking validation violations per agent. It uses the Socket process state for per-connection violation counting and an ETS table for cross-connection backoff persistence.

**Per-connection tracking (pure functions, called from Socket):**

`track_violation(state)` -- takes Socket state with `violation_count` and `violation_window_start` fields. Returns updated state map with new count and window_start. Logic:
1. Get current time in milliseconds.
2. If `violation_window_start` is nil or elapsed > 60_000ms, reset window: count = 1, window_start = now.
3. Otherwise increment count.

`should_disconnect?(state)` -- returns true if `violation_count >= 10`, false otherwise. This is a separate function so the caller can decide what to do.

**Cross-connection backoff (ETS-backed):**

`record_disconnect(agent_id)` -- inserts/updates `:validation_backoff` ETS table. Each entry is `{agent_id, disconnect_count, last_disconnect_at}`. If entry exists, increment disconnect_count and update timestamp. If not, insert with count 1.

`check_backoff(agent_id)` -- returns `:ok` if no cooldown active, or `{:cooldown, remaining_seconds}` if agent is still in cooldown period. Cooldown durations per LOCKED user decision:
- 1st disconnect: 30 seconds
- 2nd disconnect: 60 seconds
- 3rd+ disconnect: 300 seconds (5 minutes)

`backoff_remaining(agent_id)` -- returns remaining cooldown in seconds (for error messages), or 0 if no cooldown.

`clear_backoff(agent_id)` -- removes agent from backoff table (for admin use / testing).

`sweep_expired(max_age_ms \\ 600_000)` -- removes entries older than max_age_ms from ETS. To be called periodically (can be done by the existing Reaper or a new timer, but for now just provide the function).

**ETS table creation in application.ex:**

Modify `lib/agent_com/application.ex` -- add ETS table creation at the TOP of `start/2` BEFORE the children list:

```elixir
:ets.new(:validation_backoff, [:named_table, :public, :set])
```

This goes before the children list because the ETS table must exist before any Socket process starts (Bandit is the last child, but be safe). Use `:public` so Socket processes can read/write directly. Use `:set` for unique agent_id keys.

Do NOT create a GenServer for this. The ViolationTracker is a module of pure functions + ETS operations. The Socket process calls these functions directly.
  </action>
  <verify>
Run `mix compile --warnings-as-errors` -- compiles cleanly. Verify in `iex -S mix`:
- `:ets.info(:validation_backoff)` returns table info (not :undefined) -- table exists
- `AgentCom.Validation.ViolationTracker.check_backoff("test-agent")` returns `:ok` (no backoff)
- `AgentCom.Validation.ViolationTracker.record_disconnect("test-agent")` inserts entry
- `AgentCom.Validation.ViolationTracker.check_backoff("test-agent")` returns `{:cooldown, _seconds}`
- `AgentCom.Validation.ViolationTracker.clear_backoff("test-agent")` cleans up
  </verify>
  <done>
ViolationTracker module provides per-connection violation counting (pure functions) and cross-connection backoff tracking (ETS-backed). Application.ex creates :validation_backoff ETS table at startup. 10 failures in 1 minute triggers disconnect. Backoff escalates: 30s, 1m, 5m per LOCKED user decisions.
  </done>
</task>

</tasks>

<verification>
- `mix compile --warnings-as-errors` passes
- All 15 WebSocket message types have schemas in Schemas.all()
- All HTTP endpoint schemas defined and accessible via Schemas.http_schema/1
- ViolationTracker functions work against the ETS table
- No new dependencies added (pure Elixir)
</verification>

<success_criteria>
- AgentCom.Validation.validate_ws_message/1 correctly validates all 15 message types
- AgentCom.Validation.validate_http/2 correctly validates all HTTP endpoint bodies
- Error responses include field-level detail with offending values echoed back
- Unknown fields pass through without error
- Strict type checking (no coercion)
- ViolationTracker tracks per-agent failures with 1-minute window
- Backoff ETS table persists disconnect state across connections
</success_criteria>

<output>
After completion, create `.planning/phases/12-input-validation/12-01-SUMMARY.md`
</output>
