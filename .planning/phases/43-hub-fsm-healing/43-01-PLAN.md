---
phase: 43-hub-fsm-healing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/agent_com/health_aggregator.ex
  - lib/agent_com/hub_fsm.ex
  - lib/agent_com/hub_fsm/predicates.ex
  - test/agent_com/health_aggregator_test.exs
autonomous: true
must_haves:
  truths:
    - "HealthAggregator.assess/0 returns a structured health report with issues list"
    - "FSM has :healing as a valid state with transitions from any state to :healing and :healing to :resting"
    - "Predicates.evaluate/2 checks health and returns {:transition, :healing, reason} when critical issues exist"
    - "FSM tick drives healing transition when should_heal? is true"
  artifacts:
    - path: "lib/agent_com/health_aggregator.ex"
      provides: "Unified health signal aggregation from Alerter, MetricsCollector, LlmRegistry, AgentFSM"
      exports: ["assess/0"]
    - path: "lib/agent_com/hub_fsm.ex"
      provides: "5-state FSM with :healing state and healing cooldown tracking"
      contains: "healing"
    - path: "lib/agent_com/hub_fsm/predicates.ex"
      provides: "should_heal? evaluation in predicate logic"
      contains: "should_heal"
    - path: "test/agent_com/health_aggregator_test.exs"
      provides: "Unit tests for HealthAggregator"
  key_links:
    - from: "lib/agent_com/hub_fsm/predicates.ex"
      to: "lib/agent_com/health_aggregator.ex"
      via: "HealthAggregator.assess/0 called from system_state"
      pattern: "HealthAggregator"
    - from: "lib/agent_com/hub_fsm.ex"
      to: "lib/agent_com/hub_fsm/predicates.ex"
      via: "Predicates.evaluate/2 with health data in system_state"
      pattern: "Predicates.evaluate"
---

<objective>
Add the :healing state to the Hub FSM and create the HealthAggregator module that unifies health signals from existing infrastructure (Alerter, MetricsCollector, LlmRegistry, AgentFSM).

Purpose: Establish the FSM state machine foundation for healing -- the state, transitions, predicate evaluation, and health signal aggregation. Remediation actions come in Plan 02.
Output: HealthAggregator module, updated FSM with 5 states, updated Predicates with healing evaluation, unit tests.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@lib/agent_com/hub_fsm.ex
@lib/agent_com/hub_fsm/predicates.ex
@lib/agent_com/hub_fsm/history.ex
@lib/agent_com/alerter.ex
@lib/agent_com/metrics_collector.ex
@lib/agent_com/llm_registry.ex
@lib/agent_com/agent_fsm.ex
@lib/agent_com/task_queue.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HealthAggregator module with assess/0</name>
  <files>lib/agent_com/health_aggregator.ex, test/agent_com/health_aggregator_test.exs</files>
  <action>
Create `AgentCom.HealthAggregator` as a stateless module (no GenServer -- just functions).

`assess/0` gathers health signals from 4 existing sources and returns a structured report:

```elixir
def assess do
  now = System.system_time(:millisecond)
  alerts = safe_call(fn -> AgentCom.Alerter.active_alerts() end, [])
  metrics = safe_call(fn -> AgentCom.MetricsCollector.snapshot() end, %{})
  endpoints = safe_call(fn -> AgentCom.LlmRegistry.list_endpoints() end, [])
  agents = safe_call(fn -> AgentCom.AgentFSM.list_all() end, [])

  issues = []
    |> check_stuck_tasks(alerts)
    |> check_offline_agents(agents)
    |> check_unhealthy_endpoints(endpoints)
    |> check_high_error_rate(metrics)

  %{
    healthy: issues == [],
    issues: issues,
    critical_count: Enum.count(issues, & &1.severity == :critical),
    timestamp: now
  }
end
```

Issue struct format: `%{source: atom, severity: :critical | :warning, category: atom, detail: map}`.

Categories:
- `:stuck_tasks` (critical if 3+ stuck) -- from Alerter `:stuck_tasks` alert
- `:offline_agents` (warning) -- from AgentFSM.list_all filtered for :offline with assigned tasks
- `:unhealthy_endpoints` (critical if ALL unhealthy) -- from LlmRegistry.list_endpoints
- `:high_error_rate` (warning) -- from MetricsCollector snapshot error_rates

Every source call wrapped in try/catch returning safe default. HealthAggregator NEVER crashes.

Write unit tests in `test/agent_com/health_aggregator_test.exs`:
- Test with no issues returns `%{healthy: true, issues: []}`
- Test with mock stuck_tasks alert returns issue with correct category
- Test with all endpoints unhealthy returns critical endpoint issue
- Test that source failures are handled gracefully (returns healthy when sources unavailable)
  </action>
  <verify>
`mix test test/agent_com/health_aggregator_test.exs` passes all tests.
`mix compile --warnings-as-errors` compiles clean.
  </verify>
  <done>HealthAggregator.assess/0 returns structured health report aggregating signals from Alerter, MetricsCollector, LlmRegistry, and AgentFSM. All source failures handled gracefully.</done>
</task>

<task type="auto">
  <name>Task 2: Add :healing state to FSM and Predicates</name>
  <files>lib/agent_com/hub_fsm.ex, lib/agent_com/hub_fsm/predicates.ex</files>
  <action>
**In hub_fsm.ex:**

1. Update `@valid_transitions` to add :healing. Per CONTEXT.md, any state can transition to :healing, and :healing exits only to :resting:
```elixir
@valid_transitions %{
  resting: [:executing, :improving, :healing],
  executing: [:resting, :healing],
  improving: [:resting, :executing, :contemplating, :healing],
  contemplating: [:resting, :executing, :healing],
  healing: [:resting]
}
```

2. Add healing-related fields to the struct:
```elixir
defstruct [
  :fsm_state, :last_state_change, :tick_ref, :watchdog_ref,
  cycle_count: 0, paused: false, transition_count: 0,
  healing_cooldown_until: 0,    # timestamp (ms) when cooldown expires
  healing_attempts: 0,          # count within rolling window
  healing_attempts_window_start: 0  # start of rolling 10-min window
]
```

3. Update `gather_system_state/0` to include health data:
```elixir
health = safe_call(fn -> AgentCom.HealthAggregator.assess() end, %{healthy: true, issues: [], critical_count: 0})
# Add to the returned map:
health_report: health,
healing_cooldown_active: now < state.healing_cooldown_until
```
Note: `gather_system_state` is a private function called from the tick handler. The healing_cooldown_until value needs to be passed in. Refactor gather_system_state to accept the state struct so it can check cooldown, OR add cooldown checking in the Predicates module by passing cooldown info in the system_state map. Choose the approach that keeps Predicates pure -- pass cooldown info through system_state.

4. Update the tick handler to pass cooldown info to system_state:
```elixir
system_state = gather_system_state()
system_state = Map.merge(system_state, %{
  healing_cooldown_active: System.system_time(:millisecond) < state.healing_cooldown_until,
  healing_attempts: state.healing_attempts,
  healing_attempts_window_start: state.healing_attempts_window_start
})
```

5. Add `handle_info({:healing_cycle_complete, result}, state)` handler following the pattern from `:improvement_cycle_complete`:
```elixir
def handle_info({:healing_cycle_complete, result}, state) do
  Logger.info("healing_cycle_complete", result: inspect(result))
  if state.fsm_state == :healing do
    now = System.system_time(:millisecond)
    updated = do_transition(state, :resting, "healing cycle complete")
    # Set cooldown: 5 minutes from now
    updated = %{updated | healing_cooldown_until: now + 300_000}
    {:noreply, updated}
  else
    {:noreply, state}
  end
end
```

6. In `do_transition/3`, add placeholder for healing cycle spawn (actual Healing module comes in Plan 02):
```elixir
if new_state == :healing do
  pid = self()
  Task.start(fn ->
    # Healing.run_healing_cycle/1 will be implemented in Plan 02
    # For now, return immediately
    result = %{actions_taken: 0, issues_found: 0, placeholder: true}
    send(pid, {:healing_cycle_complete, result})
  end)
end
```

7. Update ClaudeClient notification in do_transition to handle :healing (skip notification for :healing like :resting).

**In predicates.ex:**

1. Add healing evaluation. The `should_heal?` logic checks health_report in system_state. Healing is highest priority -- checked BEFORE other transitions in non-resting states:

```elixir
# Healing evaluation for all states (except :healing itself)
def evaluate(:healing, _system_state), do: :stay

# For each existing state, add healing check FIRST:
def evaluate(current_state, %{health_report: %{critical_count: critical}} = sys)
    when current_state != :healing and critical > 0
    and not Map.get(sys, :healing_cooldown_active, false) do
  {:transition, :healing, "critical health issues detected (#{critical} critical)"}
end
```

Add this clause BEFORE existing evaluate/2 clauses so it takes priority. The pattern match on `critical > 0` and `healing_cooldown_active: false` ensures healing only triggers when there are critical issues AND cooldown has expired.

2. Keep all existing predicate clauses unchanged -- healing preempts via pattern matching priority.

3. Update @moduledoc to reflect 5 states.
  </action>
  <verify>
`mix compile --warnings-as-errors` compiles clean.
`mix test test/agent_com/hub_fsm_test.exs` passes (if exists).
Manually verify in `iex -S mix`: `AgentCom.HubFSM.force_transition(:healing, "test")` works from :resting after adding :healing to resting transitions.
  </verify>
  <done>FSM has 5 states with :healing. Predicates evaluate health and trigger :healing on critical issues with cooldown respect. Healing cycle complete handler transitions to :resting with 5-min cooldown.</done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` -- zero warnings
2. `mix test test/agent_com/health_aggregator_test.exs` -- all tests pass
3. `mix test --exclude skip --exclude smoke` -- no regressions
4. HealthAggregator.assess/0 returns %{healthy: bool, issues: list, critical_count: integer}
5. @valid_transitions includes :healing with correct in/out transitions
6. Predicates.evaluate(:healing, _) returns :stay
7. Predicates.evaluate(:executing, %{health_report: %{critical_count: 3}}) returns {:transition, :healing, _}
</verification>

<success_criteria>
- HealthAggregator aggregates 4 health sources into structured report
- FSM recognizes :healing as valid state with correct transition rules
- Predicates trigger :healing when critical issues detected and cooldown expired
- Healing cycle complete handler sets 5-minute cooldown
- All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/43-hub-fsm-healing/43-01-SUMMARY.md`
</output>
