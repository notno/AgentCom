---
phase: 43-hub-fsm-healing
plan: 02
type: execute
wave: 2
depends_on: ["43-01"]
files_modified:
  - lib/agent_com/hub_fsm/healing.ex
  - lib/agent_com/hub_fsm.ex
  - test/agent_com/hub_fsm/healing_test.exs
autonomous: true
must_haves:
  truths:
    - "Healing requeues stuck tasks when agent is offline and dead-letters after 3 retries"
    - "Healing attempts Ollama endpoint recovery with exponential backoff"
    - "Healing falls back to Claude routing when all Ollama endpoints fail recovery"
    - "All remediation actions are logged with timestamps and outcomes"
  artifacts:
    - path: "lib/agent_com/hub_fsm/healing.ex"
      provides: "Remediation action module with run_healing_cycle/0"
      exports: ["run_healing_cycle/0"]
    - path: "test/agent_com/hub_fsm/healing_test.exs"
      provides: "Unit tests for healing remediation actions"
  key_links:
    - from: "lib/agent_com/hub_fsm/healing.ex"
      to: "lib/agent_com/task_queue.ex"
      via: "TaskQueue.reclaim_task/1, TaskQueue.list/1, TaskQueue.fail_task/3"
      pattern: "TaskQueue"
    - from: "lib/agent_com/hub_fsm/healing.ex"
      to: "lib/agent_com/llm_registry.ex"
      via: "LlmRegistry.list_endpoints/0 for endpoint recovery"
      pattern: "LlmRegistry"
    - from: "lib/agent_com/hub_fsm.ex"
      to: "lib/agent_com/hub_fsm/healing.ex"
      via: "Healing.run_healing_cycle/0 called from Task.start on :healing entry"
      pattern: "Healing.run_healing_cycle"
---

<objective>
Implement the healing remediation actions: stuck task requeue/dead-letter, offline agent cleanup, and Ollama endpoint recovery with exponential backoff and Claude fallback.

Purpose: The healing state needs actual remediation logic, not just detection. This plan implements HEAL-04 (stuck tasks) and HEAL-05 (endpoint recovery) -- the two most impactful automated fixes.
Output: Healing module with remediation actions, updated FSM to call real healing, unit tests.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-hub-fsm-healing/43-01-SUMMARY.md
@lib/agent_com/hub_fsm.ex
@lib/agent_com/hub_fsm/healing.ex
@lib/agent_com/health_aggregator.ex
@lib/agent_com/task_queue.ex
@lib/agent_com/llm_registry.ex
@lib/agent_com/agent_fsm.ex
@lib/agent_com/alerter.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Healing module with remediation actions</name>
  <files>lib/agent_com/hub_fsm/healing.ex, test/agent_com/hub_fsm/healing_test.exs</files>
  <action>
Create `AgentCom.HubFSM.Healing` module with `run_healing_cycle/0`.

The healing cycle:
1. Call `HealthAggregator.assess/0` to get current health report
2. Sort issues by priority (stuck_tasks > offline_agents > unhealthy_endpoints > high_error_rate)
3. Execute remediation actions sequentially
4. Collect results and return summary

```elixir
defmodule AgentCom.HubFSM.Healing do
  @moduledoc """
  Remediation actions for the :healing FSM state.

  Called from an async Task spawned by HubFSM when entering :healing.
  All actions are wrapped in try/catch to prevent cascading failures.
  """
  require Logger

  def run_healing_cycle do
    Logger.info("healing_cycle_started")
    health = AgentCom.HealthAggregator.assess()

    results = health.issues
      |> Enum.sort_by(&priority/1)
      |> Enum.map(fn issue ->
        result = remediate(issue)
        log_action(issue, result)
        {issue.category, result}
      end)

    summary = %{
      issues_found: length(health.issues),
      actions_taken: length(results),
      results: results,
      timestamp: System.system_time(:millisecond)
    }

    Logger.info("healing_cycle_complete", summary: inspect(summary))
    summary
  end
end
```

**Remediation action 1: Stuck tasks (HEAL-04)**

```elixir
defp remediate(%{category: :stuck_tasks, detail: detail}) do
  task_ids = Map.get(detail, :task_ids, [])

  results = Enum.map(task_ids, fn task_id ->
    try do
      # Get task to check retry count
      tasks = AgentCom.TaskQueue.list(status: :assigned)
      task = Enum.find(tasks, fn t -> t.id == task_id end)

      cond do
        is_nil(task) ->
          {:skip, task_id, "task not found or no longer assigned"}

        Map.get(task, :retry_count, 0) >= 3 ->
          # Dead-letter after 3 retries
          AgentCom.TaskQueue.fail_task(task_id, task.generation, "stuck: exceeded 3 retries")
          {:dead_lettered, task_id}

        true ->
          # Check if agent is offline
          agent_id = task.agent_id
          agent = find_agent(agent_id)

          if is_nil(agent) or agent.fsm_state == :offline do
            AgentCom.TaskQueue.reclaim_task(task_id)
            {:requeued, task_id, "agent offline"}
          else
            # Agent is online but slow -- skip, let pipeline timeout handle it
            {:skip, task_id, "agent online, deferring to pipeline timeout"}
          end
      end
    catch
      kind, error ->
        {:error, task_id, "#{kind}: #{inspect(error)}"}
    end
  end)

  %{action: :stuck_task_remediation, results: results}
end
```

**Remediation action 2: Offline agents**

```elixir
defp remediate(%{category: :offline_agents, detail: detail}) do
  agent_ids = Map.get(detail, :agent_ids, [])

  results = Enum.map(agent_ids, fn agent_id ->
    try do
      # Requeue any tasks assigned to this offline agent
      assigned = AgentCom.TaskQueue.list(status: :assigned)
      agent_tasks = Enum.filter(assigned, fn t -> t.agent_id == agent_id end)

      requeued = Enum.map(agent_tasks, fn task ->
        AgentCom.TaskQueue.reclaim_task(task.id)
        task.id
      end)

      {:cleaned, agent_id, requeued_tasks: requeued}
    catch
      kind, error ->
        {:error, agent_id, "#{kind}: #{inspect(error)}"}
    end
  end)

  %{action: :offline_agent_cleanup, results: results}
end
```

**Remediation action 3: Unhealthy endpoints (HEAL-05)**

```elixir
defp remediate(%{category: :unhealthy_endpoints, detail: detail}) do
  endpoint_ids = Map.get(detail, :endpoint_ids, [])

  # Attempt recovery with exponential backoff: 5s, 15s, 45s
  backoff_schedule = [5_000, 15_000, 45_000]

  recovery_results = Enum.map(endpoint_ids, fn ep_id ->
    try do
      recovered = attempt_endpoint_recovery(ep_id, backoff_schedule)
      if recovered, do: {:recovered, ep_id}, else: {:failed, ep_id}
    catch
      kind, error ->
        {:error, ep_id, "#{kind}: #{inspect(error)}"}
    end
  end)

  any_recovered = Enum.any?(recovery_results, fn
    {:recovered, _} -> true
    _ -> false
  end)

  # If no endpoints recovered, log that Claude fallback is available
  # (Claude routing happens automatically via scheduler tier fallback)
  unless any_recovered do
    Logger.warning("healing_all_endpoints_failed_recovery",
      message: "all Ollama endpoints failed recovery, Claude tier fallback active")

    :telemetry.execute(
      [:agent_com, :healing, :endpoint_fallback],
      %{failed_endpoints: length(endpoint_ids)},
      %{action: :claude_fallback}
    )
  end

  %{action: :endpoint_recovery, results: recovery_results, claude_fallback: not any_recovered}
end
```

`attempt_endpoint_recovery/2` tries an HTTP health check to the endpoint's base URL with exponential backoff:

```elixir
defp attempt_endpoint_recovery(endpoint_id, [delay | rest]) do
  # Get endpoint URL from registry
  endpoints = AgentCom.LlmRegistry.list_endpoints()
  endpoint = Enum.find(endpoints, fn ep -> ep.id == endpoint_id end)

  if endpoint do
    url = "#{endpoint.base_url}/api/tags"
    case safe_http_get(url, 5_000) do
      {:ok, _} ->
        Logger.info("healing_endpoint_recovered", endpoint_id: endpoint_id)
        true
      {:error, _} ->
        Process.sleep(delay)
        attempt_endpoint_recovery(endpoint_id, rest)
    end
  else
    false
  end
end

defp attempt_endpoint_recovery(_endpoint_id, []), do: false
```

For `safe_http_get/2`, use the existing HTTP client pattern from the codebase. Check if `Req` or `:httpc` is available. Use whatever HTTP client the project already uses (check OllamaClient for the pattern -- it uses `Req`):

```elixir
defp safe_http_get(url, timeout) do
  try do
    case Req.get(url, receive_timeout: timeout, connect_timeout: timeout) do
      {:ok, %{status: status}} when status in 200..299 -> {:ok, status}
      {:ok, %{status: status}} -> {:error, "HTTP #{status}"}
      {:error, reason} -> {:error, reason}
    end
  catch
    kind, error -> {:error, "#{kind}: #{inspect(error)}"}
  end
end
```

**Remediation action 4: High error rate (catch-all)**

```elixir
defp remediate(%{category: :high_error_rate}) do
  # No automated fix for high error rate -- log for awareness
  Logger.warning("healing_high_error_rate", message: "high error rate detected, no automated fix")
  %{action: :high_error_rate_noted, results: [:logged]}
end

# Catch-all for unknown categories
defp remediate(%{category: category}) do
  Logger.warning("healing_unknown_category", category: category)
  %{action: :unknown, results: [:skipped]}
end
```

**Helper functions:**

```elixir
defp priority(%{category: :stuck_tasks}), do: 1
defp priority(%{category: :offline_agents}), do: 2
defp priority(%{category: :unhealthy_endpoints}), do: 3
defp priority(%{category: :high_error_rate}), do: 4
defp priority(_), do: 99

defp find_agent(agent_id) do
  try do
    agents = AgentCom.AgentFSM.list_all()
    Enum.find(agents, fn a -> a.agent_id == agent_id end)
  catch
    _, _ -> nil
  end
end

defp log_action(issue, result) do
  :telemetry.execute(
    [:agent_com, :healing, :action],
    %{timestamp: System.system_time(:millisecond)},
    %{category: issue.category, severity: issue.severity, result: result}
  )
end
```

**Tests** in `test/agent_com/hub_fsm/healing_test.exs`:
- Test run_healing_cycle with no issues returns summary with 0 actions
- Test stuck task remediation requeues tasks (mock TaskQueue if needed, or use test helpers)
- Test endpoint recovery failure path returns correct structure
- Test that remediation errors are caught and don't crash the cycle
  </action>
  <verify>
`mix compile --warnings-as-errors` compiles clean.
`mix test test/agent_com/hub_fsm/healing_test.exs` passes.
  </verify>
  <done>Healing.run_healing_cycle/0 implements stuck task requeue/dead-letter, offline agent cleanup, and Ollama endpoint recovery with exponential backoff. All actions wrapped in try/catch.</done>
</task>

<task type="auto">
  <name>Task 2: Wire Healing module into FSM Task.start</name>
  <files>lib/agent_com/hub_fsm.ex</files>
  <action>
Update the placeholder healing Task.start in `do_transition/3` (created in Plan 01) to call the real Healing module:

Replace the placeholder:
```elixir
if new_state == :healing do
  pid = self()
  Task.start(fn ->
    result = %{actions_taken: 0, issues_found: 0, placeholder: true}
    send(pid, {:healing_cycle_complete, result})
  end)
end
```

With the real call:
```elixir
if new_state == :healing do
  pid = self()
  Task.start(fn ->
    result = AgentCom.HubFSM.Healing.run_healing_cycle()
    send(pid, {:healing_cycle_complete, result})
  end)
end
```

Also update the healing_cycle_complete handler to track attempt counts for the 3-attempt limit:

```elixir
def handle_info({:healing_cycle_complete, result}, state) do
  Logger.info("healing_cycle_complete", result: inspect(result))

  if state.fsm_state == :healing do
    now = System.system_time(:millisecond)

    # Track attempts within 10-minute rolling window
    {new_attempts, window_start} =
      if now - state.healing_attempts_window_start > 600_000 do
        # Window expired, reset
        {1, now}
      else
        {state.healing_attempts + 1, state.healing_attempts_window_start}
      end

    updated = do_transition(state, :resting, "healing cycle complete")
    updated = %{updated |
      healing_cooldown_until: now + 300_000,
      healing_attempts: new_attempts,
      healing_attempts_window_start: window_start
    }

    {:noreply, updated}
  else
    {:noreply, state}
  end
end
```

Update the Predicates healing check (in predicates.ex or by adding attempt info to system_state) to respect the 3-attempt limit:

In `hub_fsm.ex` gather_system_state enhancement:
```elixir
healing_attempts_exhausted: state.healing_attempts >= 3 and
  (System.system_time(:millisecond) - state.healing_attempts_window_start) <= 600_000
```

In `predicates.ex`, update the healing guard to also check attempts:
```elixir
def evaluate(current_state, %{health_report: %{critical_count: critical}} = sys)
    when current_state != :healing and critical > 0
    and not Map.get(sys, :healing_cooldown_active, false)
    and not Map.get(sys, :healing_attempts_exhausted, false) do
  {:transition, :healing, "critical health issues detected (#{critical} critical)"}
end
```
  </action>
  <verify>
`mix compile --warnings-as-errors` compiles clean.
`mix test --exclude skip --exclude smoke` passes -- no regressions.
  </verify>
  <done>FSM spawns real Healing.run_healing_cycle/0 on :healing entry. Attempt tracking enforces 3-attempt limit within 10-minute window. Cooldown and attempt limits prevent healing storms.</done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` -- zero warnings
2. `mix test test/agent_com/hub_fsm/healing_test.exs` -- all tests pass
3. `mix test --exclude skip --exclude smoke` -- no regressions
4. Healing.run_healing_cycle/0 handles all issue categories
5. Stuck tasks are requeued (agent offline) or dead-lettered (3+ retries)
6. Endpoint recovery uses exponential backoff (5s, 15s, 45s)
7. 3-attempt limit within 10-minute window prevents healing storms
</verification>

<success_criteria>
- Healing module implements prioritized remediation for stuck tasks, offline agents, and endpoint recovery
- FSM calls real Healing.run_healing_cycle/0 instead of placeholder
- Exponential backoff for endpoint recovery (5s, 15s, 45s)
- 3-attempt limit within 10-minute window enforced
- All remediation actions wrapped in try/catch (no cascading failures)
</success_criteria>

<output>
After completion, create `.planning/phases/43-hub-fsm-healing/43-02-SUMMARY.md`
</output>
