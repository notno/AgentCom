---
phase: 43-hub-fsm-healing
plan: 03
type: execute
wave: 3
depends_on: ["43-02"]
files_modified:
  - lib/agent_com/hub_fsm/healing.ex
  - lib/agent_com/hub_fsm.ex
  - lib/agent_com/health_aggregator.ex
  - lib/agent_com/hub_fsm/healing_history.ex
  - lib/agent_com/endpoint.ex
  - test/agent_com/hub_fsm/healing_test.exs
autonomous: true
must_haves:
  truths:
    - "Healing detects merge conflicts and compilation failures and creates high-priority remediation tasks"
    - "Healing state force-transitions to :resting after 5-minute watchdog timeout with critical alert"
    - "All healing actions are logged to a queryable healing history"
    - "Healing history is accessible via /api/hub/healing-history endpoint"
  artifacts:
    - path: "lib/agent_com/hub_fsm/healing.ex"
      provides: "CI/compilation healing remediation actions"
      contains: "compilation"
    - path: "lib/agent_com/hub_fsm/healing_history.ex"
      provides: "ETS-backed healing action audit log"
      exports: ["record/3", "list/1"]
    - path: "lib/agent_com/hub_fsm.ex"
      provides: "5-minute healing watchdog timer"
      contains: "healing_watchdog"
    - path: "lib/agent_com/endpoint.ex"
      provides: "/api/hub/healing-history endpoint"
      contains: "healing-history"
  key_links:
    - from: "lib/agent_com/hub_fsm/healing.ex"
      to: "lib/agent_com/hub_fsm/healing_history.ex"
      via: "HealingHistory.record/3 called after each remediation action"
      pattern: "HealingHistory.record"
    - from: "lib/agent_com/hub_fsm.ex"
      to: "lib/agent_com/hub_fsm.ex"
      via: "Process.send_after :healing_watchdog on :healing entry"
      pattern: "healing_watchdog"
    - from: "lib/agent_com/endpoint.ex"
      to: "lib/agent_com/hub_fsm/healing_history.ex"
      via: "HealingHistory.list/1 called from API endpoint"
      pattern: "HealingHistory"
---

<objective>
Add CI/compilation healing, the 5-minute healing watchdog timer, and a queryable audit log for all healing actions.

Purpose: Complete the healing feature set with HEAL-06 (CI healing), HEAL-07 (watchdog), and HEAL-08 (audit logging). CI healing delegates fixing to an OpenClaw agent rather than auto-fixing.
Output: CI/compilation remediation, healing watchdog, healing history module, API endpoint for history.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-hub-fsm-healing/43-01-SUMMARY.md
@.planning/phases/43-hub-fsm-healing/43-02-SUMMARY.md
@lib/agent_com/hub_fsm.ex
@lib/agent_com/hub_fsm/healing.ex
@lib/agent_com/health_aggregator.ex
@lib/agent_com/endpoint.ex
@lib/agent_com/hub_fsm/history.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CI/compilation healing and HealingHistory audit log</name>
  <files>lib/agent_com/hub_fsm/healing.ex, lib/agent_com/hub_fsm/healing_history.ex, lib/agent_com/health_aggregator.ex, test/agent_com/hub_fsm/healing_test.exs</files>
  <action>
**Create HealingHistory module** at `lib/agent_com/hub_fsm/healing_history.ex`:

Follow the same pattern as `HubFSM.History` -- ETS-backed, public, ordered_set:

```elixir
defmodule AgentCom.HubFSM.HealingHistory do
  @moduledoc """
  ETS-backed audit log for healing actions.

  Records every remediation action with timestamp, category, severity,
  action taken, and outcome. Capped at 500 entries.
  """

  @table :hub_healing_history
  @max_entries 500

  def init_table do
    case :ets.whereis(@table) do
      :undefined ->
        :ets.new(@table, [:named_table, :public, :ordered_set, {:read_concurrency, true}])
        :ok
      _ref -> :ok
    end
  end

  def record(category, action, outcome) do
    timestamp = System.system_time(:millisecond)
    entry = %{
      category: category,
      action: action,
      outcome: outcome,
      timestamp: timestamp
    }
    :ets.insert(@table, {{-timestamp, :erlang.unique_integer()}, entry})
    trim()
    :ok
  end

  def list(opts \\ []) do
    limit = Keyword.get(opts, :limit, 50)
    @table
    |> :ets.tab2list()
    |> Enum.sort()
    |> Enum.take(limit)
    |> Enum.map(fn {_key, entry} -> entry end)
  end

  def clear do
    case :ets.whereis(@table) do
      :undefined -> :ok
      _ref -> :ets.delete_all_objects(@table); :ok
    end
  end

  defp trim do
    size = :ets.info(@table, :size)
    if size > @max_entries do
      to_delete = size - @max_entries
      @table
      |> :ets.tab2list()
      |> Enum.sort()
      |> Enum.reverse()
      |> Enum.take(to_delete)
      |> Enum.each(fn {key, _} -> :ets.delete(@table, key) end)
    end
  end
end
```

**Initialize HealingHistory table** in `hub_fsm.ex` init/1:
Add `AgentCom.HubFSM.HealingHistory.init_table()` alongside the existing History.init_table() call.

**Update Healing module** to record actions to HealingHistory:

Update the `log_action/2` function:
```elixir
defp log_action(issue, result) do
  # Record to audit log
  AgentCom.HubFSM.HealingHistory.record(
    issue.category,
    %{severity: issue.severity, detail: issue.detail},
    result
  )

  # Emit telemetry
  :telemetry.execute(
    [:agent_com, :healing, :action],
    %{timestamp: System.system_time(:millisecond)},
    %{category: issue.category, severity: issue.severity, result: result}
  )
end
```

**Add CI/compilation healing to HealthAggregator:**

Add a new check function in HealthAggregator:
```elixir
defp check_compilation_issues(issues) do
  # Check for compilation failures by running mix compile in a safe way
  # Only check if we're in the project directory
  case safe_mix_compile_check() do
    :ok -> issues
    {:error, :merge_conflicts, files} ->
      [%{source: :compilation, severity: :critical, category: :merge_conflicts,
         detail: %{files: files}} | issues]
    {:error, :compilation_failure, output} ->
      [%{source: :compilation, severity: :critical, category: :compilation_failure,
         detail: %{output: String.slice(output, 0, 1000)}} | issues]
  end
end

defp safe_mix_compile_check do
  try do
    # Check for merge conflict markers first (fast, no compilation needed)
    case System.cmd("git", ["diff", "--check"], stderr_to_stdout: true) do
      {output, 0} when output == "" -> :ok
      {output, _} ->
        if String.contains?(output, "conflict") do
          files = output
            |> String.split("\n")
            |> Enum.filter(&String.contains?(&1, ":"))
            |> Enum.map(fn line -> String.split(line, ":") |> List.first() end)
            |> Enum.uniq()
          {:error, :merge_conflicts, files}
        else
          :ok
        end
    end
  catch
    _, _ -> :ok  # If git not available, skip check
  end
end
```

Add `check_compilation_issues` to the assess/0 pipeline.

**Add CI/compilation remediation to Healing module:**

```elixir
defp remediate(%{category: :merge_conflicts, detail: detail}) do
  # Delegate to an OpenClaw agent by creating a high-priority task
  files = Map.get(detail, :files, [])

  try do
    task_params = %{
      title: "Fix merge conflicts in #{length(files)} file(s)",
      description: """
      Merge conflict markers detected by healing system.
      Files: #{Enum.join(files, ", ")}
      Action: Resolve merge conflicts, ensure compilation passes.
      """,
      priority: :urgent,
      source: :healing,
      tags: ["healing", "merge-conflict", "ci"]
    }

    case AgentCom.TaskQueue.submit(task_params) do
      {:ok, task} ->
        Logger.info("healing_created_fix_task", task_id: task.id, files: files)
        %{action: :delegated_to_agent, task_id: task.id}
      {:error, reason} ->
        Logger.error("healing_failed_to_create_task", reason: inspect(reason))
        %{action: :delegation_failed, reason: reason}
    end
  catch
    kind, error ->
      %{action: :delegation_error, error: "#{kind}: #{inspect(error)}"}
  end
end

defp remediate(%{category: :compilation_failure, detail: detail}) do
  output = Map.get(detail, :output, "")

  try do
    task_params = %{
      title: "Fix compilation failure detected by healing",
      description: """
      Compilation failure detected by healing system.
      Error output (truncated): #{String.slice(output, 0, 500)}
      Action: Fix compilation errors, ensure `mix compile` passes.
      """,
      priority: :urgent,
      source: :healing,
      tags: ["healing", "compilation", "ci"]
    }

    case AgentCom.TaskQueue.submit(task_params) do
      {:ok, task} ->
        Logger.info("healing_created_compile_fix_task", task_id: task.id)
        %{action: :delegated_to_agent, task_id: task.id}
      {:error, reason} ->
        %{action: :delegation_failed, reason: reason}
    end
  catch
    kind, error ->
      %{action: :delegation_error, error: "#{kind}: #{inspect(error)}"}
  end
end
```

Update the priority function:
```elixir
defp priority(%{category: :stuck_tasks}), do: 1
defp priority(%{category: :offline_agents}), do: 2
defp priority(%{category: :unhealthy_endpoints}), do: 3
defp priority(%{category: :merge_conflicts}), do: 4
defp priority(%{category: :compilation_failure}), do: 5
defp priority(%{category: :high_error_rate}), do: 6
defp priority(_), do: 99
```

**Add tests:**
- HealingHistory.record/3 stores entries and list/1 retrieves them
- HealingHistory.list/1 respects limit option
- CI/compilation remediation creates task in queue (or test the delegation path)
  </action>
  <verify>
`mix compile --warnings-as-errors` compiles clean.
`mix test test/agent_com/hub_fsm/healing_test.exs` passes.
  </verify>
  <done>CI/compilation healing delegates to OpenClaw agents. HealingHistory records all remediation actions. All categories covered in remediation pipeline.</done>
</task>

<task type="auto">
  <name>Task 2: Add healing watchdog and API endpoint</name>
  <files>lib/agent_com/hub_fsm.ex, lib/agent_com/endpoint.ex</files>
  <action>
**Add 5-minute healing watchdog to hub_fsm.ex (HEAL-07):**

1. Add `@healing_watchdog_ms 300_000` module attribute (5 minutes).

2. Add `:healing_watchdog_ref` to the struct:
```elixir
defstruct [
  ...,
  healing_watchdog_ref: nil
]
```

3. In `do_transition/3`, when entering :healing, arm the healing-specific watchdog:
```elixir
# After the existing Task.start for healing:
if new_state == :healing do
  # ... existing Task.start code ...
end

# Arm healing watchdog (separate from the global 2-hour watchdog)
healing_ref = if new_state == :healing do
  Process.send_after(self(), :healing_watchdog, @healing_watchdog_ms)
end
```

Store the ref in the updated state. When LEAVING :healing (in the healing_cycle_complete handler), cancel the healing watchdog:
```elixir
# In healing_cycle_complete handler, before do_transition:
cancel_timer(state.healing_watchdog_ref)
```

4. Add `handle_info(:healing_watchdog, state)` handler:
```elixir
def handle_info(:healing_watchdog, %{fsm_state: :healing} = state) do
  Logger.critical("healing_watchdog_timeout",
    message: "healing state exceeded 5-minute watchdog, force-transitioning to :resting")

  :telemetry.execute(
    [:agent_com, :healing, :watchdog_timeout],
    %{duration_ms: 300_000},
    %{fsm_state: :healing}
  )

  # Record watchdog timeout in healing history
  AgentCom.HubFSM.HealingHistory.record(
    :watchdog_timeout,
    %{severity: :critical, detail: %{timeout_ms: @healing_watchdog_ms}},
    %{action: :force_transition_resting}
  )

  # Force transition to resting
  updated = do_transition(state, :resting, "healing watchdog: 5-minute timeout exceeded")

  # Set cooldown
  now = System.system_time(:millisecond)
  updated = %{updated | healing_cooldown_until: now + 300_000}

  {:noreply, updated}
end

# Healing watchdog fires but we're not in healing state (already exited)
def handle_info(:healing_watchdog, state) do
  {:noreply, state}
end
```

Make sure these handle_info clauses are placed BEFORE the catch-all `handle_info(_msg, state)`.

5. Update the healing_watchdog_ref in do_transition return value. The cleanest approach: add `healing_watchdog_ref` to the updated state map in do_transition when entering healing, and clear it when leaving healing.

**Add /api/hub/healing-history endpoint to endpoint.ex:**

Find the existing hub API routes in endpoint.ex (or router.ex -- check which handles /api/hub/ routes). Add:

```elixir
get "/api/hub/healing-history" do
  limit = case conn.params["limit"] do
    nil -> 50
    val -> String.to_integer(val)
  end

  history = AgentCom.HubFSM.HealingHistory.list(limit: min(limit, 200))

  conn
  |> put_resp_content_type("application/json")
  |> send_resp(200, Jason.encode!(%{history: history, count: length(history)}))
end
```

Check the existing endpoint.ex pattern for how /api/hub/* routes are structured and follow that exact pattern.

**Update tests:**
- Test healing watchdog fires and transitions to :resting
- Test healing history endpoint returns JSON
  </action>
  <verify>
`mix compile --warnings-as-errors` compiles clean.
`mix test --exclude skip --exclude smoke` passes -- no regressions.
Verify: `curl http://localhost:4000/api/hub/healing-history` returns JSON (when server running).
  </verify>
  <done>5-minute healing watchdog force-transitions to :resting with critical alert. Healing history accessible via /api/hub/healing-history. All HEAL requirements (01-08) implemented.</done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` -- zero warnings
2. `mix test --exclude skip --exclude smoke` -- all tests pass
3. HealingHistory stores and retrieves audit entries
4. CI healing creates high-priority task in queue for merge conflicts
5. Healing watchdog fires after 5 minutes and force-transitions to :resting
6. /api/hub/healing-history returns JSON with healing action log
7. All HEAL-01 through HEAL-08 requirements addressed across Plans 01-03
</verification>

<success_criteria>
- CI/compilation healing detects merge conflicts and creates remediation tasks
- 5-minute watchdog force-transitions stuck healing to :resting
- All healing actions logged to HealingHistory (queryable ETS audit log)
- /api/hub/healing-history API endpoint serves healing history
- No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/43-hub-fsm-healing/43-03-SUMMARY.md`
</output>
