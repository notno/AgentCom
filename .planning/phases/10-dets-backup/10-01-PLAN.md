---
phase: 10-dets-backup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - config/config.exs
  - config/test.exs
  - lib/agent_com/dets_backup.ex
  - lib/agent_com/application.ex
autonomous: true

must_haves:
  truths:
    - "DetsBackup GenServer starts in supervision tree and logs startup"
    - "backup_all/0 syncs and copies all 9 DETS tables to priv/backups/ with timestamped filenames"
    - "Retention cleanup keeps only the last 3 backups per table"
    - "health_metrics/0 returns record count, file size, fragmentation ratio for all 9 tables"
    - "Daily timer schedules automatic backup every 24 hours"
    - "PubSub broadcasts backup_complete event after each backup run"
  artifacts:
    - path: "lib/agent_com/dets_backup.ex"
      provides: "DetsBackup GenServer with backup, retention, health, daily timer"
      contains: "defmodule AgentCom.DetsBackup"
    - path: "config/config.exs"
      provides: "backup_dir config key for production"
      contains: "backup_dir"
    - path: "config/test.exs"
      provides: "backup_dir config key pointing to tmp for tests"
      contains: "backup_dir"
    - path: "lib/agent_com/application.ex"
      provides: "DetsBackup registered in supervision tree"
      contains: "AgentCom.DetsBackup"
  key_links:
    - from: "config/config.exs"
      to: "lib/agent_com/dets_backup.ex"
      via: "Application.get_env(:agent_com, :backup_dir)"
      pattern: "backup_dir"
    - from: "lib/agent_com/dets_backup.ex"
      to: "lib/agent_com/application.ex"
      via: "Supervision tree child spec"
      pattern: "AgentCom.DetsBackup"
---

<objective>
Create the AgentCom.DetsBackup GenServer that handles automated daily backups of all 9 DETS tables, retention cleanup (keep last 3 per table), and exposes health metrics (table sizes, fragmentation, last backup time). Register it in the supervision tree and add backup_dir to config.

Purpose: This is the core engine for DETS data protection. Plan 02 wires it into HTTP endpoints and the dashboard.

Output: dets_backup.ex GenServer, config updates, supervision tree registration
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-dets-backup/10-RESEARCH.md
@.planning/phases/10-dets-backup/10-CONTEXT.md

@lib/agent_com/application.ex
@config/config.exs
@config/test.exs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add backup_dir configuration</name>
  <files>
    config/config.exs
    config/test.exs
  </files>
  <action>
1. In `config/config.exs`, add `backup_dir: "priv/backups"` to the `:agent_com` config block.

2. In `config/test.exs`, add `backup_dir: "tmp/test/backups"` to the `:agent_com` config block.

This follows the existing pattern where DETS paths are configured via Application env (see `task_queue_path`, `channels_path`, etc. in config/test.exs). Do NOT store in AgentCom.Config (DETS-stored config) to avoid chicken-and-egg problem (Config table itself needs backing up).
  </action>
  <verify>
Run `MIX_ENV=test mix compile` -- should compile cleanly.
Verify config is loaded: `MIX_ENV=test mix run -e "IO.inspect(Application.get_env(:agent_com, :backup_dir))"` should output "tmp/test/backups".
  </verify>
  <done>
config/config.exs has backup_dir: "priv/backups" in :agent_com config.
config/test.exs has backup_dir: "tmp/test/backups" in :agent_com config.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AgentCom.DetsBackup GenServer</name>
  <files>
    lib/agent_com/dets_backup.ex
  </files>
  <action>
Create `lib/agent_com/dets_backup.ex` implementing the full DetsBackup GenServer.

**Module attributes:**
```elixir
@tables [
  :task_queue, :task_dead_letter, :agent_mailbox, :message_history,
  :agent_channels, :channel_history, :agentcom_config, :thread_messages, :thread_replies
]
@daily_interval_ms 24 * 60 * 60 * 1000
@max_backups_per_table 3
```

**State shape:**
```elixir
%{
  backup_dir: String.t(),
  last_backup_at: integer() | nil,
  last_backup_results: [map()] | nil
}
```

**`init/1`:**
- Read backup_dir from `Application.get_env(:agent_com, :backup_dir, "priv/backups")`
- Call `File.mkdir_p!/1` on backup_dir
- Schedule daily timer: `Process.send_after(self(), :daily_backup, @daily_interval_ms)`
- Initial state: `last_backup_at: nil, last_backup_results: nil`
- Log startup: `Logger.info("DetsBackup: started, backup_dir=#{backup_dir}, daily interval=24h")`

**Public client API:**

1. `backup_all/0` -- Synchronous. Calls `GenServer.call(@name, :backup_all, 30_000)`. Returns `{:ok, results}` where results is a list of per-table outcome tuples `{:ok, info}` or `{:error, info}`. Used by both the daily timer and the manual API endpoint.

2. `health_metrics/0` -- Synchronous. Calls `GenServer.call(@name, :health_metrics)`. Returns:
```elixir
%{
  tables: [%{table: atom, record_count: int, file_size_bytes: int, fragmentation_ratio: float, status: :ok | :unavailable}, ...],
  last_backup_at: integer() | nil,
  last_backup_results: [...] | nil
}
```

**`handle_call(:backup_all, ...)`:**
- Generate timestamp string: `NaiveDateTime.utc_now() |> NaiveDateTime.to_string() |> String.replace(":", "-") |> String.replace(" ", "T") |> String.slice(0, 19)` â†’ produces `2026-02-11T14-30-00` (Windows-safe)
- Ensure backup_dir exists: `File.mkdir_p!(state.backup_dir)`
- Iterate over `@tables`, calling `backup_table/3` for each. Use `Enum.map` -- do NOT stop on individual table failure (best-effort per user decision).
- After all tables processed, run `cleanup_old_backups/2` for each table
- Record `last_backup_at` and `last_backup_results` in state
- Log results: `Logger.info("DetsBackup: backup complete, #{success_count}/#{length(@tables)} tables backed up")`
- Broadcast via PubSub:
```elixir
Phoenix.PubSub.broadcast(AgentCom.PubSub, "backups", {:backup_complete, %{
  timestamp: System.system_time(:millisecond),
  tables_backed_up: success_tables,
  backup_dir: state.backup_dir
}})
```
- Reply with `{:ok, results}`

**`handle_call(:health_metrics, ...)`:**
- Iterate over `@tables`, calling `table_metrics/1` for each
- Return map with `:tables` list, `:last_backup_at`, `:last_backup_results`

**`handle_info(:daily_backup, state)`:**
- Call internal `do_backup_all(state)` (same logic as handle_call, extracted to shared function)
- Reschedule: `Process.send_after(self(), :daily_backup, @daily_interval_ms)`
- `{:noreply, updated_state}`

**Private functions:**

`backup_table(table_atom, backup_dir, timestamp)`:
- Check if table is open: `case :dets.info(table_atom, :type)` -- if `:undefined`, return `{:error, %{table: table_atom, reason: :table_not_open}}`
- Get source path: `:dets.info(table_atom, :filename) |> to_string()`
- Build backup_path: `Path.join(backup_dir, "#{table_atom}_#{timestamp}.dets")`
- Call `:dets.sync(table_atom)` -- if error, log warning but continue with copy
- Call `File.cp(source_path, backup_path)`
- On success: `{:ok, %{table: table_atom, path: backup_path, size: File.stat!(backup_path).size}}`
- On failure: `{:error, %{table: table_atom, reason: reason}}`

`cleanup_old_backups(table_atom, backup_dir)`:
- List files in backup_dir matching `"#{table_atom}_*.dets"` pattern using `File.ls!/1` + `Enum.filter`
- Sort alphabetically (timestamps in filename ensure chronological ordering)
- If more than `@max_backups_per_table`, delete oldest ones via `File.rm/1`
- Log deletions at debug level

`table_metrics(table_atom)`:
- Check if table is open: `:dets.info(table_atom, :type)` -- if `:undefined`, return `%{table: table_atom, status: :unavailable, record_count: 0, file_size_bytes: 0, fragmentation_ratio: 0.0}`
- Get `:file_size`, `:no_objects`, `:no_slots` from `:dets.info/2`
- Calculate fragmentation: `{_min, used, max} = :dets.info(table_atom, :no_slots)` then `if max > 0, do: Float.round(1.0 - (used / max), 3), else: 0.0`
- Return `%{table: table_atom, record_count: no_objects, file_size_bytes: file_size, fragmentation_ratio: frag, status: :ok}`
  </action>
  <verify>
Run `mix compile --warnings-as-errors` -- should compile cleanly.
In IEx (`iex -S mix`): `AgentCom.DetsBackup.health_metrics()` returns a map with 9 table entries.
In IEx: `AgentCom.DetsBackup.backup_all()` returns `{:ok, results}` with 9 entries, creates files in priv/backups/.
  </verify>
  <done>
lib/agent_com/dets_backup.ex exists with:
- @tables list of all 9 DETS table atoms
- backup_all/0 client API returning {:ok, results}
- health_metrics/0 client API returning table metrics map
- Daily timer via Process.send_after
- Retention cleanup keeping last 3 per table
- PubSub broadcast on "backups" topic after each backup
- Handles closed/unavailable tables gracefully
  </done>
</task>

<task type="auto">
  <name>Task 3: Register DetsBackup in supervision tree</name>
  <files>
    lib/agent_com/application.ex
  </files>
  <action>
Add `{AgentCom.DetsBackup, []}` to the children list in `lib/agent_com/application.ex`.

Insert after `{AgentCom.DashboardNotifier, []}` and before `{Bandit, ...}`. This ensures all DETS-owning GenServers are already started when DetsBackup initializes (it needs tables to be open for health metrics and backup).

Current children list ends with:
```elixir
{AgentCom.DashboardState, []},
{AgentCom.DashboardNotifier, []},
{Bandit, plug: AgentCom.Endpoint, scheme: :http, port: port()}
```

Should become:
```elixir
{AgentCom.DashboardState, []},
{AgentCom.DashboardNotifier, []},
{AgentCom.DetsBackup, []},
{Bandit, plug: AgentCom.Endpoint, scheme: :http, port: port()}
```
  </action>
  <verify>
Run `mix compile` -- should compile cleanly.
Start the application: `mix run --no-halt` -- check logs for "DetsBackup: started" message.
Verify priv/backups/ directory is created on startup.
  </verify>
  <done>
AgentCom.DetsBackup is registered in the supervision tree after DashboardNotifier and before Bandit.
Application starts cleanly with DetsBackup logging its startup.
  </done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` passes
2. Application starts cleanly with "DetsBackup: started" in logs
3. priv/backups/ directory created on startup
4. `AgentCom.DetsBackup.health_metrics()` returns 9 table entries with record_count, file_size_bytes, fragmentation_ratio, status
5. `AgentCom.DetsBackup.backup_all()` returns {:ok, results} with 9 entries, creates timestamped .dets files in priv/backups/
6. Running backup 4+ times confirms only last 3 backups per table remain
</verification>

<success_criteria>
- DetsBackup GenServer starts in supervision tree and logs startup
- backup_all/0 syncs and copies all 9 DETS tables with timestamped filenames
- Retention cleanup keeps only last 3 backups per table
- health_metrics/0 returns record count, file size, fragmentation ratio for all 9 tables
- Daily timer schedules automatic backup every 24 hours
- PubSub broadcasts backup_complete event after each backup
- Backup dir configurable via Application.get_env with sensible default
</success_criteria>

<output>
After completion, create `.planning/phases/10-dets-backup/10-01-SUMMARY.md`
</output>
