---
phase: 28-pipeline-dependencies
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/agent_com/task_queue.ex
  - lib/agent_com/scheduler.ex
  - lib/agent_com/validation/schemas.ex
  - lib/agent_com/endpoint.ex
  - test/support/test_factory.ex
autonomous: true

must_haves:
  truths:
    - "Tasks with depends_on and goal_id fields can be submitted and persisted"
    - "Scheduler skips tasks whose dependencies have not completed"
    - "Tasks without depends_on schedule normally (no regression)"
    - "TaskQueue validates depends_on task IDs exist at submit time"
    - "Goal progress can be queried by goal_id"
    - "GET /api/tasks supports goal_id filter"
  artifacts:
    - path: "lib/agent_com/task_queue.ex"
      provides: "depends_on, goal_id fields in submit; tasks_for_goal/1; goal_progress/1; dependency validation"
      contains: "depends_on"
    - path: "lib/agent_com/scheduler.ex"
      provides: "Dependency filter in try_schedule_all"
      contains: "depends_on"
    - path: "lib/agent_com/validation/schemas.ex"
      provides: "depends_on and goal_id in post_task schema"
      contains: "depends_on"
    - path: "lib/agent_com/endpoint.ex"
      provides: "depends_on and goal_id param forwarding; goal_id query filter"
      contains: "depends_on"
    - path: "test/support/test_factory.ex"
      provides: "depends_on and goal_id opts in submit_task/1"
      contains: "depends_on"
  key_links:
    - from: "lib/agent_com/endpoint.ex"
      to: "lib/agent_com/task_queue.ex"
      via: "POST /api/tasks forwards depends_on and goal_id to TaskQueue.submit/1"
      pattern: "depends_on.*goal_id"
    - from: "lib/agent_com/scheduler.ex"
      to: "lib/agent_com/task_queue.ex"
      via: "Scheduler calls TaskQueue.get/1 per dependency to check completion"
      pattern: "TaskQueue\\.get"
---

<objective>
Add depends_on and goal_id fields to the task pipeline -- from HTTP API submission through TaskQueue persistence to Scheduler dependency filtering and goal progress queries.

Purpose: Enable goal decomposition (Phase 30) to produce ordered task graphs where dependent tasks wait for prerequisites to complete before scheduling.
Output: Extended task map, scheduler dependency filter, goal progress API, updated validation and endpoint.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-pipeline-dependencies/28-RESEARCH.md
@lib/agent_com/task_queue.ex
@lib/agent_com/scheduler.ex
@lib/agent_com/validation/schemas.ex
@lib/agent_com/endpoint.ex
@test/support/test_factory.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add depends_on and goal_id to TaskQueue with dependency validation and goal progress</name>
  <files>lib/agent_com/task_queue.ex, test/support/test_factory.ex</files>
  <action>
In `task_queue.ex`, add to the task map in `handle_call({:submit, params}, ...)` (after the verification_timeout_ms field, around line 280):

```elixir
# Pipeline dependency fields (Phase 28)
depends_on: Map.get(params, :depends_on, Map.get(params, "depends_on", [])),
goal_id: Map.get(params, :goal_id, Map.get(params, "goal_id", nil))
```

Add dependency validation BEFORE `persist_task/2` (after building the task map). Check that each ID in depends_on exists in either the tasks or dead_letter table. If any are invalid, return `{:error, {:invalid_dependencies, invalid_ids}}` without persisting:

```elixir
deps = Map.get(task, :depends_on, [])
invalid = Enum.reject(deps, fn dep_id ->
  match?({:ok, _}, lookup_task(dep_id)) or match?({:ok, _}, lookup_dead_letter(dep_id))
end)
```

If `invalid != []`, reply with `{:error, {:invalid_dependencies, invalid}}` and skip persist/broadcast/telemetry. Otherwise proceed normally.

Add two new public functions:

```elixir
@doc "Return all tasks belonging to a goal."
def tasks_for_goal(goal_id) do
  GenServer.call(__MODULE__, {:tasks_for_goal, goal_id})
end

@doc "Return goal progress summary: total, completed, failed, pending."
def goal_progress(goal_id) do
  tasks = tasks_for_goal(goal_id)
  total = length(tasks)
  completed = Enum.count(tasks, fn t -> Map.get(t, :status) == :completed end)
  failed = Enum.count(tasks, fn t -> Map.get(t, :status) == :dead_letter end)
  %{goal_id: goal_id, total: total, completed: completed, failed: failed, pending: total - completed - failed}
end
```

Add the handle_call for `{:tasks_for_goal, goal_id}`:

```elixir
def handle_call({:tasks_for_goal, goal_id}, _from, state) do
  tasks =
    :dets.foldl(
      fn {_id, task}, acc ->
        if Map.get(task, :goal_id) == goal_id, do: [task | acc], else: acc
      end,
      [],
      @tasks_table
    )
  {:reply, tasks, state}
end
```

Add goal_id filter to the existing `handle_call({:list, opts}, ...)` handler. After the existing filter variables (status_filter, priority_filter, assigned_filter), add:

```elixir
goal_filter = Keyword.get(opts, :goal_id)
```

And add to the matches expression: `and (is_nil(goal_filter) or Map.get(task, :goal_id) == goal_filter)`.

IMPORTANT: Use `Map.get(task, :depends_on, [])` and `Map.get(task, :goal_id, nil)` everywhere when reading from task maps for DETS backward compatibility.

In `test/support/test_factory.ex`, add to the `submit_task/1` params map:

```elixir
depends_on: Keyword.get(opts, :depends_on, []),
goal_id: Keyword.get(opts, :goal_id, nil)
```
  </action>
  <verify>Run `mix compile --warnings-as-errors` -- must compile cleanly. Run `mix test test/agent_com/task_queue_test.exs` -- all existing tests must pass (backward compatible).</verify>
  <done>TaskQueue accepts depends_on and goal_id at submit, validates dependency existence, provides tasks_for_goal/1 and goal_progress/1 functions, and list/1 supports goal_id filter. All existing tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Add scheduler dependency filter, API schema/endpoint updates</name>
  <files>lib/agent_com/scheduler.ex, lib/agent_com/validation/schemas.ex, lib/agent_com/endpoint.ex</files>
  <action>
In `scheduler.ex`, add a dependency filter in `try_schedule_all/2` AFTER the Phase 23 repo filter (after line 300, before the telemetry execute call at line 302). Insert:

```elixir
# Phase 28: Filter out tasks whose dependencies are not yet completed
schedulable_tasks =
  Enum.filter(schedulable_tasks, fn task ->
    deps = Map.get(task, :depends_on, [])
    deps == [] or Enum.all?(deps, fn dep_id ->
      case AgentCom.TaskQueue.get(dep_id) do
        {:ok, %{status: :completed}} -> true
        _ -> false
      end
    end)
  end)
```

In `scheduler.ex`, add depends_on and goal_id to the `task_data` map in `do_assign/4` (around line 566, after the max_verification_retries line):

```elixir
# Pipeline dependency fields (Phase 28)
depends_on: Map.get(assigned_task, :depends_on, []),
goal_id: Map.get(assigned_task, :goal_id)
```

In `validation/schemas.ex`, add two fields to the `post_task` optional map (after the existing `"complexity_tier" => :string` line):

```elixir
"depends_on" => {:list, :string},
"goal_id" => :string
```

In `endpoint.ex`, POST /api/tasks handler: add to the `task_params` map (after verification_timeout_ms, around line 918):

```elixir
depends_on: params["depends_on"] || [],
goal_id: params["goal_id"]
```

In `endpoint.ex`, GET /api/tasks handler: add goal_id filter (after the assigned_to filter line, around line 970):

```elixir
opts = if g = conn.params["goal_id"], do: [{:goal_id, g} | opts], else: opts
```
  </action>
  <verify>Run `mix compile --warnings-as-errors` -- must compile cleanly. Run `mix test test/agent_com/scheduler_test.exs` -- all existing tests must pass (backward compatible).</verify>
  <done>Scheduler filters tasks by dependency completion status. API schema accepts depends_on and goal_id. Endpoint forwards fields on POST and supports goal_id filter on GET. All existing tests pass.</done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` passes
2. `mix test` -- all existing tests pass (zero regressions)
3. Manual check: Submit a task with `depends_on: ["nonexistent"]` returns error
4. Manual check: Submit task A, then task B with `depends_on: [A.id]` -- B is accepted
</verification>

<success_criteria>
- Tasks can be submitted with depends_on and goal_id fields via HTTP API
- TaskQueue validates dependency IDs exist at submit time
- Scheduler filters out tasks whose dependencies are incomplete
- Tasks without depends_on continue scheduling normally
- goal_progress/1 returns accurate completion counts
- GET /api/tasks?goal_id=X returns filtered results
- All existing tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/28-pipeline-dependencies/28-01-SUMMARY.md`
</output>
