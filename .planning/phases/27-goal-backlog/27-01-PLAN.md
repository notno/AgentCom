---
phase: 27-goal-backlog
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/agent_com/goal_backlog.ex
  - lib/agent_com/application.ex
  - lib/agent_com/dets_backup.ex
  - test/support/dets_helpers.ex
  - test/agent_com/goal_backlog_test.exs
autonomous: true

must_haves:
  truths:
    - "GoalBacklog GenServer starts in supervision tree and opens DETS table"
    - "Goals can be submitted with description, success_criteria, priority, and source"
    - "Goals persist across GenServer restart via DETS"
    - "Lifecycle transitions are enforced (submitted->decomposing->executing->verifying->complete/failed)"
    - "Invalid transitions are rejected with descriptive error"
    - "Priority index orders goals by priority then created_at"
    - "PubSub events broadcast on goal_submitted and every lifecycle transition"
    - "DETS table registered with DetsBackup for backup/compaction/recovery"
  artifacts:
    - path: "lib/agent_com/goal_backlog.ex"
      provides: "GoalBacklog GenServer with DETS persistence, lifecycle state machine, priority index, PubSub"
      contains: "defmodule AgentCom.GoalBacklog"
    - path: "test/agent_com/goal_backlog_test.exs"
      provides: "Unit tests for submit, transition, list, stats, persistence"
      contains: "defmodule AgentCom.GoalBacklogTest"
  key_links:
    - from: "lib/agent_com/goal_backlog.ex"
      to: "Phoenix.PubSub"
      via: "broadcast on goals topic"
      pattern: "Phoenix\\.PubSub\\.broadcast.*goals"
    - from: "lib/agent_com/goal_backlog.ex"
      to: ":dets"
      via: "persist_goal with sync"
      pattern: ":dets\\.(insert|sync|open_file)"
    - from: "lib/agent_com/dets_backup.ex"
      to: "lib/agent_com/goal_backlog.ex"
      via: "table registration"
      pattern: "table_owner\\(:goal_backlog\\)"
---

<objective>
Implement the GoalBacklog GenServer with DETS persistence, lifecycle state machine, priority ordering, PubSub event broadcasting, and DetsBackup registration.

Purpose: GoalBacklog is the centralized storage and lifecycle engine for goals -- higher-level work items that decompose into 1-N tasks. This is the foundation that HTTP API and CLI layers will build on.
Output: Working GoalBacklog GenServer with submit/transition/list/stats/dequeue API, passing tests, registered in supervision tree and DetsBackup.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-goal-backlog/27-RESEARCH.md
@lib/agent_com/task_queue.ex
@lib/agent_com/dets_backup.ex
@lib/agent_com/application.ex
@test/support/dets_helpers.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement GoalBacklog GenServer with DETS persistence and lifecycle state machine</name>
  <files>lib/agent_com/goal_backlog.ex</files>
  <action>
Create `AgentCom.GoalBacklog` GenServer following the TaskQueue pattern exactly. Key implementation details:

**Module attributes:**
- `@table :goal_backlog`
- `@priority_map %{"urgent" => 0, "high" => 1, "normal" => 2, "low" => 3}`
- `@valid_transitions %{submitted: [:decomposing], decomposing: [:executing, :failed], executing: [:verifying, :failed], verifying: [:complete, :failed, :executing]}`
- `@history_cap 50`

**init/1:** Read `data_dir()` from `Application.get_env(:agent_com, :goal_backlog_data_dir, "priv/data/goal_backlog")`. Open DETS with `type: :set, auto_save: 5_000`. Rebuild priority index from DETS contents. Return `{:ok, %{priority_index: priority_index}}`.

**Public API functions (GenServer.call wrappers):**
- `submit(params)` -- creates goal with generated ID (`"goal-" <> Base.encode16(:crypto.strong_rand_bytes(8), case: :lower)`), required fields: description, success_criteria. Optional: priority (default "normal"), source (default "api"), tags, repo, file_hints, metadata, submitted_by, depends_on. Returns `{:ok, goal}`.
- `transition(goal_id, new_status, opts \\ [])` -- validates transition against `@valid_transitions`, updates status/updated_at/history, optional child_task_ids and reason in opts. Removes from priority index when leaving :submitted. Returns `{:ok, updated_goal}` or `{:error, {:invalid_transition, from, to}}` or `{:error, :not_found}`.
- `list(filters \\ %{})` -- returns all goals, optionally filtered by status and/or priority. Fold over DETS, not GenServer state.
- `get(goal_id)` -- lookup single goal by ID. Returns `{:ok, goal}` or `{:error, :not_found}`.
- `dequeue()` -- pop highest-priority :submitted goal from priority index, transition to :decomposing. Returns `{:ok, goal}` or `{:error, :empty}`.
- `stats()` -- count by status and by priority. Returns map like `%{by_status: %{submitted: 3, executing: 1}, by_priority: %{0 => 1, 2 => 3}, total: 4}`.
- `delete(goal_id)` -- remove goal from DETS and priority index. Returns `:ok` or `{:error, :not_found}`.

**Private helpers:**
- `persist_goal/1` -- `:dets.insert(@table, {goal.id, goal})` then `:dets.sync(@table)`. On error, cast corruption_detected to DetsBackup.
- `lookup_goal/1` -- `:dets.lookup(@table, goal_id)` pattern match.
- `rebuild_priority_index/0` -- fold DETS, collect `{priority, created_at, goal_id}` for goals with status :submitted, sort ascending.
- `add_to_priority_index/2`, `remove_from_priority_index/2` -- maintain sorted list.
- `broadcast_goal_event/2` -- `Phoenix.PubSub.broadcast(AgentCom.PubSub, "goals", {:goal_event, %{event: event, goal_id: goal.id, goal: goal, timestamp: System.system_time(:millisecond)}})`.
- `cap_history/1` -- `Enum.take(history, @history_cap)`.
- `generate_goal_id/0` -- `"goal-" <> Base.encode16(:crypto.strong_rand_bytes(8), case: :lower)`.
- `data_dir/0` -- reads from Application env with fallback.

**Telemetry:** Emit `[:agent_com, :goal, :submit]` on submit and `[:agent_com, :goal, :transition]` on transition, with goal_id, priority, source/new_status metadata.

**child_spec:** Use `use GenServer` with `name: __MODULE__`.
  </action>
  <verify>
Run `mix compile --warnings-as-errors` -- no compilation errors.
Grep for `defmodule AgentCom.GoalBacklog` to confirm module exists.
Verify `@valid_transitions` map covers all 6 lifecycle states.
  </verify>
  <done>GoalBacklog GenServer compiles with submit, transition, list, get, dequeue, stats, delete API. DETS persistence with sync after every mutation. Lifecycle state machine enforces valid transitions. PubSub broadcasts on all state changes. Priority index maintained for dequeue ordering.</done>
</task>

<task type="auto">
  <name>Task 2: Register GoalBacklog in supervision tree, DetsBackup, DetsHelpers, and write tests</name>
  <files>
lib/agent_com/application.ex
lib/agent_com/dets_backup.ex
test/support/dets_helpers.ex
test/agent_com/goal_backlog_test.exs
  </files>
  <action>
**application.ex:** Add `{AgentCom.GoalBacklog, []}` to the children list. Place it after `AgentCom.DetsBackup` and before the `Bandit` entry (following the convention of DETS-backed GenServers being before the HTTP server). The exact position: after `{AgentCom.DetsBackup, []}`.

**dets_backup.ex -- 4 changes:**
1. Add `:goal_backlog` to the `@tables` list (after `:cost_ledger`).
2. Add clause: `defp table_owner(:goal_backlog), do: AgentCom.GoalBacklog`
3. Add clause in `get_table_path/1` case statement:
   ```
   :goal_backlog ->
     dir = Application.get_env(:agent_com, :goal_backlog_data_dir, "priv/data/goal_backlog")
     Path.join(dir, "goal_backlog.dets")
   ```

**DetsHelpers (test/support/dets_helpers.ex) -- 3 changes:**
1. In `setup_test_dets/0`: Add `Application.put_env(:agent_com, :goal_backlog_data_dir, Path.join(tmp_dir, "goal_backlog"))` and `File.mkdir_p!(Path.join(tmp_dir, "goal_backlog"))`.
2. In `restart_dets_servers/0` stop_order: Add `AgentCom.GoalBacklog` after `AgentCom.CostLedger` (before TaskQueue).
3. In `restart_dets_servers/0` dets_tables list: Add `:goal_backlog`.

**goal_backlog_test.exs:** Create test file with these test cases:
- `test "submit creates goal with generated ID and required fields"` -- submit with description + success_criteria, verify returned goal has id, status :submitted, timestamps.
- `test "submit defaults priority to normal (2)"` -- submit without priority, verify priority is 2.
- `test "submit with explicit priority"` -- submit with priority "urgent", verify priority is 0.
- `test "get returns submitted goal"` -- submit then get by ID, verify match.
- `test "get returns error for unknown ID"` -- get("nonexistent"), verify {:error, :not_found}.
- `test "transition follows valid lifecycle"` -- submit, transition to :decomposing, verify status changed.
- `test "transition rejects invalid state change"` -- submit, try transition to :complete (skipping steps), verify {:error, {:invalid_transition, :submitted, :complete}}.
- `test "transition to failed from any active state"` -- verify decomposing->failed, executing->failed, verifying->failed all succeed.
- `test "dequeue returns highest priority goal"` -- submit 3 goals (low, urgent, normal), dequeue, verify urgent one returned, status changed to :decomposing.
- `test "dequeue returns error when empty"` -- dequeue on empty backlog, verify {:error, :empty}.
- `test "list returns all goals"` -- submit 3, list, verify count 3.
- `test "list filters by status"` -- submit 2, transition one to :decomposing, list with status filter, verify counts.
- `test "stats returns counts by status and priority"` -- submit several with different priorities, verify stats map.
- `test "delete removes goal"` -- submit, delete, get returns not_found.
- `test "PubSub events broadcast on submit and transition"` -- subscribe to "goals" topic, submit a goal, assert_receive {:goal_event, %{event: :goal_submitted}}, transition, assert_receive {:goal_event, %{event: :goal_decomposing}}.
- `test "goals persist across GenServer restart"` -- submit goal, restart GenServer (GenServer.stop + start), get goal by ID, verify it's still there.

Use `setup` block with `DetsHelpers.full_test_setup()` and `on_exit` with `full_test_teardown`. Subscribe to PubSub topic `"goals"` in PubSub tests.
  </action>
  <verify>
Run `mix test test/agent_com/goal_backlog_test.exs --trace` -- all tests pass.
Run `mix test` -- full suite passes (no regressions).
  </verify>
  <done>GoalBacklog is in the supervision tree, DETS table registered with DetsBackup for backup/compaction/recovery, DetsHelpers provides test isolation, and all 16 test cases pass covering submit, transition lifecycle, priority ordering, dequeue, list/filter, stats, delete, PubSub events, and DETS persistence across restart.</done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` -- clean compilation
2. `mix test test/agent_com/goal_backlog_test.exs --trace` -- all tests green
3. `mix test` -- full suite passes, no regressions
4. Verify GoalBacklog appears in application.ex children list
5. Verify :goal_backlog appears in DetsBackup @tables list
6. Verify DetsHelpers includes goal_backlog in setup, stop_order, and dets_tables
</verification>

<success_criteria>
GoalBacklog GenServer is operational with DETS persistence, enforced lifecycle transitions, priority-ordered dequeue, PubSub event broadcasting, and full test coverage. Ready for HTTP API and CLI integration in Plan 02.
</success_criteria>

<output>
After completion, create `.planning/phases/27-goal-backlog/27-01-SUMMARY.md`
</output>
