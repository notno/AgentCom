---
phase: 11-dets-compaction
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - lib/agent_com/dets_backup.ex
  - lib/agent_com/mailbox.ex
  - lib/agent_com/channels.ex
  - lib/agent_com/task_queue.ex
  - lib/agent_com/message_history.ex
  - lib/agent_com/config.ex
  - lib/agent_com/threads.ex
autonomous: true
must_haves:
  truths:
    - "A corrupted DETS table is automatically restored from the latest backup without operator intervention"
    - "Restored data integrity is verified via record count and open/close test before resuming operations"
    - "When both table and backup are corrupted, the system continues in degraded mode with an empty table"
    - "Push notifications fire on auto-restore events"
  artifacts:
    - path: "lib/agent_com/dets_backup.ex"
      provides: "Recovery orchestration: find_latest_backup, restore_table, verify_table_integrity, corruption handler"
      contains: "restore_table"
    - path: "lib/agent_com/mailbox.ex"
      provides: "Corruption detection in hot-path DETS operations"
      contains: "corruption_detected"
    - path: "lib/agent_com/task_queue.ex"
      provides: "Corruption detection in hot-path DETS operations"
      contains: "corruption_detected"
  key_links:
    - from: "lib/agent_com/mailbox.ex"
      to: "lib/agent_com/dets_backup.ex"
      via: "GenServer.cast for corruption_detected"
      pattern: "corruption_detected"
    - from: "lib/agent_com/dets_backup.ex"
      to: "AgentCom.Supervisor"
      via: "Supervisor.terminate_child + restart_child for recovery"
      pattern: "Supervisor\\.(terminate_child|restart_child)"
---

<objective>
Add DETS corruption recovery: auto-restore from backup, integrity verification, degraded mode fallback, and corruption detection in hot-path GenServer operations.

Purpose: When DETS tables become corrupted (detectable at open time or during runtime operations), the system must automatically restore from the latest backup, verify data integrity, and resume operations -- or fall back to degraded mode if backups are also corrupted. This fulfills requirement DETS-05.

Output: DetsBackup gains recovery logic (find backup, stop owner, replace file, restart owner, verify). Key GenServers detect corruption in their DETS calls and trigger auto-recovery.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-dets-compaction/11-RESEARCH.md
@.planning/phases/11-dets-compaction/11-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add recovery logic to DetsBackup</name>
  <files>lib/agent_com/dets_backup.ex</files>
  <action>
Add recovery functions to DetsBackup GenServer for restoring DETS tables from backup.

**1. Add find_latest_backup/2:**
```elixir
@doc "Find the most recent backup file for a table."
def find_latest_backup(table_atom, backup_dir) do
  prefix = "#{table_atom}_"

  case File.ls(backup_dir) do
    {:ok, files} ->
      case files
           |> Enum.filter(fn f -> String.starts_with?(f, prefix) and String.ends_with?(f, ".dets") end)
           |> Enum.sort()
           |> List.last() do
        nil -> {:error, :no_backup_found}
        filename -> {:ok, Path.join(backup_dir, filename)}
      end
    {:error, reason} ->
      {:error, {:backup_dir_unreadable, reason}}
  end
end
```

**2. Add verify_table_integrity/1:**
Per locked decision: "Verify restored data integrity before resuming normal operations (record count, open/close test)."
```elixir
defp verify_table_integrity(table_atom) do
  case :dets.info(table_atom, :type) do
    :undefined ->
      {:error, :table_not_open}
    _ ->
      record_count = :dets.info(table_atom, :no_objects)
      file_size = :dets.info(table_atom, :file_size)

      # Attempt a fold to verify data readability (the "open/close test" is handled by the GenServer restart)
      traversal_ok = try do
        :dets.foldl(fn _record, acc -> acc + 1 end, 0, table_atom)
        true
      catch
        _, _ -> false
      end

      if traversal_ok do
        {:ok, %{record_count: record_count, file_size: file_size}}
      else
        {:error, :data_unreadable}
      end
  end
end
```

**3. Add restore_table/2 (the core recovery procedure):**
This uses `table_owner/1` from Plan 01. Recovery steps:
1. Stop the owning GenServer via Supervisor.terminate_child
2. Replace the corrupted file with the backup copy
3. Restart the owning GenServer via Supervisor.restart_child (init/1 opens the restored file)
4. Verify integrity

```elixir
defp get_table_path(table_atom) do
  # The table must currently be open to get its path, but during recovery it may be closed.
  # Use the known path conventions from the codebase.
  case table_atom do
    :agent_mailbox -> Application.get_env(:agent_com, :mailbox_path, "priv/mailbox.dets")
    :message_history -> Application.get_env(:agent_com, :message_history_path, "priv/message_history.dets")
    :agent_channels ->
      dir = Application.get_env(:agent_com, :channels_path, "priv")
      Path.join(dir, "channels.dets")
    :channel_history ->
      dir = Application.get_env(:agent_com, :channels_path, "priv")
      Path.join(dir, "channel_history.dets")
    :agentcom_config ->
      dir = Application.get_env(:agent_com, :data_dir, ".agentcom/data")
      Path.join(dir, "config.dets")
    :thread_messages ->
      dir = Application.get_env(:agent_com, :data_dir, ".agentcom/data")
      Path.join(dir, "thread_messages.dets")
    :thread_replies ->
      dir = Application.get_env(:agent_com, :data_dir, ".agentcom/data")
      Path.join(dir, "thread_replies.dets")
    :task_queue -> Application.get_env(:agent_com, :task_queue_path, "priv/task_queue.dets")
    :task_dead_letter -> Application.get_env(:agent_com, :task_dead_letter_path, "priv/task_dead_letter.dets")
  end
end

defp do_restore_table(table_atom, backup_dir) do
  owner = table_owner(table_atom)
  original_path = get_table_path(table_atom)

  case find_latest_backup(table_atom, backup_dir) do
    {:ok, backup_path} ->
      try do
        # Step 1: Stop owner GenServer (terminate/2 closes DETS tables)
        :ok = Supervisor.terminate_child(AgentCom.Supervisor, owner)

        # Step 2: Replace corrupted file with backup
        File.cp!(backup_path, original_path)

        # Step 3: Restart owner GenServer (init/1 opens the restored file)
        case Supervisor.restart_child(AgentCom.Supervisor, owner) do
          {:ok, _pid} ->
            # Step 4: Verify integrity (per locked decision)
            case verify_table_integrity(table_atom) do
              {:ok, integrity_info} ->
                backup_filename = Path.basename(backup_path)
                {:ok, %{table: table_atom, backup_used: backup_filename, integrity: integrity_info}}
              {:error, reason} ->
                Logger.error("DetsBackup: integrity verification failed for #{table_atom} after restore: #{inspect(reason)}")
                {:error, {:integrity_failed, reason}}
            end

          {:error, restart_reason} ->
            Logger.critical("DetsBackup: failed to restart #{owner} after restore: #{inspect(restart_reason)}")
            # Per discretion: enter degraded mode -- delete corrupted file and restart with empty table
            handle_restart_failure(table_atom, owner, original_path)
        end
      rescue
        e ->
          Logger.critical("DetsBackup: restore failed for #{table_atom}: #{inspect(e)}")
          # Try to restart the owner even if copy failed
          try do
            Supervisor.restart_child(AgentCom.Supervisor, owner)
          catch
            _, _ -> :ok
          end
          {:error, {:restore_failed, e}}
      end

    {:error, :no_backup_found} ->
      Logger.critical("DetsBackup: no backup found for #{table_atom}, entering degraded mode")
      handle_no_backup(table_atom, owner, original_path)

    {:error, reason} ->
      {:error, reason}
  end
end
```

**4. Add degraded mode handler** (per discretion decision: empty table + CRITICAL log + operator notification):
```elixir
defp handle_restart_failure(table_atom, owner, original_path) do
  Logger.critical("DetsBackup: both table and backup corrupted for #{table_atom}, entering degraded mode with empty table")
  # Delete corrupted file, let init/1 create fresh empty table
  File.rm(original_path)
  case Supervisor.restart_child(AgentCom.Supervisor, owner) do
    {:ok, _pid} ->
      {:ok, %{table: table_atom, status: :degraded, data_lost: true}}
    {:error, reason} ->
      {:error, {:degraded_mode_failed, reason}}
  end
end

defp handle_no_backup(table_atom, owner, original_path) do
  # Same as restart failure -- enter degraded mode
  handle_restart_failure(table_atom, owner, original_path)
end
```

**5. Add public restore API:**
```elixir
@doc """
Restore a specific table from its latest backup.
Per locked decision: operators can force-restore a table at any time.
Returns {:ok, restore_info} or {:error, reason}.
"""
def restore_table(table_atom) when table_atom in @tables do
  GenServer.call(__MODULE__, {:restore_table, table_atom}, 60_000)
end
```

**6. Add handle_call for :restore_table:**
```elixir
@impl true
def handle_call({:restore_table, table_atom}, _from, state) do
  result = do_restore_table(table_atom, state.backup_dir)
  now = System.system_time(:millisecond)

  case result do
    {:ok, info} ->
      Phoenix.PubSub.broadcast(AgentCom.PubSub, "backups", {:recovery_complete, %{
        timestamp: now,
        table: table_atom,
        backup_used: info[:backup_used],
        record_count: get_in(info, [:integrity, :record_count]) || 0,
        trigger: :manual
      }})
      {:reply, {:ok, info}, state}

    {:error, reason} ->
      Phoenix.PubSub.broadcast(AgentCom.PubSub, "backups", {:recovery_failed, %{
        timestamp: now,
        table: table_atom,
        reason: reason,
        trigger: :manual
      }})
      {:reply, {:error, reason}, state}
  end
end
```

**7. Add corruption handler (called by owning GenServers via cast):**
Per locked decision: "Auto-restore on corruption detection -- detect corruption, restore from latest backup automatically, notify operator after the fact."
```elixir
@impl true
def handle_cast({:corruption_detected, table_atom, reason}, state) do
  Logger.error("DetsBackup: corruption detected in #{table_atom}: #{inspect(reason)}, initiating auto-restore")
  now = System.system_time(:millisecond)

  result = do_restore_table(table_atom, state.backup_dir)

  case result do
    {:ok, info} ->
      Logger.warning("DetsBackup: auto-restored #{table_atom} from backup #{info[:backup_used]}")
      Phoenix.PubSub.broadcast(AgentCom.PubSub, "backups", {:recovery_complete, %{
        timestamp: now,
        table: table_atom,
        backup_used: info[:backup_used],
        record_count: get_in(info, [:integrity, :record_count]) || 0,
        trigger: :auto
      }})

    {:error, err} ->
      Logger.critical("DetsBackup: auto-restore failed for #{table_atom}: #{inspect(err)}")
      Phoenix.PubSub.broadcast(AgentCom.PubSub, "backups", {:recovery_failed, %{
        timestamp: now,
        table: table_atom,
        reason: err,
        trigger: :auto
      }})
  end

  {:noreply, state}
end
```

IMPORTANT: The `do_restore_table` function uses `Supervisor.terminate_child` and `Supervisor.restart_child`. These work because the supervision tree uses `:one_for_one` strategy and GenServers are registered with their module name as the child ID. Verify this by checking `application.ex`.

IMPORTANT: The `get_table_path/1` function must resolve paths the same way each GenServer's `init/1` does. Read each GenServer's `init/1` to confirm the path resolution matches. If a GenServer uses `String.to_charlist()`, the path stored in DETS info will be a charlist -- `get_table_path/1` returns strings which is what `File.cp!` expects.
  </action>
  <verify>
Run `mix compile --warnings-as-errors` to verify clean compilation. Verify that `find_latest_backup`, `restore_table`, `do_restore_table`, `verify_table_integrity`, `get_table_path`, and `handle_cast({:corruption_detected, ...})` all exist in dets_backup.ex.
  </verify>
  <done>DetsBackup can restore any DETS table from its latest backup via Supervisor stop/file-replace/restart, with integrity verification, degraded mode fallback, and auto-restore triggered by corruption detection casts from owning GenServers.</done>
</task>

<task type="auto">
  <name>Task 2: Add corruption detection to key GenServer hot paths</name>
  <files>
    lib/agent_com/mailbox.ex
    lib/agent_com/channels.ex
    lib/agent_com/task_queue.ex
    lib/agent_com/message_history.ex
    lib/agent_com/config.ex
    lib/agent_com/threads.ex
  </files>
  <action>
Add corruption detection wrappers to the most frequently called DETS operations in each GenServer. When a DETS operation returns `{:error, Reason}`, log the error and cast to DetsBackup to trigger auto-recovery.

Per research anti-pattern guidance: "Wrap the key hot-path calls (lookup, insert) and rely on the compaction-time health check for less frequent operations." Do NOT wrap every DETS call -- only the primary read/write paths.

**Pattern to apply** (adapt per GenServer):
```elixir
# When :dets.lookup or :dets.insert returns {:error, Reason}:
{:error, reason} ->
  Logger.error("DETS corruption detected in #{@table}: #{inspect(reason)}")
  GenServer.cast(AgentCom.DetsBackup, {:corruption_detected, @table, reason})
  {:reply, {:error, :table_corrupted}, state}
```

**Files and specific hot paths to wrap:**

1. **Mailbox** (`mailbox.ex`):
   - `handle_call({:enqueue, ...})` -- wrap `:dets.insert(@table, ...)` return
   - `handle_call({:poll, ...})` -- wrap `:dets.select(@table, ...)` to catch error tuple returns

2. **Channels** (`channels.ex`):
   - `handle_call({:publish, ...})` -- wrap `:dets.lookup(@table, ...)` and `:dets.insert(@history_table, ...)`
   - `handle_call({:subscribe, ...})` -- wrap `:dets.lookup(@table, ...)`

3. **TaskQueue** (`task_queue.ex`):
   - Wrap the `:dets.insert` and `:dets.lookup` in the `submit`, `assign_task`, `complete_task`, and `fail_task` handlers. These are the critical path operations.
   - Be careful: TaskQueue has complex handler logic. Only wrap the specific `:dets.insert` and `:dets.lookup` calls, not the entire handler.

4. **MessageHistory** (`message_history.ex`):
   - `handle_call({:store, ...})` -- wrap `:dets.insert(@table, ...)`

5. **Config** (`config.ex`):
   - `handle_call({:get, ...})` -- wrap `:dets.lookup(@table, ...)`
   - `handle_call({:put, ...})` -- wrap `:dets.insert(@table, ...)`

6. **Threads** (`threads.ex`):
   - `handle_cast({:index, ...})` -- wrap `:dets.insert` calls (note: this is a cast, so reply with `{:noreply, state}` after detecting corruption)

For each corruption detection, use `require Logger` if not already present, and the pattern:
```elixir
case :dets.operation(...) do
  # ... existing success patterns ...
  {:error, reason} ->
    Logger.error("DETS corruption detected in #{table_name}: #{inspect(reason)}")
    GenServer.cast(AgentCom.DetsBackup, {:corruption_detected, table_name, reason})
    # Return appropriate error to caller
end
```

IMPORTANT: Do NOT over-wrap. The `:dets.select` function returns a list on success and `{:error, Reason}` on failure. The `:dets.insert` function returns `:ok` on success and `{:error, Reason}` on failure. The `:dets.lookup` function returns a list on success and `{:error, Reason}` on failure. Only add corruption detection where these error returns are not already handled.

IMPORTANT: For TaskQueue, be especially careful not to break the existing complex logic. Wrap minimally -- the insert/lookup calls in the submit and assign paths are the most critical.
  </action>
  <verify>
Run `mix compile --warnings-as-errors` to verify clean compilation. Run `mix test --exclude smoke --exclude skip` to verify existing tests still pass. Grep for `corruption_detected` across all modified files to confirm detection was added.
  </verify>
  <done>Key DETS operations in all 6 owning GenServers detect corruption ({:error, Reason} returns) and trigger auto-recovery via cast to DetsBackup, without disrupting normal success-path behavior.</done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` passes
2. `mix test --exclude smoke --exclude skip` passes (existing tests unbroken)
3. DetsBackup contains `restore_table/1`, `find_latest_backup/2`, `verify_table_integrity/1`, `do_restore_table/2`, `get_table_path/1`
4. DetsBackup handles `{:corruption_detected, table, reason}` cast
5. At least 6 GenServer files contain `corruption_detected` casts
6. DetsBackup broadcasts `:recovery_complete` and `:recovery_failed` PubSub events
</verification>

<success_criteria>
- Corrupted DETS tables are automatically restored from the latest backup
- Integrity verification (record count + traversal) runs after every restore
- Degraded mode (empty table) activates when both table and backup are corrupted
- Manual restore available via DetsBackup.restore_table/1
- Recovery events broadcast on PubSub "backups" topic
- Corruption detection in hot-path DETS calls triggers auto-recovery
</success_criteria>

<output>
After completion, create `.planning/phases/11-dets-compaction/11-02-SUMMARY.md`
</output>
