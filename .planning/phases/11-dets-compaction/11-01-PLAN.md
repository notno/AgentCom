---
phase: 11-dets-compaction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/agent_com/mailbox.ex
  - lib/agent_com/message_history.ex
  - lib/agent_com/config.ex
  - lib/agent_com/channels.ex
  - lib/agent_com/task_queue.ex
  - lib/agent_com/threads.ex
  - lib/agent_com/dets_backup.ex
autonomous: true
must_haves:
  truths:
    - "Compaction runs on a configurable 6-hour schedule without blocking operations for more than 1 second per table"
    - "Tables below 10% fragmentation are skipped during scheduled compaction"
    - "Compaction failure retries once then waits for next scheduled run"
    - "Compaction results are broadcast on PubSub backups topic"
  artifacts:
    - path: "lib/agent_com/dets_backup.ex"
      provides: "Compaction orchestration, scheduling, history tracking, PubSub events"
      contains: "compact_all"
    - path: "lib/agent_com/mailbox.ex"
      provides: "Compaction handle_call for :agent_mailbox"
      contains: "handle_call(:compact"
    - path: "lib/agent_com/channels.ex"
      provides: "Compaction handle_call for :agent_channels and :channel_history"
      contains: "handle_call({:compact"
    - path: "lib/agent_com/task_queue.ex"
      provides: "Compaction handle_call for :task_queue and :task_dead_letter"
      contains: "handle_call({:compact"
    - path: "lib/agent_com/threads.ex"
      provides: "Compaction handle_call for :thread_messages and :thread_replies"
      contains: "handle_call({:compact"
  key_links:
    - from: "lib/agent_com/dets_backup.ex"
      to: "lib/agent_com/mailbox.ex"
      via: "GenServer.call(AgentCom.Mailbox, :compact)"
      pattern: "GenServer\\.call.*:compact"
    - from: "lib/agent_com/dets_backup.ex"
      to: "lib/agent_com/channels.ex"
      via: "GenServer.call(AgentCom.Channels, {:compact, table_atom})"
      pattern: "GenServer\\.call.*:compact"
---

<objective>
Add DETS compaction to all 9 tables via owning-GenServer handle_calls orchestrated by DetsBackup on a configurable 6-hour schedule.

Purpose: DETS tables accumulate fragmentation over time. Periodic compaction via `repair: force` reclaims wasted space and keeps table performance consistent. This fulfills requirement DETS-03.

Output: All 6 DETS-owning GenServers handle compaction calls. DetsBackup orchestrates serial compaction of all tables, skips below-threshold tables, retries once on failure, and tracks compaction history.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-dets-compaction/11-RESEARCH.md
@.planning/phases/10-dets-backup/10-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add :compact handle_call to all 6 DETS-owning GenServers</name>
  <files>
    lib/agent_com/mailbox.ex
    lib/agent_com/message_history.ex
    lib/agent_com/config.ex
    lib/agent_com/channels.ex
    lib/agent_com/task_queue.ex
    lib/agent_com/threads.ex
  </files>
  <action>
Add a `:compact` handle_call to each of the 6 DETS-owning GenServers. The pattern differs for single-table vs multi-table GenServers:

**Single-table GenServers** (Mailbox, MessageHistory, Config) -- add this handle_call:
```elixir
@impl true
def handle_call(:compact, _from, state) do
  table = @table  # Each module's @table module attribute
  path = :dets.info(table, :filename)
  :ok = :dets.close(table)

  case :dets.open_file(table, file: path, type: :set, repair: :force) do
    {:ok, ^table} ->
      {:reply, :ok, state}
    {:error, reason} ->
      {:reply, {:error, reason}, state}
  end
end
```

For Config, note that it uses `type: :set` but does NOT use `auto_save`. When reopening, match the original open options from each module's `init/1`:
- Mailbox: `type: :set, auto_save: 5_000`
- MessageHistory: `type: :set, auto_save: 5_000`
- Config: `type: :set` (no auto_save)

**Multi-table GenServers** (Channels, TaskQueue, Threads) -- add this handle_call accepting a table argument:
```elixir
# For Channels (owns @table = :agent_channels, @history_table = :channel_history):
@impl true
def handle_call({:compact, table_atom}, _from, state) when table_atom in [@table, @history_table] do
  path = :dets.info(table_atom, :filename)
  :ok = :dets.close(table_atom)

  case :dets.open_file(table_atom, file: path, type: :set, auto_save: 5_000, repair: :force) do
    {:ok, ^table_atom} ->
      {:reply, :ok, state}
    {:error, reason} ->
      {:reply, {:error, reason}, state}
  end
end
```

Match original open options per module:
- Channels: both tables use `type: :set, auto_save: 5_000`
- TaskQueue: both tables (@tasks_table and @dead_letter_table) use `type: :set, auto_save: 5_000`
- Threads: both tables (@messages_table and @replies_table) use `type: :set` (no auto_save)

Place each handle_call after the existing handle_call definitions in each module (before handle_cast or handle_info).

IMPORTANT: The compaction close+reopen must match the exact same options the table was originally opened with (minus `repair: :force` which is the compaction trigger). Check each module's `init/1` to confirm the options.
  </action>
  <verify>
Run `mix compile --warnings-as-errors` to verify no compilation errors or warnings. Grep all 6 files for `:compact` to confirm the handle_call was added.
  </verify>
  <done>All 6 DETS-owning GenServers have a :compact handle_call that closes the table and reopens with repair: force, using the same options as their init/1.</done>
</task>

<task type="auto">
  <name>Task 2: Add compaction orchestration, scheduling, and history to DetsBackup</name>
  <files>lib/agent_com/dets_backup.ex</files>
  <action>
Extend DetsBackup GenServer with compaction orchestration, a configurable schedule, history tracking, and PubSub events.

**1. Add configuration constants and state:**
```elixir
@compaction_interval_ms Application.compile_env(:agent_com, :compaction_interval_ms, 6 * 60 * 60 * 1000)
@compaction_threshold Application.compile_env(:agent_com, :compaction_threshold, 0.1)
```

Update `init/1` state to include:
```elixir
%{
  # ... existing fields ...
  compaction_history: [],        # List of recent compaction run results (capped at 20)
  last_compaction_at: nil        # Epoch ms of last compaction run
}
```

Add `Process.send_after(self(), :scheduled_compaction, @compaction_interval_ms)` in `init/1`.

**2. Add table_owner/1 mapping:**
```elixir
defp table_owner(:agent_mailbox), do: AgentCom.Mailbox
defp table_owner(:message_history), do: AgentCom.MessageHistory
defp table_owner(:agent_channels), do: AgentCom.Channels
defp table_owner(:channel_history), do: AgentCom.Channels
defp table_owner(:agentcom_config), do: AgentCom.Config
defp table_owner(:thread_messages), do: AgentCom.Threads
defp table_owner(:thread_replies), do: AgentCom.Threads
defp table_owner(:task_queue), do: AgentCom.TaskQueue
defp table_owner(:task_dead_letter), do: AgentCom.TaskQueue
```

**3. Add compact_table/1 private function:**
```elixir
defp compact_table(table_atom) do
  owner = table_owner(table_atom)
  start_time = System.system_time(:millisecond)

  # Check fragmentation threshold first
  metrics = table_metrics(table_atom)
  if metrics.status == :ok and metrics.fragmentation_ratio < @compaction_threshold do
    {:skipped, :below_threshold, 0}
  else
    # For single-table GenServers, send :compact
    # For multi-table GenServers, send {:compact, table_atom}
    msg = if owner in [AgentCom.Channels, AgentCom.TaskQueue, AgentCom.Threads] do
      {:compact, table_atom}
    else
      :compact
    end

    result = try do
      GenServer.call(owner, msg, 30_000)
    catch
      :exit, reason -> {:error, reason}
    end

    duration_ms = System.system_time(:millisecond) - start_time

    case result do
      :ok -> {:compacted, duration_ms}
      {:error, reason} -> {:error, reason, duration_ms}
    end
  end
end
```

**4. Add compact_all/0 with retry-once logic:**
```elixir
defp do_compact_all do
  Enum.map(@tables, fn table ->
    case compact_table(table) do
      {:compacted, duration} ->
        %{table: table, status: :compacted, duration_ms: duration}
      {:skipped, reason, _duration} ->
        %{table: table, status: :skipped, reason: reason}
      {:error, reason, duration} ->
        # Retry once per user decision
        Logger.warning("DetsBackup: compaction failed for #{table}: #{inspect(reason)}, retrying once")
        case compact_table(table) do
          {:compacted, retry_duration} ->
            %{table: table, status: :compacted, duration_ms: duration + retry_duration, retried: true}
          {:error, retry_reason, retry_duration} ->
            Logger.error("DetsBackup: compaction retry failed for #{table}: #{inspect(retry_reason)}")
            %{table: table, status: :error, reason: retry_reason, duration_ms: duration + retry_duration}
          {:skipped, skip_reason, _} ->
            %{table: table, status: :skipped, reason: skip_reason}
        end
    end
  end)
end
```

**5. Add public API function:**
```elixir
@doc """
Compact all DETS tables synchronously. Skips tables below fragmentation threshold.
Returns {:ok, results} with per-table compaction outcomes.
"""
def compact_all do
  GenServer.call(__MODULE__, :compact_all, 120_000)
end
```

**6. Add handle_call for :compact_all:**
```elixir
@impl true
def handle_call(:compact_all, _from, state) do
  results = do_compact_all()
  now = System.system_time(:millisecond)

  # Broadcast compaction complete event (per locked decision: silent for success, but event still needed for dashboard)
  Phoenix.PubSub.broadcast(AgentCom.PubSub, "backups", {:compaction_complete, %{
    timestamp: now,
    results: results
  }})

  # Update history (keep last 20 entries)
  entry = %{timestamp: now, results: results}
  history = [entry | state.compaction_history] |> Enum.take(20)

  updated_state = %{state | compaction_history: history, last_compaction_at: now}
  {:reply, {:ok, results}, updated_state}
end
```

**7. Add handle_info for :scheduled_compaction:**
```elixir
@impl true
def handle_info(:scheduled_compaction, state) do
  results = do_compact_all()
  now = System.system_time(:millisecond)

  # Only broadcast/notify on failures (per locked decision: successful compaction is silent)
  failures = Enum.filter(results, fn r -> r.status == :error end)
  if length(failures) > 0 do
    Phoenix.PubSub.broadcast(AgentCom.PubSub, "backups", {:compaction_failed, %{
      timestamp: now,
      failures: failures
    }})
  end

  # Always broadcast compaction_complete for dashboard history
  Phoenix.PubSub.broadcast(AgentCom.PubSub, "backups", {:compaction_complete, %{
    timestamp: now,
    results: results
  }})

  entry = %{timestamp: now, results: results}
  history = [entry | state.compaction_history] |> Enum.take(20)

  Process.send_after(self(), :scheduled_compaction, @compaction_interval_ms)
  {:noreply, %{state | compaction_history: history, last_compaction_at: now}}
end
```

**8. Add compaction_history/0 public API:**
```elixir
@doc "Return the compaction history log (recent events with time, table, result, duration)."
def compaction_history do
  GenServer.call(__MODULE__, :compaction_history)
end
```

And the handle_call:
```elixir
@impl true
def handle_call(:compaction_history, _from, state) do
  {:reply, state.compaction_history, state}
end
```

**9. Update health_metrics/0 reply** to include compaction info:
Update the health_metrics handle_call to include `last_compaction_at` and `compaction_history` in the returned map.
  </action>
  <verify>
Run `mix compile --warnings-as-errors` to verify clean compilation. Start the app with `mix run --no-halt` briefly and confirm DetsBackup starts without error and schedules the compaction timer (check logs for startup message).
  </verify>
  <done>DetsBackup orchestrates serial compaction of all 9 tables through owning GenServers, with configurable 6-hour schedule, 10% fragmentation threshold skip, retry-once on failure, compaction history tracking, and PubSub event broadcasting.</done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` passes with no errors or warnings
2. All 6 GenServer files contain `:compact` handle_call(s)
3. DetsBackup contains `compact_all`, `compact_table`, `table_owner`, `do_compact_all` functions
4. DetsBackup state includes `compaction_history` and `last_compaction_at` fields
5. `mix test` passes (existing tests should not be broken by adding new handle_calls)
</verification>

<success_criteria>
- Every DETS-owning GenServer can compact its table(s) via a handle_call
- DetsBackup orchestrates compaction serially across all 9 tables
- Scheduled compaction fires every 6 hours (configurable)
- Tables below 10% fragmentation are skipped
- Failed compaction retries once then waits for next run
- Compaction events broadcast on PubSub "backups" topic
- Compaction history is tracked in DetsBackup state
</success_criteria>

<output>
After completion, create `.planning/phases/11-dets-compaction/11-01-SUMMARY.md`
</output>
