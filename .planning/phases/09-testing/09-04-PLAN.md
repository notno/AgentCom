---
phase: 09-testing
plan: 04
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - test/integration/task_lifecycle_test.exs
  - test/integration/failure_paths_test.exs
  - test/integration/websocket_e2e_test.exs
autonomous: true

must_haves:
  truths:
    - "An integration test submits a task and observes it flow through submit -> schedule -> assign -> accept -> complete"
    - "An integration test triggers failure paths: timeout, crash, retry, and observes tasks reach dead-letter"
    - "A WebSocket E2E test connects via real WebSocket, identifies, receives task assignment, and completes it"
  artifacts:
    - path: "test/integration/task_lifecycle_test.exs"
      provides: "Happy path integration test via GenServer API"
      contains: "TaskLifecycleTest"
    - path: "test/integration/failure_paths_test.exs"
      provides: "Failure path integration tests"
      contains: "FailurePathsTest"
    - path: "test/integration/websocket_e2e_test.exs"
      provides: "Full WebSocket end-to-end integration test"
      contains: "WebsocketE2eTest"
  key_links:
    - from: "test/integration/task_lifecycle_test.exs"
      to: "lib/agent_com/scheduler.ex"
      via: "Scheduler reacts to task_submitted PubSub and assigns to idle agent"
      pattern: "task_assigned|:assigned"
    - from: "test/integration/failure_paths_test.exs"
      to: "lib/agent_com/task_queue.ex"
      via: "Verifies retry count and dead-letter on exhausted retries"
      pattern: "dead.letter|retry"
    - from: "test/integration/websocket_e2e_test.exs"
      to: "test/support/ws_client.ex"
      via: "WsClient connects to real Bandit server on port 4002"
      pattern: "WsClient"
---

<objective>
Write integration tests that validate the full task pipeline: happy-path lifecycle via GenServer APIs, failure paths (timeout, crash, retry, dead-letter), and one full WebSocket end-to-end test.

Purpose: Satisfies TEST-03 (full task lifecycle integration) and TEST-04 (failure path integration). These tests prove the system works as a whole, not just individual modules. The WebSocket E2E test is the single realistic test that exercises the real protocol per the locked decision.

Output: 3 integration test files validating the complete task pipeline
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-testing/09-RESEARCH.md
@.planning/phases/09-testing/09-01-SUMMARY.md

@lib/agent_com/task_queue.ex
@lib/agent_com/agent_fsm.ex
@lib/agent_com/scheduler.ex
@lib/agent_com/socket.ex
@lib/agent_com/endpoint.ex
@test/support/dets_helpers.ex
@test/support/test_factory.ex
@test/support/ws_client.ex
@test/smoke/helpers/agent_sim.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write task lifecycle and failure paths integration tests</name>
  <files>
    test/integration/task_lifecycle_test.exs
    test/integration/failure_paths_test.exs
  </files>
  <action>
**Task Lifecycle Test** (`test/integration/task_lifecycle_test.exs`):

`use ExUnit.Case, async: false`. Use DetsHelpers for isolation. The Scheduler MUST be running for integration tests -- it's part of what we're testing.

Setup:
```elixir
setup do
  tmp_dir = AgentCom.TestHelpers.DetsHelpers.full_test_setup()

  on_exit(fn ->
    AgentCom.TestHelpers.DetsHelpers.full_test_teardown(tmp_dir)
  end)

  %{tmp_dir: tmp_dir}
end
```

Test: "full lifecycle: submit -> schedule -> assign -> accept -> complete"
1. Create an idle agent using TestFactory.create_agent with capabilities
2. Subscribe to PubSub "tasks" topic BEFORE submitting (Pitfall #7)
3. Submit a task via TestFactory.submit_task
4. Wait for Scheduler to assign: `assert_receive` on task_assigned event (5000ms timeout)
5. Verify task status is now :assigned via TaskQueue.get
6. Verify task is assigned to the correct agent
7. Complete the task via TaskQueue.complete_task with correct generation
8. Verify task status is :completed
9. Clean up agent via TestFactory.cleanup_agent

Check the actual PubSub message format by reading scheduler.ex. The broadcast format may be `{:task_event, %{...}}` or something else.

Test: "task with capabilities matches only capable agents"
1. Create agent-a with capabilities=["code"]
2. Create agent-b with capabilities=["review"]
3. Submit task with needed_capabilities=["code"]
4. Verify task assigned to agent-a (not agent-b)
5. Clean up both agents

**Failure Paths Test** (`test/integration/failure_paths_test.exs`):

`use ExUnit.Case, async: false`. Use DetsHelpers. Scheduler running.

Test: "failed task retries and eventually reaches dead-letter"
1. Create an idle agent
2. Submit task with max_retries=1 (or 2, depending on how retries work -- read source)
3. Wait for assignment
4. Fail the task via TaskQueue.fail_task with correct generation
5. Verify task is re-queued (:queued status) with incremented retry_count
6. Wait for Scheduler to re-assign
7. Fail again
8. Verify task is now in dead-letter (status should indicate max retries exceeded)
9. Clean up

Test: "acceptance timeout causes task to be re-queued"
1. Create an idle agent with on_task_assign = :ignore behavior (or don't use factory -- just register in Presence without starting an FSM that auto-accepts)
2. Submit a task
3. Wait for Scheduler to assign
4. Send acceptance timeout message directly to the FSM: `send(fsm_pid, {:acceptance_timeout, task_id})` (Pitfall #4: avoid waiting for real 60s timer)
5. Verify the task is re-queued or failed appropriately
6. Check actual FSM behavior -- it may notify the hub, re-queue the task, etc.

Test: "agent crash (ws_pid dies) during task execution"
1. Create agent, submit task, wait for assignment
2. Kill the agent's ws_pid: `Process.exit(ws_pid, :kill)`
3. Wait briefly for FSM to process :DOWN
4. Verify task handling: is it re-queued? failed? Check actual behavior in agent_fsm.ex.

Read `lib/agent_com/task_queue.ex` and `lib/agent_com/agent_fsm.ex` carefully to understand:
- How fail_task works (does it auto-retry or just fail?)
- What happens on acceptance timeout
- What happens when ws_pid dies during an active task
- What the dead-letter mechanism looks like (separate DETS table? status field?)
  </action>
  <verify>
Run `MIX_ENV=test mix test test/integration/task_lifecycle_test.exs --trace` -- all pass.
Run `MIX_ENV=test mix test test/integration/failure_paths_test.exs --trace` -- all pass.
Lifecycle test has >= 2 tests. Failure paths test has >= 2 tests.
  </verify>
  <done>
Task lifecycle integration test validates: submit -> schedule -> assign -> complete, and capability-based matching.
Failure paths integration test validates: retry -> dead-letter, acceptance timeout, and agent crash during task execution.
All integration tests use DETS isolation and real Scheduler.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write WebSocket end-to-end integration test</name>
  <files>test/integration/websocket_e2e_test.exs</files>
  <action>
Create `test/integration/websocket_e2e_test.exs` with `use ExUnit.Case, async: false`.

This is the ONE full WebSocket E2E test per the locked decision. It connects via real WebSocket to the Bandit HTTP server running on port 4002 (test port from config/test.exs), identifies as an agent, receives a task_assign message, and completes the task.

Setup:
- Use DetsHelpers.full_test_setup for DETS isolation
- Ensure the Bandit server is running on port 4002 (it should be, since Application starts it)
- Generate a fresh auth token for the test agent

Test: "full WebSocket lifecycle: connect -> identify -> receive task -> complete"
1. Generate auth token: `{:ok, token} = AgentCom.Auth.generate("ws-test-agent")`
2. Start WsClient: `{:ok, ws} = AgentCom.TestHelpers.WsClient.start_link(url: "ws://localhost:4002/ws")`
3. Connect and identify: `AgentCom.TestHelpers.WsClient.connect_and_identify(ws, "ws-test-agent", token)`
4. Wait for identification: `AgentCom.TestHelpers.WsClient.wait_for_identified(ws, 5000)`
5. Verify agent appears in Presence: `AgentCom.Presence.get("ws-test-agent")` returns info
6. Submit a task via TaskQueue (not WebSocket -- we're testing receiving via WS): `{:ok, task} = AgentCom.TaskQueue.submit(%{description: "ws e2e test", needed_capabilities: []})`
7. Wait for the WS client to receive a task_assign message. Poll `WsClient.messages(ws)` looking for a message with `"type" => "task_assign"`. Use a polling helper:
   ```elixir
   Smoke.Assertions.wait_for(fn ->
     msgs = AgentCom.TestHelpers.WsClient.messages(ws)
     Enum.any?(msgs, fn m -> m["type"] == "task_assign" end)
   end, timeout: 10_000)
   ```
8. Extract task_id and generation from the task_assign message
9. Send task_accepted via WebSocket: `WsClient.send_json(ws, %{"type" => "task_accepted", "task_id" => task_id, "protocol_version" => 1})`
10. Send task_complete via WebSocket: `WsClient.send_json(ws, %{"type" => "task_complete", "task_id" => task_id, "generation" => generation, "result" => %{"status" => "success"}, "protocol_version" => 1})`
11. Wait for task to reach :completed status: `Smoke.Assertions.assert_task_completed(task.id, timeout: 10_000)`
12. Verify via TaskQueue.get that the task is completed
13. Stop WsClient: `AgentCom.TestHelpers.WsClient.stop(ws)`

IMPORTANT: The WsClient must handle the full WebSocket protocol correctly:
- HTTP upgrade -> WebSocket handshake
- Send identify message
- Receive and parse JSON frames
- Send JSON frames

If the WsClient from Plan 01 has issues connecting to port 4002, debug by checking:
- Is Bandit running? `GenServer.whereis(Bandit)` or check application children
- Is port 4002 configured? `Application.get_env(:agent_com, :port)`
- Connection errors in WsClient state

FALLBACK: If WsClient has issues, use the existing `Smoke.AgentSim` module directly (it's already proven to work). Adapt the test to use AgentSim with `hub_url: "ws://localhost:4002/ws"` and `on_task_assign: :complete`.

Cleanup in on_exit: stop WsClient, revoke token, cleanup DETS.

Tag this test with `@tag :e2e` so it can be run separately if needed: `mix test --only e2e`.
  </action>
  <verify>
Run `MIX_ENV=test mix test test/integration/websocket_e2e_test.exs --trace` -- test passes.
The test exercises real WebSocket connection, identification, task assignment receipt, and completion via WebSocket protocol.
  </verify>
  <done>
WebSocket E2E test passes, validating: connect to real Bandit server -> identify via WebSocket -> receive task_assign -> send task_accepted + task_complete -> verify task completed in TaskQueue.
The test uses port 4002, real WebSocket framing, and real JSON protocol.
  </done>
</task>

</tasks>

<verification>
1. `MIX_ENV=test mix test test/integration/` -- all integration tests pass
2. Task lifecycle test proves submit->schedule->assign->complete flow
3. Failure paths test proves retry->dead-letter and timeout/crash handling
4. WebSocket E2E test proves full protocol over real WebSocket connection
5. All tests use DETS isolation
6. No flaky Process.sleep synchronization (uses assert_receive and wait_for)
</verification>

<success_criteria>
- Task lifecycle integration test validates happy path through full pipeline with Scheduler running
- Failure paths test validates retry, dead-letter, timeout, and crash scenarios
- WebSocket E2E test connects via real WebSocket to Bandit on port 4002 and completes a task
- All 3 integration test files pass with `mix test`
- Tests satisfy TEST-03 and TEST-04 requirements
</success_criteria>

<output>
After completion, create `.planning/phases/09-testing/09-04-SUMMARY.md`
</output>
