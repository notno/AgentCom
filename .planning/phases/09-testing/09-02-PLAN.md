---
phase: 09-testing
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - test/agent_com/task_queue_test.exs
  - test/agent_com/agent_fsm_test.exs
  - test/agent_com/scheduler_test.exs
autonomous: true

must_haves:
  truths:
    - "TaskQueue unit tests cover submit, get, assign, complete, fail, retry, dead-letter, sweep_overdue, and stale generation"
    - "AgentFSM unit tests cover init state, task assignment, acceptance, completion, failure, ws_pid DOWN, and state transitions"
    - "Scheduler unit tests cover idle agent matching, capability filtering, PubSub event reactions, and empty queue handling"
  artifacts:
    - path: "test/agent_com/task_queue_test.exs"
      provides: "TaskQueue GenServer unit tests"
      contains: "AgentCom.TaskQueueTest"
    - path: "test/agent_com/agent_fsm_test.exs"
      provides: "AgentFSM state machine unit tests"
      contains: "AgentCom.AgentFSMTest"
    - path: "test/agent_com/scheduler_test.exs"
      provides: "Scheduler GenServer unit tests"
      contains: "AgentCom.SchedulerTest"
  key_links:
    - from: "test/agent_com/task_queue_test.exs"
      to: "test/support/dets_helpers.ex"
      via: "setup block calls full_test_setup"
      pattern: "DetsHelpers\\.full_test_setup"
    - from: "test/agent_com/scheduler_test.exs"
      to: "test/support/test_factory.ex"
      via: "creates agents via factory for scheduler matching"
      pattern: "TestFactory\\.create_agent"
---

<objective>
Write deep unit tests for the three most critical GenServer modules: TaskQueue, AgentFSM, and Scheduler. These are the core of the task pipeline -- if they break, the entire system fails.

Purpose: These modules handle task lifecycle, agent state, and work assignment. Deep coverage here catches regressions in the most important code paths. Satisfies TEST-01 (critical path coverage) from requirements.

Output: 3 comprehensive test files covering init, key handlers, edge cases, and error paths
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-testing/09-RESEARCH.md
@.planning/phases/09-testing/09-01-SUMMARY.md

@lib/agent_com/task_queue.ex
@lib/agent_com/agent_fsm.ex
@lib/agent_com/scheduler.ex
@lib/agent_com/agent_supervisor.ex
@test/support/dets_helpers.ex
@test/support/test_factory.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write TaskQueue deep unit tests</name>
  <files>test/agent_com/task_queue_test.exs</files>
  <action>
Create `test/agent_com/task_queue_test.exs` with `use ExUnit.Case, async: false`.

Setup block pattern (use for ALL unit tests in this phase):
```elixir
setup do
  # Stop Scheduler to prevent it from reacting to task events during unit tests
  Supervisor.terminate_child(AgentCom.Supervisor, AgentCom.Scheduler)

  tmp_dir = AgentCom.TestHelpers.DetsHelpers.full_test_setup()

  on_exit(fn ->
    Supervisor.restart_child(AgentCom.Supervisor, AgentCom.Scheduler)
    AgentCom.TestHelpers.DetsHelpers.full_test_teardown(tmp_dir)
  end)

  %{tmp_dir: tmp_dir}
end
```

CRITICAL: Stop the Scheduler in setup for TaskQueue tests. The Scheduler subscribes to PubSub and auto-reacts to :task_submitted events. Without stopping it, submitting a task in a test will trigger the Scheduler to assign it, changing task status from :queued to :assigned unexpectedly. This is Pitfall #3 from research.

Test cases (deep coverage):

**Submit:**
- submit/1 creates a task with :queued status and default priority 2 ("normal")
- submit/1 with "high" priority sets priority to 1
- submit/1 with "low" priority sets priority to 3
- submit/1 generates a unique task_id matching pattern `task-[a-f0-9]+`
- submit/1 stores submitted_by, description, max_retries, needed_capabilities

**Get:**
- get/1 returns {:ok, task} for existing task
- get/1 returns {:error, :not_found} for nonexistent task_id

**Assign:**
- assign_task/2 transitions :queued -> :assigned with assigned_to and generation=1
- assign_task/2 on already-assigned task returns error (or re-assigns per actual behavior -- check source)

**Complete:**
- complete_task/3 with correct generation transitions :assigned -> :completed
- complete_task/3 with wrong generation returns {:error, :stale_generation}
- complete_task/3 stores result data

**Fail:**
- fail_task/3 with retries remaining transitions to :queued (re-queued for retry) with incremented retry_count
- fail_task/3 with retries exhausted moves task to dead-letter

**List:**
- list/0 or list_queued/0 returns submitted tasks
- Dead-lettered tasks appear in dead letter list (if API exists)

**Sweep:**
- Send `:sweep_overdue` message directly to TaskQueue pid to test the sweep timer handler. Assigned tasks past their timeout should be re-queued or failed.
- Use `send(GenServer.whereis(AgentCom.TaskQueue), :sweep_overdue)` instead of waiting for the real timer.

**Edge cases:**
- Submit with minimal params (only description)
- Submit with all optional params

Read `lib/agent_com/task_queue.ex` carefully to discover the exact public API, return values, and internal message names before writing tests. Match tests to actual API, not assumed API.
  </action>
  <verify>
Run `MIX_ENV=test mix test test/agent_com/task_queue_test.exs --trace` -- all tests pass.
Verify test count is >= 12 tests covering the categories listed.
  </verify>
  <done>
TaskQueue unit tests pass covering: submit (status, priority, id format, fields), get (found/not-found), assign (state transition, generation), complete (correct/wrong generation, result storage), fail (retry, dead-letter), sweep_overdue, and edge cases.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write AgentFSM and Scheduler deep unit tests</name>
  <files>
    test/agent_com/agent_fsm_test.exs
    test/agent_com/scheduler_test.exs
  </files>
  <action>
**AgentFSM tests** -- `test/agent_com/agent_fsm_test.exs`:

Setup: Use DetsHelpers.full_test_setup(). Stop Scheduler to isolate FSM tests.

IMPORTANT: AgentFSM requires a ws_pid (it monitors this process). Always spawn a dummy process: `ws_pid = spawn(fn -> Process.sleep(:infinity) end)`. Always kill ws_pid in on_exit to prevent registry leaks (Pitfall #2 from research).

Test cases:
- **Init:** FSM starts in :idle state with correct capabilities
- **Get state:** `AgentFSM.get_state(agent_id)` returns current state struct with fsm_state, capabilities, agent_id
- **Task assignment:** Sending task_assign transitions idle -> assigned (or whatever the actual state name is -- read source)
- **Task acceptance:** task_accepted transitions appropriately
- **Task completion:** task_complete transitions to idle
- **Task failure:** task_failed transitions appropriately
- **WS disconnect:** Killing ws_pid triggers :DOWN handler, FSM cleans up
- **Acceptance timeout:** Send `{:acceptance_timeout, task_id}` directly to FSM pid to test timeout without waiting 60s (Pitfall #4 from research)
- **State queries:** Verify state is queryable at each transition point

Read `lib/agent_com/agent_fsm.ex` to understand exact state names (they may be atoms like :idle, :assigned, :working), message formats, and public API. The FSM uses `:gen_statem` or GenServer -- check which one.

Always create agents via `AgentCom.AgentSupervisor.start_agent/1` (not direct FSM start_link) to ensure proper Registry registration.

Cleanup pattern:
```elixir
on_exit(fn ->
  # Kill dummy ws_pids to trigger FSM cleanup
  if Process.alive?(ws_pid), do: Process.exit(ws_pid, :kill)
  Process.sleep(100) # Allow FSM to process :DOWN
  ...
end)
```

**Scheduler tests** -- `test/agent_com/scheduler_test.exs`:

Setup: Use DetsHelpers.full_test_setup(). The Scheduler SHOULD be running for these tests (unlike TaskQueue tests where we stop it). But be careful: restart it fresh so it has clean state.

Test cases:
- **Matching:** Submit a task, have an idle agent registered -> Scheduler assigns the task to the agent. Verify via PubSub subscription or by polling task status.
- **Capability filtering:** Submit task with needed_capabilities=["code"], register agent with capabilities=["code"] -> assigned. Register agent without "code" capability -> not assigned.
- **No idle agents:** Submit task with no agents registered -> task stays :queued
- **Empty queue:** Register agent with no tasks -> nothing happens
- **Multiple agents:** Submit task, have 2 idle agents -> task assigned to one of them
- **PubSub reaction:** Subscribe to "tasks" topic, submit task, verify Scheduler broadcasts task_assigned event

Use TestFactory.create_agent/1 to set up agents. Use TestFactory.submit_task/1 to create tasks. Use `assert_receive` with 5000ms timeout on PubSub events for synchronization (Pitfall #7: subscribe BEFORE triggering action).

Pattern:
```elixir
Phoenix.PubSub.subscribe(AgentCom.PubSub, "tasks")
{:ok, task} = AgentCom.TestFactory.submit_task(description: "scheduler test")
assert_receive {:task_event, %{event: :task_assigned}}, 5_000
```

Check the actual PubSub message format by reading scheduler.ex -- the pattern above is from research but the actual format may differ.
  </action>
  <verify>
Run `MIX_ENV=test mix test test/agent_com/agent_fsm_test.exs --trace` -- all tests pass.
Run `MIX_ENV=test mix test test/agent_com/scheduler_test.exs --trace` -- all tests pass.
Verify AgentFSM tests >= 7 tests. Scheduler tests >= 5 tests.
  </verify>
  <done>
AgentFSM unit tests pass covering: init state, get_state, task assignment, acceptance, completion, failure, ws_pid DOWN cleanup, and acceptance timeout.
Scheduler unit tests pass covering: idle agent matching, capability filtering, no-idle-agents handling, empty-queue handling, and PubSub event verification.
  </done>
</task>

</tasks>

<verification>
1. `MIX_ENV=test mix test test/agent_com/task_queue_test.exs` -- all pass
2. `MIX_ENV=test mix test test/agent_com/agent_fsm_test.exs` -- all pass
3. `MIX_ENV=test mix test test/agent_com/scheduler_test.exs` -- all pass
4. Tests use DETS isolation (no production data touched)
5. Tests use Scheduler stop/start pattern where needed
6. No Process.sleep for synchronization (use assert_receive or wait_for)
</verification>

<success_criteria>
- TaskQueue has >= 12 unit tests covering submit, get, assign, complete, fail, sweep, edge cases
- AgentFSM has >= 7 unit tests covering full state machine lifecycle
- Scheduler has >= 5 unit tests covering matching, capability filtering, PubSub reactions
- All tests pass with `mix test` and use DETS isolation
- Scheduler interference correctly handled (stopped in TaskQueue/FSM tests, running in Scheduler tests)
</success_criteria>

<output>
After completion, create `.planning/phases/09-testing/09-02-SUMMARY.md`
</output>
