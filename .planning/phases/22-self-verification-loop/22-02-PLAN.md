---
phase: 22-self-verification-loop
plan: 02
type: execute
wave: 2
depends_on: ["22-01"]
files_modified:
  - sidecar/index.js
  - lib/agent_com/validation/schemas.ex
  - lib/agent_com/task_queue.ex
  - lib/agent_com/socket.ex
autonomous: true

must_haves:
  truths:
    - "executeTask calls executeWithVerification instead of dispatch, producing a result with verification_report and verification_history"
    - "sendTaskComplete passes verification_history as a top-level WS field alongside verification_report"
    - "Task submit schema accepts optional max_verification_retries integer field"
    - "Task struct stores max_verification_retries and passes it through task_assign to sidecar"
    - "complete_task persists each report in verification_history to Verification.Store with correct run_number"
    - "handleTaskAssign in sidecar reads max_verification_retries from task_assign message"
  artifacts:
    - path: "sidecar/index.js"
      provides: "Verification loop integration in executeTask and sendTaskComplete"
      contains: "executeWithVerification"
    - path: "lib/agent_com/validation/schemas.ex"
      provides: "max_verification_retries in post_task schema"
      contains: "max_verification_retries"
    - path: "lib/agent_com/task_queue.ex"
      provides: "max_verification_retries in task struct, verification_history persistence in complete_task"
      contains: "max_verification_retries"
    - path: "lib/agent_com/socket.ex"
      provides: "max_verification_retries forwarded in task_assign WS message"
      contains: "max_verification_retries"
  key_links:
    - from: "sidecar/index.js"
      to: "sidecar/lib/execution/verification-loop.js"
      via: "require in executeTask"
      pattern: "executeWithVerification"
    - from: "lib/agent_com/socket.ex"
      to: "lib/agent_com/task_queue.ex"
      via: "task struct field forwarded in task_assign"
      pattern: "max_verification_retries"
    - from: "lib/agent_com/task_queue.ex"
      to: "lib/agent_com/verification/store.ex"
      via: "Store.save called for each report in verification_history"
      pattern: "verification_history"
---

<objective>
Wire the verification loop into the sidecar execution path and extend the hub pipeline to accept, store, and forward verification retry configuration and history.

Purpose: Connect the verification-loop.js module (Plan 01) into the live execution flow. The sidecar's executeTask() calls executeWithVerification instead of dispatch directly. The hub accepts max_verification_retries on task submission, stores it in the task struct, forwards it to the sidecar in task_assign, and persists per-iteration verification reports on task completion.

Output: End-to-end pipeline for self-verification -- from task submission with retry config, through sidecar execution with retry loop, to hub persistence of multi-run verification history.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-self-verification-loop/22-RESEARCH.md
@.planning/phases/22-self-verification-loop/22-01-SUMMARY.md

@sidecar/index.js
@lib/agent_com/validation/schemas.ex
@lib/agent_com/task_queue.ex
@lib/agent_com/socket.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire verification loop into sidecar executeTask and sendTaskComplete</name>
  <files>sidecar/index.js</files>
  <action>
**In executeTask() method (around line 633):**

1. Replace `const { dispatch } = require('./lib/execution/dispatcher');` with `const { executeWithVerification } = require('./lib/execution/verification-loop');`.
2. Replace the `dispatch(task, _config, ...)` call with `executeWithVerification(task, _config, (event) => emitter.emit(event))`.
3. Update the sendTaskComplete call to pass through the verification fields from the result. The result from executeWithVerification already includes `verification_report`, `verification_history`, `verification_status`, and `verification_attempts`. Pass all of these in the result object sent to sendTaskComplete:
   ```javascript
   this.sendTaskComplete(task.task_id, {
     status: result.status,
     output: result.output,
     model_used: result.model_used,
     tokens_in: result.tokens_in,
     tokens_out: result.tokens_out,
     estimated_cost_usd: result.estimated_cost_usd,
     equivalent_claude_cost_usd: result.equivalent_claude_cost_usd,
     execution_ms: result.execution_ms,
     verification_report: result.verification_report,
     verification_history: result.verification_history,
     verification_status: result.verification_status,
     verification_attempts: result.verification_attempts
   });
   ```

**In handleTaskAssign() method (around line 564):**

4. Add `max_verification_retries` to the task object construction, reading from the task_assign message:
   ```javascript
   max_verification_retries: msg.max_verification_retries || 0
   ```
   Add this after the `routing_decision` line.

**In sendTaskComplete() method (around line 517):**

5. Extract `verification_history` as a top-level WS field (same pattern as verification_report):
   ```javascript
   const verificationHistory = result.verification_history;
   delete cleanResult.verification_history;
   ```
6. Add `verification_history: verificationHistory || null` to the sent message object alongside the existing `verification_report` field.
  </action>
  <verify>
    `node -e "require('./sidecar/index')"` -- sidecar starts without syntax errors (will fail to connect to hub, but no require/parse errors). Grep for `executeWithVerification` in index.js shows usage. Grep for `dispatch` in executeTask should NOT appear (replaced).
  </verify>
  <done>
    executeTask uses executeWithVerification instead of dispatch. sendTaskComplete forwards verification_history. handleTaskAssign reads max_verification_retries.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend hub schema, task struct, task_assign, and complete_task for verification retries</name>
  <files>
    lib/agent_com/validation/schemas.ex
    lib/agent_com/task_queue.ex
    lib/agent_com/socket.ex
  </files>
  <action>
**In schemas.ex -- post_task optional fields (around line 286):**

1. Add `"max_verification_retries" => :integer` to the optional map, after `"complexity_tier"`. Also add `"skip_verification" => :boolean` and `"verification_timeout_ms" => :integer` if not already present (they were added in Phase 21 for the sidecar but may not be in the submit schema yet -- check and add only if missing).

**In task_queue.ex -- task struct initialization (around line 248-251):**

2. Add `max_verification_retries` field to the task map, after `verification_report: nil`:
   ```elixir
   max_verification_retries:
     Map.get(params, :max_verification_retries,
       Map.get(params, "max_verification_retries", 0)),
   ```
   Cap value at 5: wrap in `min(value, 5)` to enforce the hard cap from research recommendations.

**In task_queue.ex -- complete_task handler (around line 410-449):**

3. After the existing `verification_report` handling block, add verification_history persistence:
   ```elixir
   # Persist verification history (Phase 22: multi-run reports)
   verification_history = Map.get(result_params, :verification_history,
     Map.get(result_params, "verification_history", []))

   if is_list(verification_history) and length(verification_history) > 0 do
     for report <- verification_history do
       AgentCom.Verification.Store.save(task_id, report)
     end
   end
   ```
   Place this AFTER the existing single-report save (so the single report save still works as fallback for legacy callers). Guard the loop: only iterate if verification_history is a non-empty list.

4. Store `verification_history` on the task map in the `updated` variable, adding it to the completed task struct:
   ```elixir
   verification_history: verification_history,
   ```

**In socket.ex -- push_task handler (around line 186):**

5. Add `max_verification_retries` to the task_assign message map:
   ```elixir
   "max_verification_retries" => task["max_verification_retries"] || task[:max_verification_retries] || 0,
   ```
   Also add `"skip_verification"` and `"verification_timeout_ms"` if not already forwarded (check existing code -- they may already be present from Phase 21).
  </action>
  <verify>
    `cd C:/Users/nrosq/src/AgentCom && mix compile --warnings-as-errors` compiles without errors. Grep for `max_verification_retries` in schemas.ex, task_queue.ex, and socket.ex each returns matches.
  </verify>
  <done>
    Hub pipeline supports max_verification_retries end-to-end: submit schema validates it, task struct stores it (capped at 5), task_assign forwards it to sidecar, complete_task persists verification_history reports.
  </done>
</task>

</tasks>

<verification>
- `mix compile --warnings-as-errors` passes
- Grep for `executeWithVerification` in sidecar/index.js returns matches
- Grep for `max_verification_retries` in schemas.ex, task_queue.ex, socket.ex returns matches
- Grep for `verification_history` in task_queue.ex and index.js returns matches
</verification>

<success_criteria>
- Sidecar executeTask uses verification loop instead of direct dispatch
- sendTaskComplete forwards verification_history to hub
- Hub submit schema accepts max_verification_retries
- Task struct stores max_verification_retries (capped at 5)
- task_assign WS message includes max_verification_retries
- complete_task persists all verification_history reports to Store
</success_criteria>

<output>
After completion, create `.planning/phases/22-self-verification-loop/22-02-SUMMARY.md`
</output>
