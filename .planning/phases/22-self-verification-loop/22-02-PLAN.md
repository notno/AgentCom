---
phase: 22-self-verification-loop
plan: 02
type: execute
wave: 2
depends_on: ["22-01"]
files_modified:
  - sidecar/index.js
  - lib/agent_com/validation/schemas.ex
  - lib/agent_com/task_queue.ex
  - lib/agent_com/socket.ex
  - sidecar/test/verification-loop-integration.js
autonomous: true

must_haves:
  truths:
    - "executeTask calls executeWithVerification instead of dispatch, producing a result with verification_report and verification_history"
    - "sendTaskComplete passes verification_history as a top-level WS field alongside verification_report"
    - "Task submit schema accepts optional max_verification_retries integer field"
    - "Task struct stores max_verification_retries and passes it through task_assign to sidecar"
    - "complete_task persists each report in verification_history to Verification.Store with correct run_number"
    - "handleTaskAssign in sidecar reads max_verification_retries from task_assign message"
    - "When verification fails on first attempt, a corrective prompt is constructed and the task is re-dispatched, producing a multi-iteration verification history"
  artifacts:
    - path: "sidecar/index.js"
      provides: "Verification loop integration in executeTask and sendTaskComplete"
      contains: "executeWithVerification"
    - path: "lib/agent_com/validation/schemas.ex"
      provides: "max_verification_retries in post_task schema"
      contains: "max_verification_retries"
    - path: "lib/agent_com/task_queue.ex"
      provides: "max_verification_retries in task struct, verification_history persistence in complete_task"
      contains: "max_verification_retries"
    - path: "lib/agent_com/socket.ex"
      provides: "max_verification_retries forwarded in task_assign WS message"
      contains: "max_verification_retries"
  key_links:
    - from: "sidecar/index.js"
      to: "sidecar/lib/execution/verification-loop.js"
      via: "require in executeTask"
      pattern: "executeWithVerification"
    - from: "lib/agent_com/socket.ex"
      to: "lib/agent_com/task_queue.ex"
      via: "task struct field forwarded in task_assign"
      pattern: "max_verification_retries"
    - from: "lib/agent_com/task_queue.ex"
      to: "lib/agent_com/verification/store.ex"
      via: "Store.save called for each report in verification_history"
      pattern: "verification_history"
---

<objective>
Wire the verification loop into the sidecar execution path and extend the hub pipeline to accept, store, and forward verification retry configuration and history.

Purpose: Connect the verification-loop.js module (Plan 01) into the live execution flow. The sidecar's executeTask() calls executeWithVerification instead of dispatch directly. The hub accepts max_verification_retries on task submission, stores it in the task struct, forwards it to the sidecar in task_assign, and persists per-iteration verification reports on task completion.

Output: End-to-end pipeline for self-verification -- from task submission with retry config, through sidecar execution with retry loop, to hub persistence of multi-run verification history.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-self-verification-loop/22-RESEARCH.md
@.planning/phases/22-self-verification-loop/22-01-SUMMARY.md

@sidecar/index.js
@lib/agent_com/validation/schemas.ex
@lib/agent_com/task_queue.ex
@lib/agent_com/socket.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire verification loop into sidecar executeTask and sendTaskComplete</name>
  <files>sidecar/index.js</files>
  <action>
**In executeTask() method (around line 633):**

1. Replace `const { dispatch } = require('./lib/execution/dispatcher');` with `const { executeWithVerification } = require('./lib/execution/verification-loop');`.
2. Replace the `dispatch(task, _config, ...)` call with `executeWithVerification(task, _config, (event) => emitter.emit(event))`.
3. Update the sendTaskComplete call to pass through the verification fields from the result. The result from executeWithVerification already includes `verification_report`, `verification_history`, `verification_status`, and `verification_attempts`. Pass all of these in the result object sent to sendTaskComplete:
   ```javascript
   this.sendTaskComplete(task.task_id, {
     status: result.status,
     output: result.output,
     model_used: result.model_used,
     tokens_in: result.tokens_in,
     tokens_out: result.tokens_out,
     estimated_cost_usd: result.estimated_cost_usd,
     equivalent_claude_cost_usd: result.equivalent_claude_cost_usd,
     execution_ms: result.execution_ms,
     verification_report: result.verification_report,
     verification_history: result.verification_history,
     verification_status: result.verification_status,
     verification_attempts: result.verification_attempts
   });
   ```

**In handleTaskAssign() method (around line 564):**

4. Add `max_verification_retries` to the task object construction, reading from the task_assign message:
   ```javascript
   max_verification_retries: msg.max_verification_retries || 0
   ```
   Add this after the `routing_decision` line.

**In sendTaskComplete() method (around line 517):**

5. Extract `verification_history` as a top-level WS field (same pattern as verification_report):
   ```javascript
   const verificationHistory = result.verification_history;
   delete cleanResult.verification_history;
   ```
6. Add `verification_history: verificationHistory || null` to the sent message object alongside the existing `verification_report` field.
  </action>
  <verify>
    `node -e "require('./sidecar/index')"` -- sidecar starts without syntax errors (will fail to connect to hub, but no require/parse errors). Grep for `executeWithVerification` in index.js shows usage. Grep for `dispatch` in executeTask should NOT appear (replaced).
  </verify>
  <done>
    executeTask uses executeWithVerification instead of dispatch. sendTaskComplete forwards verification_history. handleTaskAssign reads max_verification_retries.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend hub schema, task struct, task_assign, and complete_task for verification retries</name>
  <files>
    lib/agent_com/validation/schemas.ex
    lib/agent_com/task_queue.ex
    lib/agent_com/socket.ex
  </files>
  <action>
**In schemas.ex -- post_task optional fields (around line 286):**

1. Add `"max_verification_retries" => :integer` to the optional map, after `"complexity_tier"`. Also add `"skip_verification" => :boolean` and `"verification_timeout_ms" => :integer` if not already present (they were added in Phase 21 for the sidecar but may not be in the submit schema yet -- check and add only if missing).

**In task_queue.ex -- task struct initialization (around line 248-251):**

2. Add `max_verification_retries` field to the task map, after `verification_report: nil`:
   ```elixir
   max_verification_retries:
     Map.get(params, :max_verification_retries,
       Map.get(params, "max_verification_retries", 0)),
   ```
   Cap value at 5: wrap in `min(value, 5)` to enforce the hard cap from research recommendations.

**In task_queue.ex -- complete_task handler (around line 410-449):**

3. After the existing `verification_report` handling block, add verification_history persistence:
   ```elixir
   # Persist verification history (Phase 22: multi-run reports)
   verification_history = Map.get(result_params, :verification_history,
     Map.get(result_params, "verification_history", []))

   if is_list(verification_history) and length(verification_history) > 0 do
     for report <- verification_history do
       AgentCom.Verification.Store.save(task_id, report)
     end
   end
   ```
   Place this AFTER the existing single-report save (so the single report save still works as fallback for legacy callers). Guard the loop: only iterate if verification_history is a non-empty list.

4. Store `verification_history` on the task map in the `updated` variable, adding it to the completed task struct:
   ```elixir
   verification_history: verification_history,
   ```

**In socket.ex -- push_task handler (around line 186):**

5. Add `max_verification_retries` to the task_assign message map:
   ```elixir
   "max_verification_retries" => task["max_verification_retries"] || task[:max_verification_retries] || 0,
   ```
   Also add `"skip_verification"` and `"verification_timeout_ms"` if not already forwarded (check existing code -- they may already be present from Phase 21).
  </action>
  <verify>
    `cd C:/Users/nrosq/src/AgentCom && mix compile --warnings-as-errors` compiles without errors. Grep for `max_verification_retries` in schemas.ex, task_queue.ex, and socket.ex each returns matches.
  </verify>
  <done>
    Hub pipeline supports max_verification_retries end-to-end: submit schema validates it, task struct stores it (capped at 5), task_assign forwards it to sidecar, complete_task persists verification_history reports.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify verification retry loop end-to-end</name>
  <files>sidecar/test/verification-loop-integration.js</files>
  <action>
Create `sidecar/test/verification-loop-integration.js` -- an integration test script that exercises the complete failure->corrective-prompt->retry flow through `executeWithVerification`.

**Strategy:** Use Node.js module stubbing to replace `dispatcher.dispatch` and `verification.runVerification` with controlled fakes, then call `executeWithVerification` and assert the full loop behavior. This avoids requiring a live hub or LLM, while proving the real loop module orchestrates the retry flow correctly.

**Implementation:**

1. **Setup stubs:** Use `require` to load `verification-loop.js`, then monkey-patch the dispatcher and verification modules in the require cache:
   ```javascript
   const Module = require('module');
   const path = require('path');

   // Load the real verification-loop module
   const loopPath = path.resolve(__dirname, '../lib/execution/verification-loop.js');

   // Clear require cache to ensure fresh load
   delete require.cache[loopPath];

   // Stub dispatcher.dispatch -- track calls, return success
   const dispatcherPath = path.resolve(__dirname, '../lib/execution/dispatcher.js');
   const dispatchCalls = [];
   require.cache[dispatcherPath] = {
     id: dispatcherPath, filename: dispatcherPath, loaded: true,
     exports: {
       dispatch: async (task, config, onProgress) => {
         dispatchCalls.push({ task, config });
         return { status: 'success', output: 'mock output', tokens_in: 100, tokens_out: 50, estimated_cost_usd: 0.01 };
       }
     }
   };

   // Stub verification -- fail on run 1, pass on run 2
   const verificationPath = path.resolve(__dirname, '../verification.js');
   let verifyCallCount = 0;
   require.cache[verificationPath] = {
     id: verificationPath, filename: verificationPath, loaded: true,
     exports: {
       runVerification: async (task, config, runNumber) => {
         verifyCallCount++;
         if (verifyCallCount === 1) {
           return {
             status: 'fail', run_number: runNumber,
             summary: { total: 2, passed: 1, failed: 1 },
             checks: [
               { type: 'command', target: 'npm test', status: 'pass', output: 'ok' },
               { type: 'command', target: 'npm run lint', status: 'fail', output: 'Error: unused var' }
             ]
           };
         }
         return {
           status: 'pass', run_number: runNumber,
           summary: { total: 2, passed: 2, failed: 0 },
           checks: [
             { type: 'command', target: 'npm test', status: 'pass', output: 'ok' },
             { type: 'command', target: 'npm run lint', status: 'pass', output: 'ok' }
           ]
         };
       }
     }
   };

   // Stub log module to suppress output
   const logPath = path.resolve(__dirname, '../lib/log.js');
   const noop = () => {};
   require.cache[logPath] = {
     id: logPath, filename: logPath, loaded: true,
     exports: Object.assign(noop, { info: noop, warn: noop, error: noop, debug: noop, verbose: noop })
   };
   ```

2. **Load and execute the loop:**
   ```javascript
   const { executeWithVerification } = require(loopPath);

   const task = {
     task_id: 'test-retry-001',
     description: 'Fix the lint errors',
     max_verification_retries: 2,
     routing_decision: { target_type: 'claude' },
     verification_checks: [
       { type: 'command', target: 'npm test' },
       { type: 'command', target: 'npm run lint' }
     ]
   };
   const config = { working_dir: '/tmp/test' };
   const progressEvents = [];

   const result = await executeWithVerification(task, config, (event) => progressEvents.push(event));
   ```

3. **Assert end-to-end behavior (7 assertions):**
   ```javascript
   let failures = 0;
   function assert(condition, msg) {
     if (!condition) { console.error('FAIL:', msg); failures++; }
     else { console.log('PASS:', msg); }
   }

   // A1: dispatch was called twice (initial + retry)
   assert(dispatchCalls.length === 2, 'dispatch called twice (initial + corrective retry)');

   // A2: second dispatch received corrective prompt, not original description
   assert(dispatchCalls[1].task.description.includes('VERIFICATION RETRY'),
     'retry task contains corrective prompt with VERIFICATION RETRY header');

   // A3: corrective prompt includes the failed check details
   assert(dispatchCalls[1].task.description.includes('npm run lint'),
     'corrective prompt references the specific failed check (npm run lint)');

   // A4: corrective prompt preserves original task description
   assert(dispatchCalls[1].task.description.includes('Fix the lint errors'),
     'corrective prompt includes original task description');

   // A5: result has verified status (second attempt passed)
   assert(result.verification_status === 'verified',
     'final status is verified after successful retry');

   // A6: verification history contains 2 reports
   assert(result.verification_history && result.verification_history.length === 2,
     'verification_history contains 2 reports (fail then pass)');

   // A7: cumulative cost tracked across both iterations
   assert(result.estimated_cost_usd > 0.01,
     'cumulative cost reflects both iterations (> single-iteration cost)');

   if (failures > 0) { console.error(`\n${failures} assertion(s) FAILED`); process.exit(1); }
   else { console.log('\nAll assertions passed -- verification retry loop works end-to-end'); }
   ```

4. **Wrap in async IIFE** since `executeWithVerification` is async:
   ```javascript
   (async () => { /* all the above */ })().catch(err => { console.error('Test error:', err); process.exit(1); });
   ```

**What this proves:** The real `executeWithVerification` module (not a mock) receives a failing verification report, constructs a corrective prompt containing failure details and original task context, re-dispatches to the executor, and produces a multi-iteration verification history with correct status. This is the complete failure->corrective-prompt->retry->pass flow from Success Criterion 1.
  </action>
  <verify>
    `node sidecar/test/verification-loop-integration.js` exits 0 and prints "All assertions passed". All 7 assertions pass.
  </verify>
  <done>
    Integration test proves the complete verification retry loop: verification failure on first attempt triggers corrective prompt construction (with failed check details + original task), re-dispatch occurs, second attempt passes verification, and the result contains multi-iteration history with cumulative cost. Success Criterion 1 is verified end-to-end.
  </done>
</task>

</tasks>

<verification>
- `mix compile --warnings-as-errors` passes
- Grep for `executeWithVerification` in sidecar/index.js returns matches
- Grep for `max_verification_retries` in schemas.ex, task_queue.ex, socket.ex returns matches
- Grep for `verification_history` in task_queue.ex and index.js returns matches
- `node sidecar/test/verification-loop-integration.js` exits 0 with all assertions passing
</verification>

<success_criteria>
- Sidecar executeTask uses verification loop instead of direct dispatch
- sendTaskComplete forwards verification_history to hub
- Hub submit schema accepts max_verification_retries
- Task struct stores max_verification_retries (capped at 5)
- task_assign WS message includes max_verification_retries
- complete_task persists all verification_history reports to Store
- Integration test proves failure->corrective-prompt->retry->pass flow works end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/22-self-verification-loop/22-02-SUMMARY.md`
</output>
