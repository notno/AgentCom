---
phase: 01-sidecar
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/agent_com/socket.ex
  - lib/agent_com/endpoint.ex

autonomous: true

must_haves:
  truths:
    - "Hub accepts sidecar task lifecycle messages (task_accepted, task_progress, task_complete, task_failed, task_recovering) without error"
    - "Hub can push a task_assign message to a connected agent via WebSocket"
    - "Admin can send a test task to a specific connected agent via HTTP API"
    - "Unknown sidecar message fields (client_type, protocol_version) do not cause errors"
  artifacts:
    - path: "lib/agent_com/socket.ex"
      provides: "WebSocket handler with sidecar message type support and task push capability"
      contains: "task_assign"
    - path: "lib/agent_com/endpoint.ex"
      provides: "HTTP endpoint with admin push-task API"
      contains: "push-task"
  key_links:
    - from: "lib/agent_com/endpoint.ex"
      to: "lib/agent_com/socket.ex"
      via: "Registry lookup + send to WebSocket process"
      pattern: "Registry.lookup.*AgentRegistry"
    - from: "lib/agent_com/socket.ex"
      to: "connected sidecar"
      via: "WebSocket push of task_assign message"
      pattern: "task_assign"
---

<objective>
Extend the hub's WebSocket protocol and HTTP API to support sidecar task lifecycle messages and provide an admin endpoint for pushing test tasks to connected agents.

Purpose: The sidecar needs the hub to understand its message types (task_accepted, task_complete, etc.) and the hub needs a way to push task assignments to agents. This is the minimal hub-side change needed for Phase 1 -- the full task queue system is Phase 2.

Output: Modified socket.ex with sidecar message handlers, modified endpoint.ex with admin push-task API.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-sidecar/01-CONTEXT.md
@.planning/phases/01-sidecar/01-RESEARCH.md
@lib/agent_com/socket.ex
@lib/agent_com/endpoint.ex
@lib/agent_com/presence.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sidecar message type handlers to Socket.ex</name>
  <files>lib/agent_com/socket.ex</files>
  <action>
Add new `handle_msg` clauses to `AgentCom.Socket` for sidecar task lifecycle messages. These messages are sent FROM the sidecar TO the hub to report task status.

**New message handlers (add before the catch-all `handle_msg(_unknown, state)`):**

1. `task_accepted` -- sidecar confirms it received and accepted a task:
```elixir
defp handle_msg(%{"type" => "task_accepted", "task_id" => task_id} = msg, state) do
  log_task_event(state.agent_id, "task_accepted", task_id, msg)
  reply = Jason.encode!(%{"type" => "task_ack", "task_id" => task_id, "status" => "accepted"})
  {:push, {:text, reply}, state}
end
```

2. `task_progress` -- sidecar reports progress on a task:
```elixir
defp handle_msg(%{"type" => "task_progress", "task_id" => task_id} = msg, state) do
  log_task_event(state.agent_id, "task_progress", task_id, msg)
  {:ok, state}
end
```

3. `task_complete` -- sidecar reports task finished successfully:
```elixir
defp handle_msg(%{"type" => "task_complete", "task_id" => task_id} = msg, state) do
  log_task_event(state.agent_id, "task_complete", task_id, msg)
  reply = Jason.encode!(%{"type" => "task_ack", "task_id" => task_id, "status" => "complete"})
  {:push, {:text, reply}, state}
end
```

4. `task_failed` -- sidecar reports task failed (after all retries):
```elixir
defp handle_msg(%{"type" => "task_failed", "task_id" => task_id} = msg, state) do
  log_task_event(state.agent_id, "task_failed", task_id, msg)
  reply = Jason.encode!(%{"type" => "task_ack", "task_id" => task_id, "status" => "failed"})
  {:push, {:text, reply}, state}
end
```

5. `task_recovering` -- sidecar reports it found an incomplete task on restart:
```elixir
defp handle_msg(%{"type" => "task_recovering", "task_id" => task_id} = msg, state) do
  log_task_event(state.agent_id, "task_recovering", task_id, msg)
  # For Phase 1: respond with task_reassign (hub takes task back)
  # Phase 2 will add intelligence about whether agent is still working
  reply = Jason.encode!(%{"type" => "task_reassign", "task_id" => task_id})
  {:push, {:text, reply}, state}
end
```

**Add helper function:**
```elixir
defp log_task_event(agent_id, event, task_id, msg) do
  require Logger
  Logger.info("Task event: #{event} from #{agent_id} for task #{task_id}")
  # Broadcast to PubSub for future dashboard/monitoring consumption
  Phoenix.PubSub.broadcast(AgentCom.PubSub, "tasks", {:task_event, %{
    agent_id: agent_id,
    event: event,
    task_id: task_id,
    payload: msg,
    timestamp: System.system_time(:millisecond)
  }})
end
```

**Add handle_info for task_assign push (receiving from endpoint):**
```elixir
def handle_info({:push_task, task}, state) do
  push = %{
    "type" => "task_assign",
    "task_id" => task["task_id"] || task[:task_id],
    "description" => task["description"] || task[:description] || "",
    "metadata" => task["metadata"] || task[:metadata] || %{},
    "assigned_at" => System.system_time(:millisecond)
  }
  {:push, {:text, Jason.encode!(push)}, state}
end
```

This pattern reuses the existing message push approach -- the endpoint looks up the agent's PID via Registry and sends a message, the Socket's handle_info pushes it over WebSocket.

**Important:** The existing identify handler already ignores unknown fields (client_type, protocol_version) because it only pattern-matches on known keys. No changes needed for backward compatibility.

Update the `@moduledoc` to document the new task protocol messages alongside the existing protocol docs.
  </action>
  <verify>
1. Run `mix compile` from the repo root -- should compile without errors or warnings
2. Verify the new handlers exist: `grep -n "task_accepted\|task_complete\|task_failed\|task_recovering\|push_task" lib/agent_com/socket.ex`
3. Start the hub with `mix run --no-halt` and connect a test WebSocket client. Send a task_accepted message and confirm a task_ack response is returned.
  </verify>
  <done>Socket.ex handles task_accepted, task_progress, task_complete, task_failed, and task_recovering messages from sidecars. Each message is logged, broadcast to PubSub "tasks" topic, and acknowledged. Socket.ex also handles {:push_task, task} info messages to push task_assign to connected agents via WebSocket.</done>
</task>

<task type="auto">
  <name>Task 2: Add admin push-task HTTP endpoint</name>
  <files>lib/agent_com/endpoint.ex</files>
  <action>
Add a new admin endpoint to `AgentCom.Endpoint` that pushes a test task to a connected agent via WebSocket. This enables testing the full sidecar flow without the Phase 2 scheduler.

**Add before the catch-all `match _` route:**

```elixir
# --- Admin: Push task to agent (for testing, pre-scheduler) ---

post "/api/admin/push-task" do
  conn = AgentCom.Plugs.RequireAuth.call(conn, [])
  if conn.halted do
    conn
  else
    admin_agent = conn.assigns[:authenticated_agent]

    case conn.body_params do
      %{"agent_id" => target_agent_id, "description" => description} = params ->
        task = %{
          "task_id" => "task-" <> Base.encode16(:crypto.strong_rand_bytes(8), case: :lower),
          "description" => description,
          "metadata" => params["metadata"] || %{},
          "submitted_by" => admin_agent,
          "submitted_at" => System.system_time(:millisecond)
        }

        case Registry.lookup(AgentCom.AgentRegistry, target_agent_id) do
          [{pid, _meta}] ->
            send(pid, {:push_task, task})
            send_json(conn, 200, %{
              "status" => "pushed",
              "task_id" => task["task_id"],
              "agent_id" => target_agent_id
            })
          [] ->
            send_json(conn, 404, %{
              "error" => "agent_not_connected",
              "agent_id" => target_agent_id
            })
        end

      _ ->
        send_json(conn, 400, %{
          "error" => "missing required fields: agent_id, description"
        })
    end
  end
end
```

**Key design decisions:**
- Task ID is auto-generated using crypto.strong_rand_bytes (consistent with existing token generation pattern in auth.ex)
- Requires authentication (any authenticated agent can push -- in Phase 2, the scheduler will handle this automatically)
- Returns 404 if target agent is not currently connected (sidecar must be online)
- The task payload includes task_id, description, metadata, submitted_by, and submitted_at -- matching what the sidecar expects

Update the `@moduledoc` to document the new endpoint:
```
- POST   /api/admin/push-task  --- Push a task to a connected agent (auth required)
```
  </action>
  <verify>
1. Run `mix compile` from the repo root -- should compile without errors
2. Start the hub: `mix run --no-halt`
3. Test the endpoint with curl (will return 404 since no agent connected, but validates the route works):
   ```
   curl -X POST http://localhost:4000/api/admin/push-task \
     -H "Content-Type: application/json" \
     -H "Authorization: Bearer <test-token>" \
     -d '{"agent_id": "test-agent", "description": "Test task"}'
   ```
   Expected: `{"error": "agent_not_connected", "agent_id": "test-agent"}` with 404 status
4. Test missing fields: send POST without description -- should return 400
  </verify>
  <done>POST /api/admin/push-task endpoint exists, requires auth, accepts agent_id + description + optional metadata, generates unique task_id, looks up agent via Registry, pushes task_assign via WebSocket if agent connected, returns 404 if agent offline. Endpoint documented in moduledoc.</done>
</task>

</tasks>

<verification>
- `mix compile` succeeds with no errors
- Socket.ex handles all 5 sidecar message types (task_accepted, task_progress, task_complete, task_failed, task_recovering)
- Socket.ex can push task_assign messages to connected agents via handle_info
- POST /api/admin/push-task creates and pushes tasks to connected agents
- Existing WebSocket protocol (identify, message, status, ping) continues to work unchanged
- Unknown fields in identify message (client_type, protocol_version) are silently ignored
</verification>

<success_criteria>
The hub accepts all sidecar task lifecycle messages and can push task assignments to connected agents. An admin can use the push-task endpoint to test the full sidecar flow. All existing functionality remains unchanged.
</success_criteria>

<output>
After completion, create `.planning/phases/01-sidecar/01-02-SUMMARY.md`
</output>
