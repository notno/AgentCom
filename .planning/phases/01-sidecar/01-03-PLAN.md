---
phase: 01-sidecar
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - sidecar/index.js

autonomous: true

must_haves:
  truths:
    - "Sidecar receives task_assign from hub and persists it to queue.json atomically"
    - "Sidecar rejects new tasks when an active task is already in progress"
    - "Sidecar sends task_accepted to hub after successfully persisting a task"
    - "Sidecar executes configurable wake command with full task payload"
    - "Wake command retries 3 times with 5s/15s/30s backoff on failure"
    - "Sidecar waits 30s for agent confirmation via .started file after wake"
    - "Sidecar watches results directory for task completion files"
    - "Sidecar sends task_complete or task_failed to hub based on result"
  artifacts:
    - path: "sidecar/index.js"
      provides: "Task handling: queue persistence, wake command, result watching"
      contains: "task_assign"
    - path: "sidecar/queue.json"
      provides: "Atomic task persistence file (runtime artifact, gitignored)"
      contains: "active"
  key_links:
    - from: "sidecar/index.js"
      to: "sidecar/queue.json"
      via: "write-file-atomic for crash-safe persistence"
      pattern: "writeFileAtomic"
    - from: "sidecar/index.js"
      to: "configurable wake command"
      via: "child_process.exec with template variable interpolation"
      pattern: "exec.*TASK_ID"
    - from: "sidecar/index.js"
      to: "sidecar/results/ directory"
      via: "chokidar file watcher for result files"
      pattern: "chokidar\\.watch"
---

<objective>
Add task lifecycle handling to the sidecar: receive task assignments from the hub, persist to queue.json atomically, execute the configurable wake command with retry logic, watch for agent results, and report completion back to the hub.

Purpose: This is the core task relay functionality -- the sidecar receives work from the hub, hands it to the agent, and reports back. Without this, the sidecar is just a connected client with no purpose.

Output: Modified sidecar/index.js with queue management, task handling, wake command execution, and result file watching.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-sidecar/01-CONTEXT.md
@.planning/phases/01-sidecar/01-RESEARCH.md
@.planning/phases/01-sidecar/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add queue manager and task_assign handler</name>
  <files>sidecar/index.js</files>
  <action>
Add queue management and task assignment handling to `sidecar/index.js`. This builds on the WebSocket connection from Plan 01.

**1. Queue Manager (add to index.js):**

```javascript
const writeFileAtomic = require('write-file-atomic');
const QUEUE_PATH = path.join(__dirname, 'queue.json');

// Queue data model (per CONTEXT.md: max 1 active + 1 recovering)
// { active: { task_id, description, metadata, status, assigned_at, wake_attempts }, recovering: null }

function loadQueue() {
  try {
    const data = fs.readFileSync(QUEUE_PATH, 'utf8');
    return JSON.parse(data);
  } catch (err) {
    if (err.code === 'ENOENT') return { active: null, recovering: null };
    // Corrupted file -- fall back to empty (per research pitfall #3)
    log('queue_corrupt', { error: err.message });
    return { active: null, recovering: null };
  }
}

function saveQueue(queue) {
  // Atomic write: write to temp file, then rename
  // Per CONTEXT.md locked decision: atomic writes to prevent corruption on crash
  writeFileAtomic.sync(QUEUE_PATH, JSON.stringify(queue, null, 2));
}
```

**2. Task assign handler (add to HubConnection.handleMessage):**

When `msg.type === "task_assign"`:
- Check if queue.active is not null. If busy:
  - Send `{ type: "task_rejected", task_id: msg.task_id, reason: "busy" }` to hub
  - Log rejection event
  - Per CONTEXT.md: "If agent is busy and new task arrives: reject back to hub (hub re-queues)"
  - Return early
- If idle (queue.active === null):
  - Create task object: `{ task_id: msg.task_id, description: msg.description, metadata: msg.metadata, status: "accepted", assigned_at: msg.assigned_at || Date.now(), wake_attempts: 0 }`
  - Set `queue.active = task`
  - Call `saveQueue(queue)` -- persist BEFORE acknowledging (crash-safe)
  - Send `{ type: "task_accepted", task_id: msg.task_id, protocol_version: 1 }` to hub
  - Log task_received event
  - Call `wakeAgent(task)` to start the agent (implemented in Task 2)

**3. Hub message senders (add to HubConnection class):**

Add methods for sending task lifecycle messages to hub:
- `sendTaskAccepted(taskId)` -- sends `{ type: "task_accepted", task_id, protocol_version: 1 }`
- `sendTaskComplete(taskId, result)` -- sends `{ type: "task_complete", task_id, result, protocol_version: 1 }`
- `sendTaskFailed(taskId, reason)` -- sends `{ type: "task_failed", task_id, reason, protocol_version: 1 }`
- `sendTaskRejected(taskId, reason)` -- sends `{ type: "task_rejected", task_id, reason, protocol_version: 1 }`

All use the existing `send()` method which checks readyState and adds protocol_version.

**4. Update graceful shutdown:**

On shutdown, save current queue state before closing WebSocket:
```javascript
saveQueue(queue);
```

**Important constraints per CONTEXT.md:**
- At most 1 active + 1 recovering task (recovering implemented in Plan 04)
- Reject when busy, do NOT locally queue
- Persist BEFORE acknowledging (crash between accept and persist loses the task)
- All sidecar-to-hub messages include task payload (not just IDs)
  </action>
  <verify>
1. Run `node sidecar/index.js` with a config pointing to the running hub
2. Send a task via the push-task endpoint: `curl -X POST http://localhost:4000/api/admin/push-task -H "Content-Type: application/json" -H "Authorization: Bearer <token>" -d '{"agent_id": "<sidecar-agent-id>", "description": "Test task"}'`
3. Check sidecar console/log: should show task_received event
4. Check sidecar/queue.json: should contain the task with status "accepted"
5. Send a second task while first is active: should see task_rejected in sidecar log and hub should receive rejection message
  </verify>
  <done>Sidecar receives task_assign messages from hub, persists to queue.json atomically using write-file-atomic, sends task_accepted confirmation, and rejects new tasks when busy. Queue state survives crashes.</done>
</task>

<task type="auto">
  <name>Task 2: Add wake command execution with retry and result file watching</name>
  <files>sidecar/index.js</files>
  <action>
Add wake command execution and result file watching to `sidecar/index.js`.

**1. Wake command execution:**

```javascript
const { exec } = require('child_process');

const RETRY_DELAYS = [5000, 15000, 30000]; // 5s, 15s, 30s per CONTEXT.md
```

Implement `async function wakeAgent(task)`:
- Update task status to "waking" and save queue
- Interpolate template variables in config.wake_command:
  - `${TASK_ID}` -> task.task_id
  - `${TASK_JSON}` -> JSON.stringify(task) with proper escaping for shell
  - `${TASK_DESCRIPTION}` -> task.description
- Execute using `child_process.exec(interpolatedCommand, { timeout: 60000, shell: true, windowsHide: true })`
  - `shell: true` is required for Windows .bat/.cmd files (per research pitfall #2)
  - `windowsHide: true` prevents cmd window popup on Windows
- On success (exit code 0):
  - Log wake_success event
  - Update task status to "waking_confirmation" and save queue
  - Start confirmation timeout (30s by default, configurable via config.confirmation_timeout_ms)
  - Wait for `.started` file in results dir (see result watching below)
- On failure:
  - Increment task.wake_attempts
  - If wake_attempts <= 3 (RETRY_DELAYS.length):
    - Log wake_retry event with attempt number and next delay
    - Wait RETRY_DELAYS[wake_attempts - 1] ms, then retry
  - If all 3 retries exhausted:
    - Log wake_failed event
    - Update task status to "failed" and save queue
    - Send task_failed to hub with reason "wake_failed_after_3_attempts"
    - Per CONTEXT.md: "If all 3 retries fail: report to hub, hub reassigns task to another agent"
    - Set queue.active = null and save queue

**2. Confirmation timeout:**

After successful wake (exit code 0), start a confirmation timer:
- Wait for `results/{task_id}.started` file to appear (empty file written by agent)
- If file appears within timeout: log confirmation_received, update status to "working"
- If timeout expires (default 30s): treat as failure, trigger retry logic (same as exec failure)
- Per CONTEXT.md: "Wake verification: check exit code immediately, then wait for confirmation callback from agent session within 30s timeout"

**3. Result file watching (chokidar):**

```javascript
const chokidar = require('chokidar');
```

Set up a file watcher on the results directory (config.results_dir, default `./results`):
- Create results directory if it doesn't exist: `fs.mkdirSync(resultsDir, { recursive: true })`
- Watch with chokidar: `chokidar.watch(resultsDir, { ignoreInitial: true, awaitWriteFinish: { stabilityThreshold: 500 } })`
- `awaitWriteFinish` prevents reading partially written files
- On new file detected:
  - If filename is `{task_id}.started`: handle as confirmation (see above)
  - If filename is `{task_id}.json`: handle as result
    - Read and parse the JSON file
    - Determine success/failure from result content (check for `status: "success"` vs `status: "failed"`)
    - Send task_complete or task_failed to hub with result data
    - Update queue: set active to null, save queue
    - Delete the result file after processing: `fs.unlinkSync(filePath)`
    - Delete the .started file if it exists
    - Log task_complete or task_failed event
  - Ignore files not matching current active task_id (stale files from previous runs)

**4. Update task status flow:**

The full task status progression in queue.json:
```
accepted -> waking -> waking_confirmation -> working -> (removed on complete/fail)
```

Each status change: update task.status, call saveQueue(queue), log the transition.

**Cross-platform considerations per research:**
- Use `{ shell: true }` with exec for Windows compatibility
- Use `path.join` for all file paths
- The wake_command in config.json is platform-specific (user sets it appropriately)
  </action>
  <verify>
1. Create a test wake command that simply exits 0 (e.g., set wake_command to `echo "waking ${TASK_ID}"` in config.json)
2. Push a task via the admin endpoint
3. Verify sidecar log shows: task_received -> wake_attempt -> wake_success
4. Create a `results/{task_id}.started` file manually -- verify sidecar detects it and logs confirmation_received
5. Create a `results/{task_id}.json` with `{"status": "success", "output": "done"}` -- verify sidecar:
   - Logs task_complete
   - Sends task_complete to hub
   - Clears queue.json (active becomes null)
   - Deletes the result file
6. Test wake failure: set wake_command to a non-existent command, push a task, verify 3 retry attempts at 5s/15s/30s intervals, then task_failed sent to hub
  </verify>
  <done>Sidecar executes configurable wake command with template variable interpolation (TASK_ID, TASK_JSON, TASK_DESCRIPTION). Failed wakes retry 3x at 5s/15s/30s. After successful wake, waits 30s for .started confirmation file. Watches results/ directory with chokidar for task completion files. Reports task_complete or task_failed to hub. Queue cleared after task finishes.</done>
</task>

</tasks>

<verification>
- Task pushed from hub arrives at sidecar and is persisted to queue.json
- Second task pushed while first is active is rejected back to hub
- Wake command executes with interpolated task variables
- Wake retries follow 5s/15s/30s schedule on failure
- Wake confirmation detected via .started file within timeout
- Task result detected via .json file in results/ directory
- task_complete/task_failed sent to hub on task finish
- queue.json cleared after task completes
- All lifecycle events logged to sidecar.log
</verification>

<success_criteria>
The sidecar can receive a task from the hub, persist it crash-safely, execute a wake command to start the agent, wait for confirmation, watch for results, and report completion back to the hub. The full task lifecycle is observable in sidecar.log and queue.json.
</success_criteria>

<output>
After completion, create `.planning/phases/01-sidecar/01-03-SUMMARY.md`
</output>
