---
phase: 31-hub-event-wiring
plan: 02
type: execute
wave: 2
depends_on: ["31-01"]
files_modified:
  - lib/agent_com/endpoint.ex
  - lib/agent_com/webhook_history.ex
autonomous: true

must_haves:
  truths:
    - "POST /api/webhooks/github receives push events and wakes FSM to :improving"
    - "POST /api/webhooks/github receives PR merge events and wakes FSM to :improving"
    - "Webhook signature verification rejects requests with invalid or missing signatures"
    - "Events on non-active repos are acknowledged but ignored"
    - "Webhook event history is stored in ETS and queryable via API"
    - "Webhook secret can be configured via PUT /api/config/webhook-secret"
  artifacts:
    - path: "lib/agent_com/endpoint.ex"
      provides: "Webhook endpoint route and config API"
      contains: "api/webhooks/github"
    - path: "lib/agent_com/webhook_history.ex"
      provides: "ETS-backed webhook event log"
      contains: "WebhookHistory"
  key_links:
    - from: "lib/agent_com/endpoint.ex"
      to: "lib/agent_com/webhook_verifier.ex"
      via: "verify_signature/1 call in webhook route"
      pattern: "WebhookVerifier.verify_signature"
    - from: "lib/agent_com/endpoint.ex"
      to: "lib/agent_com/hub_fsm.ex"
      via: "force_transition to :improving"
      pattern: "HubFSM.force_transition.*improving"
    - from: "lib/agent_com/endpoint.ex"
      to: "lib/agent_com/repo_registry.ex"
      via: "list_repos for active repo matching"
      pattern: "RepoRegistry.list_repos"
---

<objective>
Wire the GitHub webhook endpoint into the Endpoint router with push and PR merge handling, repo matching against RepoRegistry, FSM wake transitions, webhook event history, and webhook secret configuration API.

Purpose: This is the core wiring that connects external GitHub events to internal FSM state transitions. Push and PR merge events on active repos wake the FSM from :resting to :improving.

Output: Complete webhook handling endpoint, webhook event history module, webhook secret config API.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-hub-event-wiring/31-RESEARCH.md
@.planning/phases/31-hub-event-wiring/31-01-SUMMARY.md
@lib/agent_com/endpoint.ex
@lib/agent_com/hub_fsm.ex
@lib/agent_com/webhook_verifier.ex
@lib/agent_com/repo_registry.ex
@lib/agent_com/config.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WebhookHistory and add webhook endpoint + config routes</name>
  <files>lib/agent_com/webhook_history.ex, lib/agent_com/endpoint.ex</files>
  <action>
1. Create `lib/agent_com/webhook_history.ex` -- ETS-backed event log capped at 100 entries:
   ```elixir
   defmodule AgentCom.WebhookHistory do
     @moduledoc """
     ETS-backed webhook event history for debugging.

     Stores the last 100 webhook events with timestamp, event type, repo,
     action taken, and delivery ID. Uses the same ETS pattern as HubFSM.History.
     """

     @table :webhook_history
     @max_entries 100

     def init_table do
       case :ets.whereis(@table) do
         :undefined ->
           :ets.new(@table, [
             :named_table, :public, :ordered_set, {:read_concurrency, true}
           ])
           :ok
         _ref -> :ok
       end
     end

     def record(event) do
       timestamp = System.system_time(:millisecond)
       entry = Map.merge(event, %{timestamp: timestamp})
       :ets.insert(@table, {{-timestamp, :erlang.unique_integer()}, entry})
       trim()
       :ok
     end

     def list(opts \\ []) do
       limit = Keyword.get(opts, :limit, 50)
       @table
       |> :ets.tab2list()
       |> Enum.sort()
       |> Enum.take(limit)
       |> Enum.map(fn {_key, entry} -> entry end)
     end

     def clear do
       :ets.delete_all_objects(@table)
       :ok
     end

     defp trim do
       size = :ets.info(@table, :size)
       if size > @max_entries do
         to_delete = size - @max_entries
         @table
         |> :ets.tab2list()
         |> Enum.sort()
         |> Enum.reverse()
         |> Enum.take(to_delete)
         |> Enum.each(fn {key, _} -> :ets.delete(@table, key) end)
       end
     end
   end
   ```

2. Add routes to `lib/agent_com/endpoint.ex`. Place these BEFORE the `match _` catch-all at the bottom. Add them in the "Hub FSM API" section area, after the existing hub routes:

   a. **Webhook endpoint** (no auth -- uses HMAC verification instead):
      ```elixir
      post "/api/webhooks/github" do
        case AgentCom.WebhookVerifier.verify_signature(conn) do
          {:ok, conn} ->
            event_type = Plug.Conn.get_req_header(conn, "x-github-event") |> List.first()
            delivery_id = Plug.Conn.get_req_header(conn, "x-github-delivery") |> List.first()
            handle_github_event(conn, event_type, conn.body_params, delivery_id)

          {:error, reason} ->
            Logger.warning("webhook_signature_failed", reason: inspect(reason))
            send_json(conn, 401, %{"error" => "invalid_signature"})
        end
      end
      ```

   b. **Webhook history endpoint** (no auth -- dashboard read):
      ```elixir
      get "/api/webhooks/github/history" do
        limit = case conn.params["limit"] do
          nil -> 50
          l -> min(String.to_integer(l), 100)
        end
        events = AgentCom.WebhookHistory.list(limit: limit)
        formatted = Enum.map(events, fn e ->
          Map.new(e, fn {k, v} -> {to_string(k), v} end)
        end)
        send_json(conn, 200, %{"events" => formatted})
      end
      ```
      IMPORTANT: Place this BEFORE the POST route or use specific path matching so "history" is not captured as a parameter.

   c. **Webhook secret config** (auth required):
      ```elixir
      put "/api/config/webhook-secret" do
        conn = AgentCom.Plugs.RequireAuth.call(conn, [])
        if conn.halted do
          conn
        else
          secret = conn.body_params["secret"]
          if is_binary(secret) and byte_size(secret) >= 16 do
            :ok = AgentCom.Config.put(:github_webhook_secret, secret)
            send_json(conn, 200, %{"status" => "updated"})
          else
            send_json(conn, 422, %{"error" => "secret must be a string of at least 16 characters"})
          end
        end
      end
      ```

   d. Add private helper functions at the bottom of the module (before `send_json`):

      **handle_github_event/4** for push events:
      - Extract `repository.full_name`, `ref` (branch), `head_commit.id`
      - Call `match_active_repo/1` to check if repo is active
      - If active: call `wake_fsm(:improving, reason)`, record in WebhookHistory with action "accepted"
      - If not active: respond 200 with "ignored", record with action "ignored"

      **handle_github_event/4** for pull_request events:
      - Check `action == "closed"` AND `pull_request.merged == true`
      - If merged: extract repo, PR number, base branch, match active repo, wake FSM
      - If not merged: respond 200 "ignored" (not a merge)

      **handle_github_event/4** catch-all for other event types:
      - Respond 200 with `%{"status" => "ignored", "reason" => "unhandled event type"}`
      - Record in WebhookHistory with action "ignored"

      **match_active_repo/1**:
      - GitHub sends `repository.full_name` as `"owner/repo"`
      - RepoRegistry stores repos with IDs derived from URLs: `url_to_id` strips `https://github.com/` prefix and replaces `/` with `-`, producing `"owner-repo"`
      - Normalize: `String.replace(full_name, "/", "-")`
      - Call `AgentCom.RepoRegistry.list_repos()`, find entry where `r.id == target_id and r.status == :active`
      - Return `{:ok, repo}` or `:not_active`

      **wake_fsm/2**:
      - Try `AgentCom.HubFSM.force_transition(target_state, reason)`
      - Handle `:ok` (log success), `{:error, :invalid_transition}` (FSM already active, log debug)
      - Catch `:exit` for FSM unavailable (log warning)

   e. Initialize WebhookHistory ETS table. Add `AgentCom.WebhookHistory.init_table()` call somewhere it runs at startup. The simplest approach: add it at the top of the webhook POST handler with a one-time init check, OR initialize it in the Application supervisor. The cleanest approach is to call `WebhookHistory.init_table()` at the start of both the POST and GET webhook routes (it's idempotent -- `init_table` checks if table exists first). Alternatively, add it to the HubFSM init (since HubFSM is the consumer of webhook events). Use the HubFSM.init approach since it already initializes History.init_table() there.

   f. Update the `@moduledoc` at the top of endpoint.ex to add the new routes:
      - POST /api/webhooks/github -- GitHub webhook endpoint (HMAC auth)
      - GET  /api/webhooks/github/history -- Webhook event history (no auth)
      - PUT  /api/config/webhook-secret -- Set webhook secret (auth required)

   g. Log all webhook events using Logger.info for debugging, per the specific ideas in CONTEXT.md.
  </action>
  <verify>
Run `mix compile --warnings-as-errors` to confirm compilation.
Verify the webhook route exists: `grep "api/webhooks/github" lib/agent_com/endpoint.ex`.
Verify WebhookHistory module exists and has init_table, record, list functions.
  </verify>
  <done>
POST /api/webhooks/github receives events, verifies HMAC, matches repos, wakes FSM. GET /api/webhooks/github/history returns recent webhook events. PUT /api/config/webhook-secret allows setting the webhook secret. All webhook events are logged and stored in ETS history.
  </done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` passes
2. Webhook route handler processes push and pull_request events
3. Non-active repos produce "ignored" response with 200 status
4. Invalid signatures produce 401 response
5. WebhookHistory stores and retrieves events
6. Webhook secret is configurable via API
</verification>

<success_criteria>
- POST /api/webhooks/github verifies HMAC and dispatches by event type
- Push events on active repos wake FSM to :improving
- PR merge events on active repos wake FSM to :improving
- Non-active repo events return 200 "ignored"
- Webhook history stored in ETS, queryable via GET endpoint
- Webhook secret configurable via PUT /api/config/webhook-secret
- All webhook events logged for debugging
</success_criteria>

<output>
After completion, create `.planning/phases/31-hub-event-wiring/31-02-SUMMARY.md`
</output>
