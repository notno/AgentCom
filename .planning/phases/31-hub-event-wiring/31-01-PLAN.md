---
phase: 31-hub-event-wiring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/agent_com/hub_fsm.ex
  - lib/agent_com/hub_fsm/predicates.ex
  - lib/agent_com/cache_body_reader.ex
  - lib/agent_com/webhook_verifier.ex
  - lib/agent_com/endpoint.ex
autonomous: true

must_haves:
  truths:
    - "HubFSM supports :improving as a valid state alongside :resting and :executing"
    - "Transitions resting->improving and improving->resting are valid"
    - "Raw request body is cached in conn.assigns for HMAC verification"
    - "HMAC-SHA256 signature verification works against GitHub X-Hub-Signature-256 header"
  artifacts:
    - path: "lib/agent_com/hub_fsm.ex"
      provides: "Three-state FSM with :improving"
      contains: "improving"
    - path: "lib/agent_com/hub_fsm/predicates.ex"
      provides: "Predicate evaluation for :improving state"
      contains: "def evaluate(:improving"
    - path: "lib/agent_com/cache_body_reader.ex"
      provides: "Raw body caching for Plug.Parsers"
      contains: "read_body"
    - path: "lib/agent_com/webhook_verifier.ex"
      provides: "HMAC-SHA256 signature verification"
      contains: "verify_signature"
  key_links:
    - from: "lib/agent_com/endpoint.ex"
      to: "lib/agent_com/cache_body_reader.ex"
      via: "Plug.Parsers :body_reader option"
      pattern: "body_reader.*CacheBodyReader"
    - from: "lib/agent_com/hub_fsm.ex"
      to: "lib/agent_com/hub_fsm/predicates.ex"
      via: "Predicates.evaluate/2 for :improving"
      pattern: "evaluate.*improving"
---

<objective>
Add the :improving state to HubFSM and create the foundation modules for GitHub webhook handling: CacheBodyReader for raw body caching and WebhookVerifier for HMAC-SHA256 signature verification.

Purpose: The FSM needs a third state (:improving) that external repository events can wake it into. The webhook infrastructure (body caching + HMAC verification) must exist before the endpoint route handler can be added.

Output: Updated HubFSM with 3-state transitions, CacheBodyReader module, WebhookVerifier module, Plug.Parsers updated with body_reader.
</objective>

<execution_context>
@C:/Users/nrosq/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/nrosq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-hub-event-wiring/31-RESEARCH.md
@lib/agent_com/hub_fsm.ex
@lib/agent_com/hub_fsm/predicates.ex
@lib/agent_com/hub_fsm/history.ex
@lib/agent_com/endpoint.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add :improving state to HubFSM and Predicates</name>
  <files>lib/agent_com/hub_fsm.ex, lib/agent_com/hub_fsm/predicates.ex</files>
  <action>
Update the HubFSM to support a third state `:improving`:

1. In `lib/agent_com/hub_fsm.ex`:
   - Update `@valid_transitions` to:
     ```elixir
     @valid_transitions %{
       resting: [:executing, :improving],
       executing: [:resting],
       improving: [:resting]
     }
     ```
   - Update the `@moduledoc` to document the 3-state FSM (add `:improving` to the states table).
   - In `do_transition/3`, update the cycle count logic: both `resting -> executing` and `resting -> improving` start new cycles.
   - In `init/1`, update the ClaudeClient notification comment to reflect 3 states.

2. In `lib/agent_com/hub_fsm/predicates.ex`:
   - Add evaluation clauses for `:improving` state:
     ```elixir
     # :improving transitions to :resting when budget exhausted
     def evaluate(:improving, %{budget_exhausted: true}) do
       {:transition, :resting, "budget exhausted"}
     end

     # :improving stays active (transitions to :resting handled by watchdog or external signal)
     def evaluate(:improving, _system_state), do: :stay
     ```
   - Update `@moduledoc` to reference 3-state core instead of 2-state.
   - Update `@spec` and parameter docs to include `:improving`.

The :improving state is a peer of :executing -- both transition back to :resting. The :improving state exits via budget exhaustion or watchdog timeout (2 hours). It does NOT automatically transition based on goals -- only external webhook events trigger entry into :improving, and it stays there until the improvement cycle completes or budget/watchdog triggers exit.
  </action>
  <verify>
Run `mix compile --warnings-as-errors` to confirm no compilation errors.
Verify the `@valid_transitions` map includes all three states by grepping for `improving` in hub_fsm.ex.
  </verify>
  <done>
HubFSM supports 3 states: :resting, :executing, :improving. Valid transitions include resting->improving and improving->resting. Predicates evaluate :improving state correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CacheBodyReader and WebhookVerifier modules</name>
  <files>lib/agent_com/cache_body_reader.ex, lib/agent_com/webhook_verifier.ex, lib/agent_com/endpoint.ex</files>
  <action>
1. Create `lib/agent_com/cache_body_reader.ex`:
   ```elixir
   defmodule AgentCom.CacheBodyReader do
     @moduledoc "Caches raw request body in conn.assigns[:raw_body] for HMAC signature verification."

     def read_body(conn, opts) do
       case Plug.Conn.read_body(conn, opts) do
         {:ok, body, conn} ->
           conn = update_in(conn.assigns[:raw_body], fn
             nil -> [body]
             existing -> [body | existing]
           end)
           {:ok, body, conn}

         {:more, body, conn} ->
           conn = update_in(conn.assigns[:raw_body], fn
             nil -> [body]
             existing -> [body | existing]
           end)
           {:more, body, conn}

         {:error, reason} ->
           {:error, reason}
       end
     end
   end
   ```

2. Create `lib/agent_com/webhook_verifier.ex`:
   ```elixir
   defmodule AgentCom.WebhookVerifier do
     @moduledoc """
     Verifies GitHub webhook HMAC-SHA256 signatures.

     Uses the webhook secret from Config GenServer and compares against
     the X-Hub-Signature-256 header using timing-safe comparison.
     """
     import Plug.Conn

     @doc """
     Verify the GitHub webhook signature on a conn.

     Returns `{:ok, conn}` if signature is valid, `{:error, reason}` otherwise.
     Reasons: :invalid_signature, :missing_signature, :no_secret_configured
     """
     def verify_signature(conn) do
       with [signature_header] <- get_req_header(conn, "x-hub-signature-256"),
            "sha256=" <> received_hex <- signature_header,
            {:ok, secret} <- get_webhook_secret() do
         raw_body = conn.assigns[:raw_body] |> Enum.reverse() |> Enum.join()

         computed_hex =
           :crypto.mac(:hmac, :sha256, secret, raw_body)
           |> Base.encode16(case: :lower)

         if Plug.Crypto.secure_compare(computed_hex, received_hex) do
           {:ok, conn}
         else
           {:error, :invalid_signature}
         end
       else
         [] -> {:error, :missing_signature}
         nil -> {:error, :missing_signature}
         {:error, :no_secret_configured} -> {:error, :no_secret_configured}
         _ -> {:error, :missing_signature}
       end
     end

     defp get_webhook_secret do
       case AgentCom.Config.get(:github_webhook_secret) do
         nil -> {:error, :no_secret_configured}
         secret -> {:ok, secret}
       end
     end
   end
   ```

3. Update `lib/agent_com/endpoint.ex` -- change the Plug.Parsers configuration to use the CacheBodyReader:
   ```elixir
   plug(Plug.Parsers,
     parsers: [:json],
     pass: ["application/json"],
     body_reader: {AgentCom.CacheBodyReader, :read_body, []},
     json_decoder: Jason
   )
   ```
   This is a single-line addition to the existing Plug.Parsers call. The body_reader caches raw bytes in conn.assigns[:raw_body] for all requests (low cost since the body is read anyway).
  </action>
  <verify>
Run `mix compile --warnings-as-errors` to confirm all three modules compile.
Verify CacheBodyReader is wired into Plug.Parsers by grepping for `body_reader` in endpoint.ex.
  </verify>
  <done>
CacheBodyReader caches raw request body for HMAC verification. WebhookVerifier performs timing-safe HMAC-SHA256 comparison against the X-Hub-Signature-256 header. Plug.Parsers is configured to use CacheBodyReader.
  </done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` passes
2. `grep -r "improving" lib/agent_com/hub_fsm.ex` shows the new state in transitions
3. `grep -r "body_reader" lib/agent_com/endpoint.ex` shows CacheBodyReader wired in
4. Both new modules exist: cache_body_reader.ex, webhook_verifier.ex
</verification>

<success_criteria>
- HubFSM has 3 valid states with correct transition map
- Predicates handle :improving evaluation
- CacheBodyReader preserves raw body in conn.assigns
- WebhookVerifier validates HMAC-SHA256 signatures
- Endpoint uses CacheBodyReader for Plug.Parsers
- All code compiles without warnings
</success_criteria>

<output>
After completion, create `.planning/phases/31-hub-event-wiring/31-01-SUMMARY.md`
</output>
